<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Luvvies Crush</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg1:#f7f2ff;
      --bg2:#eaf6ff;
      --card:#ffffffd9;
      --card2:#ffffffef;
      --stroke:rgba(17,13,26,.10);
      --shadow: 0 18px 60px rgba(20,10,60,.12);
      --txt:#1d1334;

      --cols: 10;
      --rows: 10;
      --cell: 54px;
      --gap: 8px;
      --pad: 14px;
      --boardRadius: 26px;

      --toastMs: 2600ms;
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body.dark{
      --bg1:#141020;
      --bg2:#1f1830;
      --card:#252035d9;
      --card2:#2d2640ef;
      --stroke:rgba(255,255,255,.08);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --txt:#f2f0ff;
    }
    body.dark .diffPills{
      background: rgba(30,25,45,.78);
      border:1px solid rgba(255,255,255,.08);
    }
    body.dark .diffPills label{ color:#cfc5e5; }
    body.dark .luvCard, body.dark .lbItem, body.dark .toast{
      background: rgba(40,35,60,.82);
      border:1px solid rgba(255,255,255,.08);
      color: var(--txt);
    }
    body.dark .lbRow input{
      background: rgba(40,35,60,.92);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }
    body.dark .modal{
      background: rgba(30,26,45,.96);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txt);
      overflow:hidden;
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      position:relative;
      transition: background 0.3s ease, color 0.3s ease;
    }

    /* Scroll container (scrollbar hidden) */
    #page{
      height:100vh;
      overflow:auto;
      position:relative;
      z-index:0;
    }
    #page{ scrollbar-width:none; }
    #page::-webkit-scrollbar{ width:0; height:0; }

    /* Scrollender Background Layer */
    #scrollBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      min-height: 120vh;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,105,180,.14), transparent 48%),
        radial-gradient(circle at 85% 25%, rgba(122,216,255,.20), transparent 52%),
        radial-gradient(circle at 55% 75%, rgba(255,209,90,.16), transparent 50%),
        linear-gradient(120deg,
          rgba(255,79,185,.18),
          rgba(255,209,90,.14),
          rgba(122,216,255,.18),
          rgba(139,92,246,.14),
          rgba(255,79,185,.18)
        );
      background-size: auto, auto, auto, 300% 300%;
      filter: blur(18px);
      opacity:.55;
      animation: bgMove 18s ease-in-out infinite;
    }
    @keyframes bgMove{
      0%{ background-position: 0% 50% }
      50%{ background-position: 100% 50% }
      100%{ background-position: 0% 50% }
    }

    #globalBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      overflow:hidden;
    }

    #darkOverlay{
      position:fixed;
      inset:0;
      z-index:4;
      background:#000;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }

    /* Background luvvies: langsamer + fade, immer hinter allem */
    .bgLuv{
      position:absolute;
      width: clamp(150px, 17vw, 300px);
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.10));
      opacity:.72;
      animation: floaty 18s ease-in-out infinite;
      z-index:0;
      pointer-events:none;
    }
    .bgLuv img{ width:100%; height:auto; display:block; }
    @keyframes floaty{
      0%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
      50%{ transform: translate(10px,-16px) rotate(1.2deg); opacity:.82; }
      100%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
    }

    /* Subtle twinkles (statt bubbles) */
    .twinkle{
      position:absolute;
      width: 10px; height: 10px;
      left:0; top:0;
      transform: translate(-50%,-50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.15));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: tw 1200ms ease-out forwards;
      filter: drop-shadow(0 0 18px rgba(255,79,185,.18));
    }
    @keyframes tw{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(0deg)}
      20%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-65%) scale(1.15) rotate(140deg)}
    }

    #app{
      width:min(1100px, 96vw);
      margin: 18px auto 28px;
      position:relative;
      z-index:5; /* Vordergrund */
    }

    .topRow{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
      z-index:6;
    }

    #infoBack{ z-index: 100000; } /* Ensure Bio is above Menu */
    /* Hide menus in fullscreen */
    body.fs .below, body.fs .topRow, body.fs .stats, body.fs .progressRow, body.fs #luvPanel, body.fs #rightPanel, body.fs #settingsBack {
      display: none !important;
    }

    .diffWrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .diffWrap .label{font-weight:900;opacity:.9;margin-right:4px}
    .diffPills{
      display:flex;
      gap:8px; padding:6px;
      border-radius:999px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(17,13,26,.08);
    }
    .diffPills input{display:none}
    .diffPills label{
      cursor:pointer;
      user-select:none;
      padding:10px 14px; border-radius:999px;
      font-weight:900; font-size:14px;
      color:#2b1b4f;
      transition: transform .12s ease, background .2s ease;
    }
    .diffPills input:checked + label{
      background: linear-gradient(135deg, #ff4fb9, #7ad8ff);
      background-size:200% 100%;
      animation: pillGlow 2.2s ease-in-out infinite;
      color:#fff;
      box-shadow: 0 10px 22px rgba(255,79,185,.22);
      transform: translateY(-1px);
    }
    @keyframes pillGlow{
      0%{ background-position:0% 50% }
      50%{ background-position:100% 50% }
      100%{ background-position:0% 50% }
    }

    /* Jelly Button */
    .Btn{
      position: relative;
      height: 46px;
      padding: 0 16px;
      border-radius: 999px;
      border: none;
      background-color: rgb(151, 95, 255);
      color: white;
      box-shadow: 0px 10px 10px rgb(210, 187, 253) inset,
                  0px 5px 10px rgba(5, 5, 5, 0.18),
                  0px -10px 10px rgb(124, 54, 255) inset;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap:8px;
      font-weight:1000;
      letter-spacing:.1px;
      transition: transform .12s ease;
      white-space:nowrap;
    }
    .Btn::before{
      width: 70%; height: 2px; position: absolute;
      background-color: rgba(250, 250, 250, 0.678);
      content: ""; filter: blur(1px);
      top: 7px; border-radius: 50%; left: 15%;
    }
    .Btn::after{
      width: 70%; height: 2px; position: absolute;
      background-color: rgba(250, 250, 250, 0.137);
      content: ""; filter: blur(1px);
      bottom: 7px; border-radius: 50%; left: 15%;
    }
    .Btn:hover { animation: jello-horizontal 0.9s both; }
    .Btn:active{ transform: scale(.98); }
    @keyframes jello-horizontal {
      0% { transform: scale3d(1, 1, 1); }
      30% { transform: scale3d(1.20, 0.80, 1); }
      40% { transform: scale3d(0.80, 1.20, 1); }
      50% { transform: scale3d(1.12, 0.88, 1); }
      65% { transform: scale3d(0.96, 1.04, 1); }
      75% { transform: scale3d(1.04, 0.96, 1); }
      100% { transform: scale3d(1, 1, 1); }
    }
    .Btn.secondary{
      background: linear-gradient(135deg, #ff4fb9, #ff9adf);
      box-shadow: 0px 10px 10px rgba(255,200,235,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.15),
                  0px -10px 10px rgba(255,60,180,.55) inset;
    }
    .Btn.ghost{
      background: rgba(255,255,255,.8);
      color:#2a1849;
      box-shadow: 0px 10px 10px rgba(240,240,255,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.10),
                  0px -10px 10px rgba(220,220,255,.55) inset;
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      z-index:6;
    }

    .stats{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
      position:relative;
      z-index:6;
    }
    .stat{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      min-height: 62px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .stat .k{font-weight:900; font-size:12px; opacity:.7}
    .stat .v{font-weight:1000; font-size:20px; margin-top:2px}

    .progressRow{
      margin-top: 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      display:flex;
      align-items:center;
      gap:10px;
      position:relative;
      z-index:6;
    }
    .progressRow b{font-size:14px}
    .bar{
      flex:1;
      height: 14px;
      border-radius:999px;
      background: rgba(140,120,200,.18);
      overflow:hidden;
      border:1px solid rgba(60,20,120,.10);
      position:relative;
    }
    .bar > i{
      display:block;
      height:100%;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg,
        #ff4fb9,
        #ffcf5a,
        #7ad8ff,
        #8b5cf6,
        #ff4fb9
      );
      background-size: 300% 100%;
      animation: barHue 3.2s linear infinite;
      box-shadow: 0 0 18px rgba(255,79,185,.22);
      transition: width .25s ease;
    }
    @keyframes barHue{
      0%{background-position:0% 50%}
      100%{background-position:100% 50%}
    }
    .pct{font-weight:1000; min-width:46px; text-align:right}

    .playArea{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 14px;
      position:relative;
      overflow:visible;
      z-index:6; /* Vordergrund */
      transition: all 0.3s ease;
    }

    /* Maximize Mode */
    body.maximized .topRow, body.maximized .stats, body.maximized .progressRow, body.maximized .below {
       display:none !important;
    }
    body.maximized #app {
       width: 98vw; margin: 10px auto;
    }
    body.maximized .playArea {
       height: 90vh; /* force height */
       padding: 4px;
       border-radius: 12px;
    }

    #boardWrap{
      position:relative;
      width:100%;
      min-height: 64vh;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
      padding: 8px;
      touch-action: none;
    }
    body.maximized #boardWrap { min-height: 90vh; }

    #board{
      position:relative;
      z-index:12; /* Board immer vorne */
      padding: var(--pad);
      border-radius: var(--boardRadius);
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.86), rgba(255,255,255,.35)),
        radial-gradient(circle at 80% 70%, rgba(255,209,90,.16), transparent 55%),
        radial-gradient(circle at 30% 75%, rgba(255,79,185,.12), transparent 55%),
        radial-gradient(circle at 75% 25%, rgba(122,216,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.62), rgba(255,255,255,.36));
      border: 1px solid rgba(17,13,26,.08);
      box-shadow:
        0 18px 70px rgba(20,10,60,.10),
        0 6px 16px rgba(0,0,0,.06) inset;
      overflow:hidden;
      animation: boardFade 20s ease-in-out infinite;
      transition: filter 0.3s ease;
    }
    /* Dark Mode Board */
    body.dark #board{
      background:
        radial-gradient(circle at 20% 20%, rgba(60,50,90,.86), rgba(40,30,60,.35)),
        radial-gradient(circle at 80% 70%, rgba(100,80,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(40,35,60,.62), rgba(30,25,50,.36));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 70px rgba(0,0,0,.5), 0 6px 16px rgba(0,0,0,.3) inset;
    }
    @keyframes boardFade{
      0%{ filter:hue-rotate(0deg) saturate(1) }
      50%{ filter:hue-rotate(10deg) saturate(1.04) }
      100%{ filter:hue-rotate(0deg) saturate(1) }
    }

    /* Swirl overlay (statt bubble pattern) */
    #board:before{
      content:"";
      position:absolute; inset:-20px;
      background:
        conic-gradient(from 180deg at 35% 35%,
          rgba(255,255,255,.18),
          rgba(255,255,255,0) 22%,
          rgba(255,255,255,.12) 45%,
          rgba(255,255,255,0) 65%,
          rgba(255,255,255,.18)
        );
      opacity:.45;
      mix-blend-mode: soft-light;
      filter: blur(0.2px);
      pointer-events:none;
    }
    #board:after{
      content:"";
      position:absolute; inset:0;
      border-radius: var(--boardRadius);
      box-shadow:
        0 2px 0 rgba(255,255,255,.55) inset,
        0 -6px 12px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    #fxLayer{
      pointer-events:none;
      position:absolute;
      inset:0;
      z-index:20;
    }

    #fsBg{
      position:absolute;
      inset:0;
      z-index:5; /* hinter board */
      pointer-events:none;
      overflow:hidden;
      display:none;
    }
    body.fs #fsBg{ display:block; }

    /* Tiles */
    .tile{
      position:absolute;
      width: var(--cell);
      height: var(--cell);
      left:0; top:0;
      transform: translate(var(--x), var(--y));
      transition: transform 190ms cubic-bezier(.2,.9,.2,1.0);
      will-change: transform;
      z-index:15;
    }
    .tile.bigMellow{
      width: calc(var(--cell) * 2 + var(--gap));
      height: calc(var(--cell) * 2 + var(--gap));
      z-index:25;
    }
    .tile.dragging{ transition:none !important; z-index: 50; filter: drop-shadow(0 22px 20px rgba(0,0,0,.20)); }
    .tile.locked{ pointer-events:none; }

    .plate{
      width:100%; height:100%;
      border-radius: 16px;

      /* Palette-driven candy plate (makes each Luvvy easier to recognize) */
      background: linear-gradient(145deg, var(--p1), var(--p2));
      border: 1px solid rgba(255,255,255,.58);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.32) inset,
        0 0 0 2px var(--p1) inset,
        0 16px 26px rgba(20,10,60,.12),
        0 6px 10px rgba(0,0,0,.08),
        0 -10px 18px rgba(255,255,255,.35) inset;
      position:relative;
      overflow:hidden;

      transform: translateY(var(--oy, 0px)) scale(1);
      opacity: var(--op, 1);
      transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease, filter 200ms ease;
    }

    .plate::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle at 28% 18%, rgba(255,255,255,.88), rgba(255,255,255,0) 58%),
        linear-gradient(135deg, rgba(255,255,255,.30), rgba(240,240,255,.10));
      opacity:.85;
      pointer-events:none;
    }

    /* Subtle candy sparkle */
    .plate::after{
      content:"";
      position:absolute;
      inset:-40%;
      background:
        radial-gradient(circle at 60% 30%, rgba(255,255,255,.16), rgba(255,255,255,0) 56%),
        radial-gradient(circle at 20% 70%, rgba(255,255,255,.10), rgba(255,255,255,0) 62%);
      transform: rotate(12deg);
      opacity:.45;
      pointer-events:none;
    }

    /* Variant B: clear visual difference (helps prevent "combo feels broken") */
    .tile[data-variant="B"] .plate{
      filter: saturate(1.18) contrast(1.06);
    }
    .tile[data-variant="B"] .plate::after{
      background:
        repeating-linear-gradient(45deg, rgba(255,255,255,0) 0 10px, rgba(255,255,255,.22) 10px 14px),
        radial-gradient(circle at 60% 30%, rgba(255,255,255,.20), rgba(255,255,255,0) 58%);
      opacity:.55;
    }

    .variantBadge{
      position:absolute;
      top:6px;
      left:6px;
      width:18px;
      height:18px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:11px;
      letter-spacing:.02em;
      color:#fff;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.72);
      box-shadow: 0 10px 16px rgba(0,0,0,.16);
      pointer-events:none;
      z-index:3;
      text-shadow: 0 1px 2px rgba(0,0,0,.22);
    }
    /* Enhance image contrast */
    .tile img {
       filter: drop-shadow(0 4px 8px rgba(0,0,0,.15)) saturate(1.1);
    }
    .tile.bigMellow .plate{ border-radius: 26px; }

    /* Swirl on tile (subtle) */
    .plate:before{
      content:"";
      position:absolute; inset:-18px;
      background:
        conic-gradient(from 120deg at 35% 35%,
          rgba(255,255,255,.18),
          rgba(255,255,255,0) 26%,
          rgba(255,255,255,.12) 54%,
          rgba(255,255,255,0) 72%,
          rgba(255,255,255,.18)
        );
      opacity:.35;
      mix-blend-mode: soft-light;
      pointer-events:none;
    }
    .plate:after{
      content:"";
      position:absolute; inset:0;
      border-radius:inherit;
      box-shadow:
        0 2px 0 rgba(255,255,255,.55) inset,
        0 -6px 12px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    /* Luvvies auf der Karte gr√∂√üer */
    .tile img{
      position:absolute;
      inset: 6%;
      width:88%;
      height:88%;
      object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.10));
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }
    .tile.bigMellow img{
      inset: 8%;
      width:84%;
      height:84%;
    }

    /* Question mark powerup visual */
    .qmark{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      font-size: 26px;
      color:#fff;
      text-shadow: 0 10px 18px rgba(0,0,0,.22);
      pointer-events:none;
    }

    /* Animierter Power Background (f√ºr Powerups + ??? + Lovelie) */
    .powerAnim .plate{
      background: linear-gradient(135deg, #ff4fb9, #ffcf5a, #7ad8ff, #8b5cf6, #ff4fb9) !important;
      background-size: 320% 100% !important;
      animation: mystHue 3.8s ease-in-out infinite;
    }
    @keyframes mystHue{
      0%{background-position:0% 50%}
      50%{background-position:100% 50%}
      100%{background-position:0% 50%}
    }

    /* Puff reveal (??? -> random) */
    .tile.puff .plate{ animation: puff 520ms ease both; }
    @keyframes puff{
      0%{ transform: translateY(0) scale(1); filter: blur(0px); }
      40%{ transform: translateY(-2px) scale(1.12); filter: blur(0.2px); }
      100%{ transform: translateY(0) scale(1); filter: blur(0px); }
    }

    /* Pop */
    .pop .plate{ animation: popPlate 420ms ease-in both; }
    @keyframes popPlate{
      0%{ transform: translateY(0) scale(1); opacity:1; }
      55%{ transform: translateY(-2px) scale(1.14); opacity:1; }
      100%{ transform: translateY(8px) scale(.30); opacity:0; }
    }

    /* Landing bounce */
    .land .plate{ animation: landPlate 560ms cubic-bezier(.2,.9,.2,1) both; }
    @keyframes landPlate{
      0%{ transform: translateY(0) scale(1); }
      28%{ transform: translateY(4px) scale(1.06, .98); }
      58%{ transform: translateY(-4px) scale(.99,1.04); }
      100%{ transform: translateY(0) scale(1); }
    }

    /* Spawn glow */
    .spawnGlow .plate{ animation: spawnGlow 700ms ease-out both; }
    @keyframes spawnGlow{
      0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(.92); }
      55%{ filter: drop-shadow(0 0 20px rgba(255,255,255,.95)); transform: translateY(0) scale(1.05); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(1); }
    }

    /* Hint auff√§lliger */
    .tile.hint .plate{
      outline: 3px solid rgba(255,79,185,.85);
      box-shadow:
        0 0 0 5px rgba(122,216,255,.35),
        0 0 30px rgba(255,79,185,.28),
        0 18px 40px rgba(0,0,0,.12);
      animation: hintGlow 1.0s ease-in-out infinite;
    }
    @keyframes hintGlow{
      0%,100%{ filter: saturate(1) brightness(1); }
      50%{ filter: saturate(1.25) brightness(1.12); }
    }

    /* Mellow HP Zahl: kein Background, gr√∂√üer, fade */
    .hp{
      position:absolute;
      right:10px; top:8px;
      font-weight:1000;
      font-size: 18px;
      color: rgba(255,255,255,.98);
      text-shadow:
        0 10px 20px rgba(0,0,0,.18),
        0 2px 0 rgba(0,0,0,.12);
      z-index:30;
      background:none;
      border:none;
      box-shadow:none;
      padding:0;
      animation: hpFade 2.2s ease-in-out infinite;
      pointer-events:none;
    }
    .tile.bigMellow .hp{
      font-size: 22px;
      right:14px;
      top:12px;
    }
    @keyframes hpFade{
      0%,100%{ opacity:.60; transform: translateY(0); }
      50%{ opacity:1; transform: translateY(-1px); }
    }

    /* Below panels */
    .below{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:stretch;
      position:relative;
      z-index:6;
    }
    .below > .panel{height:100%}

    @media (max-width: 880px){
      .stats{grid-template-columns: repeat(2, minmax(0,1fr));}
      .below{grid-template-columns:1fr;}
      #boardWrap{min-height: 52vh;}
    }

    .panel{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      position:relative;
      z-index:6;
    }
    .panel h3{margin:0 0 10px;font-size:16px}

    .luvGrid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:10px}
    .luvCard{
      display:flex;gap:10px;align-items:center;
      padding:10px;border-radius:18px;
      background: rgba(255,255,255,.82);
      border:1px solid rgba(17,13,26,.08);
      box-shadow: 0 12px 26px rgba(20,10,60,.08);
      cursor:pointer;transition: transform .12s ease;
    }
    .luvCard:hover{ transform: translateY(-1px); }
    .luvCard img{
      width: 78px;height: 78px;object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.12));
      flex:0 0 auto;
    }
    .luvCard b{display:block}
    .luvCard small{opacity:.7;font-weight:900}

    #rightPanel{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 100%;
    }

    .lbRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .lbRow input{
      flex:1; min-width: 170px; height:44px;
      border-radius:14px; border:1px solid rgba(17,13,26,.12);
      padding:0 12px; font-weight:900; outline:none;
      background: rgba(255,255,255,.92);
    }

    /* Leaderboard scrollbar: aktiv, aber optisch clean */
    .lbList{
      display:flex;
      flex-direction:column; gap:8px;
      overflow:auto;
      padding-right:6px;
      flex:1;
      min-height: 260px;
      max-height: 65vh;
      border-radius: 16px;
      scrollbar-width: thin;
    }
    .lbList::-webkit-scrollbar{ width: 10px; }
    .lbList::-webkit-scrollbar-thumb{
      background: rgba(151,95,255,.35);
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.6);
    }
    .lbList::-webkit-scrollbar-track{
      background: rgba(255,255,255,.35);
      border-radius: 999px;
    }

    .lbItem{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      background: rgba(255,255,255,.82);
      border:1px solid rgba(17,13,26,.08);
      border-radius:16px;
      padding:10px 10px;
      box-shadow: 0 10px 24px rgba(20,10,60,.07);
      opacity:0;
      animation: lbSlideIn 0.4s cubic-bezier(.2,.9,.2,1) forwards;
    }
    @keyframes lbSlideIn{
      from{ opacity:0; transform: translateY(12px) scale(.96); }
      to{ opacity:1; transform: translateY(0) scale(1); }
    }
    .lbItem .left b{display:block}
    .lbItem .left small{opacity:.7;font-weight:900}
    .lbItem .score{font-weight:1000}

    /* Ranks */
    .lbItem.rank1{
      background:linear-gradient(90deg, rgba(255,215,0,.28), rgba(255,255,255,.14));
      box-shadow:0 0 18px rgba(255,215,0,.65);
      animation:shine 1.9s linear infinite;
    }
    .lbItem.rank2{
      background:linear-gradient(90deg, rgba(192,192,192,.25), rgba(255,255,255,.12));
      box-shadow:0 0 14px rgba(220,220,220,.55);
      animation:pulse 1.6s ease-in-out infinite;
    }
    .lbItem.rank3{
      background:linear-gradient(90deg, rgba(205,127,50,.25), rgba(255,255,255,.10));
      box-shadow:0 0 12px rgba(205,127,50,.55);
      animation:bounceMedal 1.6s ease-in-out infinite;
    }
    @keyframes shine{
      0%{filter:brightness(1)}
      50%{filter:brightness(1.25)}
      100%{filter:brightness(1)}
    }
    @keyframes pulse{
      0%,100%{transform:scale(1)}
      50%{transform:scale(1.03)}
    }
    @keyframes bounceMedal{
      0%,100%{transform:translateY(0)}
      50%{transform:translateY(-2px)}
    }

    /* Toasts -> rechts seitlich (Desktop/Fullscreen), Mobile oben */
    #toast{
      position: fixed;
      right: 16px;
      top: 110px;
      z-index: 9999;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
      max-width: min(420px, 92vw);
    }
    @media (max-width: 560px){
      #toast{
        left: 50%;
        right: auto;
        top: 10%;
        transform: translateX(-50%);
        align-items:center;
      }
    }
    .toast{
      width: 100%;
      background: rgba(255,255,255,.92);
      border:1px solid rgba(17,13,26,.12);
      border-radius: 20px;
      padding: 12px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.15);
      font-weight:1000;
      text-align:left;
      animation: toastIn var(--toastMs) ease forwards;
    }
    .toast small{display:block;font-weight:900;opacity:.75;margin-top:3px}
    @keyframes toastIn{
      0%{opacity:0; transform: translateY(-10px) scale(.96)}
      16%{opacity:1; transform: translateY(0) scale(1)}
      86%{opacity:1}
      100%{opacity:0; transform: translateY(-10px) scale(.98)}
    }

    /* Modal */
    .modalBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(10,8,18,.55);
      z-index: 99998;
      padding: 18px;
    }
    .modal{
      width: min(760px, 96vw);
      max-height: min(82vh, 780px);
      overflow:auto;
      background: rgba(255,255,255,.96);
      border-radius: 24px;
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 28px 90px rgba(0,0,0,.25);
      padding: 14px 14px 12px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{font-weight:800; opacity:.9}
    .modal .foot{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      margin-top:12px;
    }
    .tiny{font-size:12px; opacity:.8; font-weight:900}

    /* Greeting */
    .greet{
      text-align:center;
      padding: 18px 14px 14px;
    }
    .greet input{
       width: 80%;
       max-width: 320px;
       margin: 10px auto;
       display:block;
       padding: 12px;
       border-radius: 12px;
       border: 1px solid rgba(17,13,26,.15);
       font-weight: 900;
       font-size: 16px;
       text-align:center;
       background: rgba(255,255,255,.9);
    }
    .greet img{
      width:min(380px, 82vw);
      height:auto;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,.14));
      margin: 4px auto 10px;
      display:block;
    }
    .greet h2{ margin: 6px 0 8px; }
    .greet .sub{
      font-weight:900;
      opacity:.8;
      margin: 0 auto 10px;
      max-width: 560px;
    }
    .greet .cta{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }

    /* FX star */
    .star{
      position:absolute;
      left:0; top:0;
      width: 12px; height: 12px;
      transform: translate(-50%,-50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.2));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: starPop 820ms ease forwards;
      filter: drop-shadow(0 0 8px rgba(255,255,255,.8)); /* Brighter flash */
    }
    @keyframes starPop{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.4) rotate(0deg)}
      20%{opacity:1; transform:translate(-50%,-50%) scale(1) rotate(20deg)}
      100%{opacity:0; transform:translate(-50%,-75%) scale(.9) rotate(160deg)}
    }

    .ring{
      position:absolute; left:0; top:0;
      width: 10px; height: 10px;
      border-radius:999px;
      border: 3px solid rgba(255,255,255,.95);
      box-shadow: 0 0 30px rgba(255,79,185,.28);
      transform: translate(-50%,-50%) scale(.4);
      opacity:0;
      animation: ring 720ms ease-out forwards;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes ring{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.35)}
      15%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(4.2)}
    }

    /* Fullscreen */
    body.fs{ overflow:hidden; }
    body.fs #app{ width: min(1200px, 98vw); margin: 10px auto; }
    body.fs #boardWrap{
      min-height: 100vh;
      padding-top: 84px;
      padding-bottom: 12px;
    }

    /* FS HUD: left / center / right */
    #fsHud{
      position:absolute;
      left: 14px;
      right: 14px;
      top: 12px;
      z-index: 60;
      display:none;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    body.fs #fsHud{display:flex}

    .hudLeft, .hudCenter, .hudRight{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .hudCenter{
      justify-content:center;
      flex: 1;
      min-width: 240px;
    }

    .hudChip{
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      font-weight:1000;
      font-size: 13px;
      white-space:nowrap;
      pointer-events:none;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    @keyframes chipFade{
      0%,100%{ opacity:.92; }
      50%{ opacity:1; }
    }
    .hudChip.color{
      background: linear-gradient(135deg, rgba(255,79,185,.88), rgba(122,216,255,.86));
      color:#fff;
      border:1px solid rgba(255,255,255,.35);
      background-size: 200% 200%;
      animation: hudGlow 3.2s ease-in-out infinite;
      opacity:1;
    }
    @keyframes hudGlow{
      0%{ background-position: 0% 50%; }
      50%{ background-position: 100% 50%; }
      100%{ background-position: 0% 50%; }
    }

    .hudProg{
      pointer-events:none;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      min-width: min(520px, 70vw);
      justify-content:center;
    }
    .hudProg .pbar{
      flex:1;
      height: 12px;
      border-radius:999px;
      overflow:hidden;
      background: rgba(140,120,200,.18);
      border:1px solid rgba(60,20,120,.10);
      min-width: 160px;
    }
    .hudProg .pbar i{
      display:block;height:100%;width:0%;
      border-radius:999px;
      background: linear-gradient(90deg,#ff4fb9,#ffcf5a,#7ad8ff,#8b5cf6,#ff4fb9);
      background-size: 300% 100%;
      animation: barHue 3.2s linear infinite;
      transition: width .25s ease;
      box-shadow:0 0 18px rgba(255,79,185,.22);
    }

    .hudBtn{
      pointer-events:auto;
      height: 40px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(17,13,26,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 14px 34px rgba(0,0,0,.12);
      font-weight:1000;
      cursor:pointer;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    .hudBtn:hover{ animation: jello-horizontal .9s both; }

    /* Colored fullscreen buttons */
    .hudBtn.exit{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,130,130,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
    .hudBtn.guide{
      background: linear-gradient(135deg, rgba(90,170,255,.92), rgba(140,220,255,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
    .hudBtn.hint{
      background: linear-gradient(135deg, rgba(255,79,185,.92), rgba(255,170,230,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
      animation: pulseBtn 2s infinite;
    }
    @keyframes pulseBtn{
      0%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0.7); }
      70%{ transform:scale(1.05); box-shadow: 0 0 0 10px rgba(255,79,185, 0); }
      100%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0); }
    }

    /* Mobile/Tablet fullscreen layout */
    @media (max-width: 820px){
      body.fs #boardWrap{ padding-top: 2px; padding-bottom: 90px; min-height: 98vh; }
      #fsHud{
        top:auto;
        bottom: 10px;
        align-items:flex-end;
      }
      .hudProg{ min-width: min(520px, 92vw); }
      .hudBtn{ height:44px; padding:0 14px; }
    }
    @media (orientation: portrait) and (min-width: 600px){
      body.fs #boardWrap{ padding-top: 16px; padding-bottom: 110px; }
      .hudProg{ min-width: min(560px, 92vw); }
    }

    /* Better large screen FS */
    @media (min-width: 1600px) and (min-height: 900px){
       body.fs #boardWrap{ padding-top: 60px; padding-bottom: 40px; min-height: 100vh; }
       #scrollBg{ min-height: 150vh; }
    }
    @media (min-height: 1400px){
       body.fs #boardWrap{ min-height: 1500px; justify-content:center; }
    }
  </style>
</head>

<body>
  <div id="page">
    <div id="scrollBg"></div>
    <div id="globalBg"></div>
    <div id="darkOverlay"></div>
    <div id="toast"></div>

    <div class="modalBack" id="greetBack">
      <div class="modal greet">
        <img id="greetLogo" alt="Logo" />
        <h2>Willkommen bei Luvvies Crush üç≠</h2>
        <div class="sub">
          Match ‚Ä¢ Powerups ‚Ä¢ Mellow-Blocks ‚Ä¢ Lovelie-Bonus ‚ú®<br>
          Bounciger, weicher Candy-Style ‚Äì und jetzt mit richtigem Fullscreen-HUD.
        </div>
        <input id="greetName" placeholder="Dein Name" maxlength="24" />
        <div class="cta">
          <button class="Btn ghost" id="greetGuide">Anleitung</button>
          <button class="Btn secondary" id="greetPlay">Spielen</button>
        </div>
        <div class="tiny" style="margin-top:10px;">(Dieser Screen erscheint nur 1√ó pro Tag.)</div>
      </div>
    </div>

    <div class="modalBack" id="introBack">
      <div class="modal">
        <h2>Anleitung ‚Äì Luvvies Crush üç≠</h2>
        <ul>
          <li><b>Match 3+</b> gleiche Luvvies (gleiche Figur + gleiche Variant-Farbe).</li>
          <li><b>4er Match</b> ‚Üí <b>Sourworm</b> (Reihe/Spalte je nach Drag)</li>
          <li><b>5er Match</b> ‚Üí <b>Citrussy</b> (Stern Radius 3)</li>
          <li><b>T/L Match</b> ‚Üí <b>Koala</b> (Magie)</li>
          <li><b>Koala + Citrussy</b> ‚Üí 2√ó Board Clean & 2√ó Punkte!</li>
          <li><b>Wurm + Wurm</b> ‚Üí ‚ÄúZu sauer!‚Äù Welle</li>
          <li><b>2√ó Sleepy + 1√ó Mondlie</b> ‚Üí Shuffle <b>4√ó4</b> ‚ú®</li>
          <li><b>2√ó Joyce + 1√ó Smokey</b> ‚Üí Buddy Burst</li>
          <li><b>2√ó Smokey + 1√ó Simba</b> ‚Üí Best Buddy Wave (ab Lvl 4)</li>
          <li><b>Mellow</b> ab Level 3 (alle 4 Level), hat 3 HP ‚Ä¢ Clears daneben ziehen HP ab</li>
          <li><b>???</b> klicken ‚Üí <b>random</b> Powerup/Bonus/Block (mit Puff-Animation)</li>
          <li><b>Swap ohne Match</b> kostet <b>1 Move</b> (Live-Swap).</li>
          <li><b>Keine Z√ºge</b> ‚Üí Auto-Shuffle, ‚àí1 Move.</li>
        </ul>
        <div class="foot">
          <button class="Btn ghost" id="introClose">Schlie√üen</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="gameOverBack" style="z-index:99999;">
      <div class="modal" style="text-align:center;">
        <h2 style="font-size:32px;margin-bottom:4px;">GAME OVER üòµ</h2>
        <div class="sub" style="font-size:18px;margin-bottom:18px;">Keine Moves mehr m√∂glich!</div>

        <div class="stat" style="margin:0 auto 18px; max-width:200px;">
           <div class="k">Final Score</div>
           <div class="v" id="goScore">0</div>
        </div>

        <input id="goName" placeholder="Dein Name" maxlength="24" style="width:80%;max-width:320px;margin:0 auto 14px;display:block;padding:12px;border-radius:12px;border:1px solid rgba(17,13,26,.15);font-weight:900;font-size:16px;text-align:center;background:rgba(255,255,255,.9);" />

        <div class="cta" style="justify-content:center;gap:12px;">
           <button class="Btn" id="goPost">Score Posten</button>
           <button class="Btn secondary" id="goNew">Neues Spiel</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="infoBack">
      <div class="modal">
        <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
          <img id="infoImg" src="" alt=""
               style="width:172px;height:172px;object-fit:contain;filter:drop-shadow(0 18px 28px rgba(0,0,0,.18));">
          <div style="min-width:240px;">
            <h2 id="infoName" style="margin:0 0 6px">‚Äî</h2>
            <div class="tiny" id="infoTag">‚Äî</div>
            <div style="height:10px"></div>
            <div class="panel" style="padding:10px; border-radius:18px;">
              <b>Ability</b>
              <div id="infoAbility" style="margin-top:6px;font-weight:900;opacity:.9;">‚Äî</div>
            </div>
          </div>
        </div>

        <p id="infoStory" style="margin:12px 0 10px;font-weight:900;opacity:.9;">‚Äî</p>

        <div class="panel" style="padding:10px; border-radius:18px;">
          <b>3 Spr√ºche</b>
          <ul id="infoLines" style="margin:8px 0 0; padding-left:18px;"></ul>
        </div>

        <p class="tiny" style="margin:10px 0 0;">(Platzhalter) Sp√§ter: Plushie-Shop Link ‚ú®</p>
        <div class="foot">
          <button class="Btn ghost" id="infoClose">Schlie√üen</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="settingsBack">
      <div class="modal">
         <h2>Men√º</h2>

         <div class="panel" style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <b>FX Dimmer</b>
            <input type="range" id="fxSlider" min="0" max="100" value="0" style="flex:1">
         </div>

         <div class="cta" style="margin:16px 0; justify-content:center; gap:10px;">
            <button class="Btn secondary" id="menuNew">Neues Spiel</button>
            <button class="Btn ghost" id="menuIntro">Anleitung</button>
            <button class="Btn" id="menuFs">Vollbild</button>
            <button class="Btn" id="menuHint">Hint</button>
         </div>

         <div class="panel">
            <h3>Deine Luvvies</h3>
            <div class="luvGrid" id="menuLuvGrid"></div>
         </div>
         <div class="foot"><button class="Btn ghost" id="menuClose">Schlie√üen</button></div>
      </div>
    </div>

    <div class="modalBack" id="fsMenuBack" style="z-index:99999;">
      <div class="modal">
         <h2>Pause</h2>
         <div class="tiny" style="margin-bottom:12px;">Fullscreen Men√º</div>

         <div class="panel" style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <b>FX Dimmer</b>
            <input type="range" id="fsMenuFx" min="0" max="100" value="0" style="flex:1">
         </div>

         <div class="panel" style="margin-bottom:12px;">
            <h3>Quick-Tipps</h3>
            <div class="tiny" id="fsMenuTips"></div>
         </div>

         <div class="cta" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
            <button class="Btn secondary" id="fsMenuClose">Weiter</button>
            <button class="Btn ghost" id="fsMenuIntro">Anleitung</button>
            <button class="Btn" id="fsMenuLuv">Luvvies</button>
            <button class="Btn" id="fsMenuTheme">üåô</button>
         </div>
         <div style="margin-top:12px; text-align:center;">
            <button class="Btn ghost" onclick="document.exitFullscreen()">Exit Fullscreen</button>
         </div>
      </div>
    </div>

    <div id="app">
      <div class="topRow">
        <img id="mainLogo" alt="Luvvies Crush" style="height:46px;width:auto;margin-right:12px;filter:drop-shadow(0 4px 6px rgba(0,0,0,.1));display:block;" />

        <div class="diffWrap">
          <div class="diffPills" id="diffPills">
            <input type="radio" name="diff" id="d_easy" value="easy" checked><label for="d_easy">Easy</label>
            <input type="radio" name="diff" id="d_normal" value="normal"><label for="d_normal">Normal</label>
            <input type="radio" name="diff" id="d_hard" value="hard"><label for="d_hard">Hard</label>
            <input type="radio" name="diff" id="d_shock" value="shock"><label for="d_shock">Zuckerschock</label>
          </div>
        </div>

        <div style="flex:1; min-width:10px;"></div>

        <div style="display:flex; flex-direction:column; align-items:center; margin:0 10px;">
           <span class="tiny" style="line-height:1;">Zoom</span>
           <input type="range" id="zoomSlider" min="0.6" max="1.2" step="0.2" value="1.0" style="width:80px">
        </div>

        <div class="actions">
          <button class="Btn ghost" id="btnMax" title="Maximize Board">‚õ∂</button>
          <button class="Btn ghost" id="btnTheme" style="padding:0 12px;min-width:46px;">üåô</button>
          <button class="Btn" id="btnMenu">Men√º</button>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><div class="k">Level</div><div class="v" id="uiLevel">1</div></div>
        <div class="stat"><div class="k">Ziel</div><div class="v" id="uiGoal">4000</div></div>
        <div class="stat"><div class="k">Score</div><div class="v" id="uiScore">0</div></div>
        <div class="stat"><div class="k">Moves</div><div class="v" id="uiMoves">30</div></div>
        <div class="stat"><div class="k">Combo</div><div class="v" id="uiCombo">x1</div></div>
      </div>

      <div class="progressRow">
        <b>Fortschritt zum Ziel</b>
        <div class="bar"><i id="uiBar"></i></div>
        <div class="pct" id="uiPct">0%</div>
      </div>

      <div class="playArea" id="playArea">
        <div id="boardWrap">
          <div id="fsBg"></div>
          <div id="board"></div>
          <div id="fxLayer"></div>

          <div id="fsHud">
            <div class="hudLeft">
              <div class="hudChip color" id="hudLevel">Level 1</div>
              <div class="hudChip color" id="hudScore">Score 0</div>
              <div class="hudChip" id="hudMoves">Moves 0</div>
              <div class="hudChip" id="hudCombo">Combo x1</div>
            </div>

            <div class="hudCenter">
              <div class="hudProg">
                <div class="tiny" style="opacity:.85;">Ziel</div>
                <div class="pbar"><i id="hudBar"></i></div>
                <div class="tiny" id="hudPct" style="min-width:40px;text-align:right;">0%</div>
              </div>
            </div>

            <div class="hudRight">
              <button class="hudBtn hint" id="fsHint">Hint</button>
              <button class="hudBtn" id="fsMenuBtn">Men√º</button>
              <button class="hudBtn exit" id="fsExit">Exit</button>
            </div>
          </div>
        </div>
      </div>

      <div class="below">
        <div class="panel" id="luvPanel">
          <h3>Deine Luvvies <span class="tiny">(anklicken f√ºr Steckbrief)</span></h3>
          <div class="luvGrid" id="luvMenu"></div>
        </div>

        <div class="panel" id="rightPanel">
          <div>
            <h3>Quick-Tipps</h3>
            <div class="tiny" id="quickTips"></div>
          </div>
          <div style="height:1px;background:rgba(17,13,26,.08);"></div>
          <div style="display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
               <h3 style="margin:0;" id="lbTitle">Leaderboard</h3>
               <select id="lbDiffSelect" style="border-radius:8px;border:1px solid rgba(0,0,0,.1);padding:4px 8px;font-size:12px;font-weight:900;background:rgba(255,255,255,0.9);">
                 <option value="easy">Easy</option>
                 <option value="normal">Normal</option>
                 <option value="hard">Hard</option>
                 <option value="shock">Zuckerschock</option>
               </select>
            </div>
            <div class="lbRow">
              <input id="lbName" maxlength="24" placeholder="Dein Name (z.B. KOALAaufPILLEN)" />
              <label class="tiny" style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" id="lbAuto" checked>
                Auto-Post bei Game Over
              </label>
            </div>
            <div class="lbRow">
              <button class="Btn secondary" id="btnPost">Score posten</button>
              <button class="Btn ghost" id="btnRefresh">Refresh</button>
            </div>
            <div class="lbList" id="lbList"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     * Helpers
     **********************/
    function fmt(n){ return Number(n||0).toLocaleString("de-DE"); }
    function diffLabel(k){
      const key = (k||"").toLowerCase();
      if(key==="shock" || key==="schock" || key==="zuschock" || key==="zuckerschock") return "Zuckerschock";
      if(key==="easy") return "Easy";
      if(key==="normal") return "Normal";
      if(key==="hard") return "Hard";
      return k || "";
    }

    /**********************
     * Supabase (intern)
     **********************/
    const SUPABASE_URL = "https://qgeddoqvzajpeawlythi.supabase.co";
    const SUPABASE_KEY_PUBLISHABLE = "sb_publishable_EQUOdDGiCGgm8vA3YjN_jg_BwPnAiI_";
    const SCORE_TABLE = "luvvies_crush_scores";

    let sb = null;
    try{
      if(window.supabase?.createClient){
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY_PUBLISHABLE, {
          auth: { persistSession:false, autoRefreshToken:false }
        });
      }
    }catch(e){ sb = null; }

    /**********************
     * Cookies (1x/day greeting)
     **********************/
    function getCookie(name){
      const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([$?*|{}\(\)\[\]\\\/\+^])/g,'\\$1') + '=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : "";
    }
    function setCookie(name, value, days=7){
      const maxAge = days * 24 * 60 * 60;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
    }
    const todayKey = ()=>new Date().toISOString().slice(0,10);

    /**********************
     * Difficulty
     **********************/
    const DIFFS = {
      easy:   { key:"easy",   name:"Easy",        rows:10, cols:10, scoreMult:1.00, baseMoves:30, movesPerLevel:2, baseTarget:3500, targetGrow:0.18, lovelieChance:0.006, mystChance:0.010 },
      normal: { key:"normal", name:"Normal",      rows: 9, cols: 9, scoreMult:1.25, baseMoves:26, movesPerLevel:2, baseTarget:4200, targetGrow:0.20, lovelieChance:0.005, mystChance:0.009 },
      hard:   { key:"hard",   name:"Hard",        rows: 9, cols: 8, scoreMult:1.60, baseMoves:24, movesPerLevel:1, baseTarget:5000, targetGrow:0.22, lovelieChance:0.004, mystChance:0.008 },
      shock:  { key:"shock",  name:"Zuckerschock",rows: 8, cols: 8, scoreMult:2.00, baseMoves:22, movesPerLevel:1, baseTarget:6500, targetGrow:0.24, lovelieChance:0.003, mystChance:0.007 }
    };
    let diff = DIFFS.easy;

    /**********************
     * Images
     **********************/
    const IMG = {
      logo:     "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Luvvies-logo.png",
      sweety:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Sweety.png",
      sleepy:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Sleepy.png",
      normal:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/normal.png",
      cry:      "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Cry.png",
      koala:    "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/KOALA.png",
      citrussy: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Citrussie.png",
      worm:     "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/SourWurm.png",
      grumpy:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Grumpycookie.png",
      happy:    "https://static.wixstatic.com/media/d05122_cff843264bd8495aaa9ac0360d72e131~mv2.png",
      mond:     "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Mondly.png",
      donut:    "https://static.wixstatic.com/media/d05122_5041c19e720d4e7e9439e4acf793655c~mv2.png",
      joyce:    "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/joyce.png",
      smokey:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Smokey.png",
      mellow:   "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/mellow.png",
      lovelie:  "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Lovely.png",
      simba:    "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Simba.png",
      mellowlord: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/MellowLord.png",
      mellowzilla: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/MellowZilla.png",
            koalazilla:  "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/KoalaZilla.png",
fledernuss: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/FlederNuss.png",
      flederheld: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/FlederHeld.png",
      supernuss: "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/SuperNuss.png"
    };
    document.getElementById("greetLogo").src = IMG.logo;
    const ml = document.getElementById("mainLogo");
    if(ml) ml.src = IMG.logo;

    /**********************
     * Mystery reveal weights (Wurm > Cit > Mellow > Koala > Lovelie)
     **********************/
    const MYST_POOL = [
      { key:"worm",   w: 40 },
      { key:"cit",    w: 25 },
      { key:"mellow", w: 16 },  // goldene mitte (zwischen cit und koala)
      { key:"koala",  w: 12 },
      { key:"lovelie",w:  7 }   // rare
    ];

    /**********************
     * Bases
     **********************/
    const BASES = [
      { key:"fledernuss", name:"Fledernuss", img:IMG.fledernuss, tag:"normal", minLevel:10,
        palettes:{ A:["#8d6e63","#a1887f"], B:["#a1887f","#bcaaa4"] },
        ability:"Evolves to FlederHeld",
        story:"Kleine Nuss mit gro√üen Tr√§umen.",
        lines:{
          easy:["Fledernuss!","Evolution?","Flatter!"],
          normal:["Ich wachse!","Next stage!","Nuss-Power!"],
          hard:["Schnell entwickeln!","Evolution!","Go!"],
          shock:["SUPER NUSS?!","EVOLUTION!","FLATTER!"]
        }
      },
      { key:"flederheld", name:"FlederHeld", img:IMG.flederheld, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#3e2723","#5d4037"], B:["#5d4037","#795548"] },
        ability:"Evolves to SuperNuss",
        story:"Der Held der N√ºsse.",
        lines:{ easy:["Held!"], normal:["Hero!"], hard:["Super!"], shock:["HYPER!"] }
      },
      { key:"supernuss", name:"SuperNuss", img:IMG.supernuss, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#ffab00","#ffd740"], B:["#ff6f00","#ff8f00"] },
        ability:"Explodes!",
        story:"Die ultimative Nuss.",
        lines:{ easy:["BOOM!"], normal:["SUPER!"], hard:["MEGA!"], shock:["ULTRA!"] }
      },
      { key:"sweety", name:"Sweety", img:IMG.sweety, tag:"normal",
        palettes:{ A:["#f8bbd0","#f48fb1"], B:["#f48fb1","#ec407a"] },
        ability:"Glitzer-Queen: cleanes Match 3+.",
        story:"Sweety liebt Kettenreaktionen ‚Äì je mehr es bounct, desto besser.",
        lines:{
          easy:["Zucker-Boom! ‚ú®","Glitzer time!","Noch ein Match! üíñ"],
          normal:["Sauberer Swap üòå","Combo? Ich seh‚Äôs!","Keep the vibe ‚ú®"],
          hard:["No panic ‚Äî precision.","Du bist fast da.","Tight! üòà"],
          shock:["ZUCKERSCHOCK!","Mehr Chaos!","Ich will Ketten! üî•"]
        }
      },
      { key:"sleepy", name:"Sleepy", img:IMG.sleepy, tag:"normal",
        palettes:{ A:["#e3f2fd","#bbdefb"], B:["#bbdefb","#90caf9"] },
        ability:"2√ó Sleepy + 1√ó Mondlie ‚Üí Shuffle 4√ó4 ‚ú®",
        story:"Wirkt m√ºde‚Ä¶ aber sein Shuffle ist brutal effektiv.",
        lines:{
          easy:["Zzz‚Ä¶ aber ok üò¥","Sanfter Swap‚Ä¶","Wach f√ºr Combo!"],
          normal:["Nicht einschlafen.","Smooth & bouncy.","Weiter‚Ä¶ ‚ú®"],
          hard:["Timing ist alles.","Kein Tilt.","Mach‚Äôs clean."],
          shock:["ICH BIN WACH!","Shuffle oder RIP.","Mehr! üòà"]
        }
      },
      { key:"normal", name:"Normal", img:IMG.normal, tag:"normal",
        palettes:{ A:["#f3e5f5","#e1bee7"], B:["#ce93d8","#ba68c8"] },
        ability:"Klassiker: stabiler Tile f√ºr sichere Lines.",
        story:"Normal ist der Anker ‚Äì wenn‚Äôs brennt, rettet er dein Board.",
        lines:{
          easy:["Easy going.","Alles chill.","Noch eins!"],
          normal:["Stabil.","Rund.","Passt."],
          hard:["Disziplin.","Konsequent.","Kein Fehler."],
          shock:["Ich bleib ruhig.","Pr√§zise.","Durchziehen."]
        }
      },
      { key:"cry", name:"Cry", img:IMG.cry, tag:"normal",
        palettes:{ A:["#e0f2f1","#b2dfdb"], B:["#80cbc4","#4db6ac"] },
        ability:"Emo-Boost: f√ºhlt jede Chain-Reaction.",
        story:"Cry weint‚Ä¶ aber nur weil‚Äôs so sch√∂n glitzert.",
        lines:{
          easy:["üò≠‚ú® so sch√∂n","Bitte noch ein Match","Ich f√ºhl das!"],
          normal:["Combo macht happy.","Nicht aufgeben.","Weiter!"],
          hard:["Tough love.","Du packst das.","Sauber bleiben."],
          shock:["AAAA üò≠","Nur noch Kette!","Chaos is love."]
        }
      },
      { key:"happy", name:"Happy Cookie", img:IMG.happy, tag:"normal",
        palettes:{ A:["#fff3e0","#ffe0b2"], B:["#ffcc80","#ffb74d"] },
        ability:"Therapy Time (2√ó Grumpy + 1√ó Happy) ‚Üí +3 Moves, Grumpy‚ÜíHappy.",
        story:"Happy macht selbst Grumpy weich. üç™‚ú®",
        lines:{
          easy:["Smile! üç™","Alles wird gut!","S√º√ü & stark!"],
          normal:["Therapy incoming.","Du schaffst das.","Nice chain!"],
          hard:["Atmen. Fokus.","Guter Move.","Keep going."],
          shock:["HAPPY RAGE üòà","Wir gewinnen!","Mehr Moves!!"]
        }
      },
      { key:"grumpy", name:"Grumpy Cookie", img:IMG.grumpy, tag:"normal",
        palettes:{ A:["#ffebee","#ffcdd2"], B:["#ef9a9a","#e57373"] },
        ability:"Therapy Time (2√ó Grumpy + 1√ó Happy).",
        story:"Grumpy sagt 'nein'‚Ä¶ aber liebt +Moves heimlich.",
        lines:{
          easy:["Hmpf.","Mach schneller.","Ok‚Ä¶"],
          normal:["Weniger Fehler.","Konzentrier dich.","Weiter."],
          hard:["Sauber oder raus.","Nicht tilten.","Knapp!"],
          shock:["Zuckerschock?!","Du bist verr√ºckt.","‚Ä¶gef√§llt mir."]
        }
      },
      { key:"mond", name:"Mondlie", img:IMG.mond, tag:"normal",
        palettes:{ A:["#ede7f6","#d1c4e9"], B:["#b39ddb","#9575cd"] },
        ability:"2√ó Sleepy + 1√ó Mondlie ‚Üí Shuffle 4√ó4 ‚ú®",
        story:"Mondlie ist selten ruhig‚Ä¶ sein Shuffle ist Nachtmagie.",
        lines:{
          easy:["üåô leise‚Ä¶","Moon vibes.","Shuffle? üò¥"],
          normal:["Nacht-Combo.","Elegant.","Weiter."],
          hard:["Kein Risiko.","Nur Timing.","Mond-Plan."],
          shock:["NACHTCHAOS üòà","Alles mischen!","Mehr!"]
        }
      },
      { key:"donut", name:"Donutlie", img:IMG.donut, tag:"normal",
        palettes:{ A:["#fce4ec","#f8bbd0"], B:["#f48fb1","#f06292"] },
        ability:"2√ó Donut + Sweety ‚Üí Sprinkle Beam ‚Ä¢ 2√ó Donut + Happy ‚Üí Sugar Rush.",
        story:"Wenn Donut kommt, wird‚Äôs zuckrig gef√§hrlich. üç©",
        lines:{
          easy:["Sprinkles! ‚ú®","Mehr Donuts!","S√º√ües Chaos!"],
          normal:["Beam ready.","Zucker-Schub!","Let‚Äôs go!"],
          hard:["Timing!","Nicht verschwenden.","Power!"],
          shock:["OVERLOAD!","LASER üç©","MEHR!!!"]
        }
      },
      { key:"joyce", name:"Joyce Podenko", img:IMG.joyce, tag:"normal",
        palettes:{ A:["#efebe9","#d7ccc8"], B:["#bcaaa4","#a1887f"] },
        ability:"2√ó Joyce + 1√ó Smokey (oder umgekehrt) ‚Üí Buddy Burst.",
        story:"Joyce ist loyal ‚Äì wenn Smokey da ist, z√ºndet‚Äôs richtig.",
        lines:{
          easy:["Wuff! üêæ","Guter Swap!","Ich helf!"],
          normal:["Buddy time!","Ich bin dabei!","Nice!"],
          hard:["Wir schaffen‚Äôs.","Bleib dran.","Clean!"],
          shock:["WUFF ZUCKER!","Vollgas!","No fear!"]
        }
      },
      { key:"smokey", name:"Smokey", img:IMG.smokey, tag:"normal",
        palettes:{ A:["#f5f5f5","#e0e0e0"], B:["#bdbdbd","#9e9e9e"] },
        ability:"2√ó Smokey + 1√ó Joyce (oder umgekehrt) ‚Üí Buddy Burst.",
        story:"Smokey ist Boss-Katze ‚Äì und Boss-Katzen r√§umen auf.",
        lines:{
          easy:["Miau.","Ok.","Weiter."],
          normal:["Nicht schlecht.","Hmm.","Passt."],
          hard:["Ich bewerte dich.","Konsequent.","Sauber."],
          shock:["miau‚Ä¶ RESPEKT.","Heftig.","No mercy."]
        }
      },
      { key:"simba", name:"Simba", img:IMG.simba, tag:"normal", minLevel:4,
        palettes:{ A:["#fff8e1","#ffecb3"], B:["#ffe0b2","#ffcc80"] },
        ability:"Best Buddies: 2√ó Smokey + 1√ó Simba (oder umgekehrt) ‚Üí Buddy Wave ‚ú®",
        story:"Simba ist mutig und liebt Smokey ‚Äì zusammen sind sie unaufhaltbar.",
        lines:{
          easy:["Roar! ü¶Å","Best Buddies!","Wir schaffen‚Äôs!"],
          normal:["Starker Move!","Buddy Power!","Nice!"],
          hard:["Fokus.","Clean.","Weiter so."],
          shock:["ROAR SCHOCK!","Buddy Chaos!","No Mercy!"]
        }
      }
    ];

    const SPECIALS = {
      worm:   { key:"worm",   name:"Sourworm", img:IMG.worm, tag:"powerup" },
      cit:    { key:"cit",    name:"Citrussy", img:IMG.citrussy, tag:"powerup" },
      koala:  { key:"koala",  name:"Koala", img:IMG.koala, tag:"powerup" },
      mellow: { key:"mellow", name:"Mellow", img:IMG.mellow, tag:"obstacle" },
      lovelie:{ key:"lovelie",name:"Lovelie", img:IMG.lovelie, tag:"bonus" },
      myst:   { key:"myst",   name:"???", img:null, tag:"powerup" }
    };

    /**********************
     * Variant unlock
     **********************/
    let unlocked = {};
    function resetUnlocked(){
      unlocked = {};
      for(const b of BASES) unlocked[b.key] = new Set(["A"]);
    }
    function maybeUnlockVariant(){
      if(level < 5) return;
      if(level % 5 !== 0) return;
      const candidates = BASES.filter(b => !unlocked[b.key].has("B"));
      if(!candidates.length) return;
      const pick = candidates[Math.floor(Math.random()*candidates.length)];
      unlocked[pick.key].add("B");
      toast(`Neue Variante üé®`, `${pick.name} hat jetzt auch Farbe B ‚ú®`, 3200);
    }

    /**********************
     * State
     **********************/
    let rows=10, cols=10;
    let grid = [];
    let tileEls = new Map();
    let busy = false;
    // big mellow mapping
    const bigMellows = new Map();
    // id -> {id, r, c, hp, type}


    let lastZillaType = null; // used to alternate KoalaZilla/MellowZilla
    let pointer = {down:false, id:null, startX:0, startY:0};
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let target = 4000;
    let moves = 30;
    let combo = 1;

    let lastSwap = null;

    // cached sizing
    let CELL = 54;
    let GAP = 8;
    let PAD = 14;

    /**********************
     * UI refs
     **********************/
    const ui = {
      level: document.getElementById("uiLevel"),
      goal:  document.getElementById("uiGoal"),
      score: document.getElementById("uiScore"),
      moves: document.getElementById("uiMoves"),
      combo: document.getElementById("uiCombo"),
      bar:   document.getElementById("uiBar"),
      pct:   document.getElementById("uiPct"),
      board: document.getElementById("board"),
      fx:    document.getElementById("fxLayer"),
      menu:  document.getElementById("luvMenu"),
      tips:  document.getElementById("quickTips"),
      hudLevel: document.getElementById("hudLevel"),
      hudScore: document.getElementById("hudScore"),
      hudMoves: document.getElementById("hudMoves"),
      hudCombo: document.getElementById("hudCombo"),
      hudBar:   document.getElementById("hudBar"),
      hudPct:   document.getElementById("hudPct"),
    };

    /**********************
     * Helpers
     **********************/
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const posKey=(r,c)=>`${r},${c}`;
    function toast(title, subtitle="", ms=2600){
      document.documentElement.style.setProperty("--toastMs", ms+"ms");
      const wrap = document.getElementById("toast");
      const t = document.createElement("div");
      t.className="toast";
      t.innerHTML = `${title}${subtitle?`<small>${subtitle}</small>`:""}`;
      wrap.appendChild(t);
      setTimeout(()=>t.remove(), ms);
    }

    function typeId(baseKey, variant){ return `${baseKey}:${variant}`; }
    function parseTypeId(id){
      if(!id) return {baseKey:"", variant:"P"};
      if(!id.includes(":")) return {baseKey:id, variant:"P"};
      const [baseKey, variant] = id.split(":");
      return {baseKey, variant};
    }
    function getBase(baseKey){ return BASES.find(b=>b.key===baseKey) || null; }
    function getSpecial(baseKey){ return SPECIALS[baseKey] || null; }
    function inBounds(r,c){ return r>=0 && c>=0 && r<rows && c<cols; }

    function isPowerupKey(k){ return k==="worm" || k==="cit" || k==="koala"; }

    function isPlaceholder(t){ return t && t.type==="mellow_part"; }
    function isBlocker(t){
      if(!t) return false;
      const bk = parseTypeId(t.type).baseKey;
      // Small mellow is NO LONGER a blocker (so it falls/swaps)
      if(bk==="mellowlord" || bk==="mellowzilla" || bk==="koalazilla") return true;
      if(isPlaceholder(t)) return true;
      return false;
    }

    function isSwappable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(baseKey==="myst") return false; // ??? nur klicken
      return true;
    }
    function isMatchable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(getSpecial(baseKey)) return false;
      return true;
    }

    function calcTarget(lv){
      return Math.round(diff.baseTarget * (1 + (lv-1)*diff.targetGrow));
    }
    function calcMoves(lv){
      const m = diff.baseMoves + (lv-1)*diff.movesPerLevel;
      // Cap max moves to avoid accumulating too many (e.g. 70 moves at lvl 39 is too much)
      // Cap at 25 extra moves max (so base + 25)
      const cap = diff.baseMoves + 25;
      return Math.min(m, cap);
    }
    function scorePerTile(){ return Math.round(60 * diff.scoreMult); }

    function clearHints(){
      for(const el of tileEls.values()) el.classList.remove("hint");
    }

    /**********************
     * FX helpers
     **********************/
    function tileCenter(r,c){
      // Use getBoundingClientRect to map board cell to FX layer space
      // Find a tile at this pos, or calculate where it would be
      // If tile exists, use it. If not, use slot calc.
      // But calculating slot position relative to boardWrap is tricky if board is centered.
      // Best way: Use the 'board' element rect.
      const boardRect = ui.board.getBoundingClientRect();
      const fxRect = ui.fx.getBoundingClientRect();

      const localX = PAD + c*(CELL+GAP) + CELL/2;
      const localY = PAD + r*(CELL+GAP) + CELL/2;

      // Board Pos relative to FX layer
      const boardX = boardRect.left - fxRect.left;
      const boardY = boardRect.top - fxRect.top;

      return { x: boardX + localX, y: boardY + localY };
    }

    function makeStar(x,y, big=false){
      const s = document.createElement("div");
      s.className="star";
      s.style.left = x+"px";
      s.style.top  = y+"px";

      // Random size for "unique peng"
      const size = big ? (20 + Math.random()*12) : (10 + Math.random()*8);
      s.style.width = size+"px";
      s.style.height= size+"px";

      // Fully random pastel color
      const h = Math.floor(Math.random()*360);
      const sat = 70 + Math.random()*30;
      const light = 70 + Math.random()*20;

      s.style.background = `radial-gradient(circle at 30% 30%, hsl(${h}, ${sat}%, ${light+10}%), hsl(${h}, ${sat}%, ${light-10}%))`;
      // Random rotation
      s.style.transform = `translate(-50%, -50%) rotate(${Math.random()*360}deg)`;

      ui.fx.appendChild(s);
      setTimeout(()=>s.remove(), 900);
    }
    function ringFx(x,y){
      const r=document.createElement("div");
      r.className="ring";
      r.style.left=x+"px"; r.style.top=y+"px";
      ui.fx.appendChild(r);
      setTimeout(()=>r.remove(), 760);
    }
    function burstFx(x,y, count=12){
      ringFx(x,y);
      for(let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const dist = 10 + Math.random()*40;
        makeStar(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist, Math.random()<0.4);
      }
    }

    /**********************
     * Responsive sizing
     **********************/
    function computeCell(){
      const wrap = document.getElementById("boardWrap");
      // Use client dimensions directly to adapt to any container size
      const wrapW = wrap.clientWidth;
      const wrapH = wrap.clientHeight || window.innerHeight;

      const isFs = document.body.classList.contains("fs");
      const isMax = document.body.classList.contains("maximized");

      // Margins/Padding
      // In FS or Max, we want minimal side padding to fill the "red area"
      const padW = (isFs||isMax) ? 4 : 20;
      // Vertical padding: FS needs space for HUD (top ~100px) + bottom margin
      // Normal: Needs space for topRow + stats
      const padH = (isFs) ? 140 : (isMax ? 60 : 40);

      // If Maximized/FS, use Window Height as constraint to avoid scrolling
      const availH = (isFs || isMax) ? window.innerHeight : wrapH;

      const usableW = Math.max(260, wrapW - padW);
      const usableH = Math.max(260, availH - padH);

      const effectivePad = (isFs||isMax) ? 4 : PAD;

      const cellW = Math.floor((usableW - (cols-1)*GAP - effectivePad*2) / cols);
      const cellH = Math.floor((usableH - (rows-1)*GAP - effectivePad*2) / rows);

      const zoom = window.gameZoomFactor || 1.0;

      // No strict max cap, allow filling the screen
      const max = 400;
      return clamp(Math.min(cellW, cellH) * zoom, 20, max);
    }

    function setTileXY(el, r, c){
      const x = c*(CELL+GAP) + PAD;
      const y = r*(CELL+GAP) + PAD;
      el.style.setProperty("--x", x+"px");
      el.style.setProperty("--y", y+"px");
    }

    function layoutBoard(){
      CELL = computeCell();
      document.documentElement.style.setProperty("--cell", CELL+"px");
      document.documentElement.style.setProperty("--gap", GAP+"px");
      document.documentElement.style.setProperty("--cols", cols);
      document.documentElement.style.setProperty("--rows", rows);

      const w = PAD*2 + cols*CELL + (cols-1)*GAP;
      const h = PAD*2 + rows*CELL + (rows-1)*GAP;
      ui.board.style.width = w+"px";
      ui.board.style.height = h+"px";

      for(const [id, el] of tileEls){
        const tile = findTileById(id);
        if(!tile) continue;
        setTileXY(el, tile.r, tile.c);
      }

      syncLbHeight();
    }

    let ro=null;
    let resizeTimer;
    function attachResize(){
      const handler = () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{
           layoutBoard();
           syncBgHeight();
           buildGlobalBg();
           buildFsBg();
        }, 150);
      };

      try{
        ro = new ResizeObserver(handler);
        ro.observe(document.getElementById("boardWrap"));
      }catch(e){
        window.addEventListener("resize", handler);
      }
      window.addEventListener("resize", handler);
      document.getElementById("page").addEventListener("scroll", syncBgHeight, {passive:true});
    }

    function syncBgHeight(){
      const page = document.getElementById("page");
      const h = Math.max(page.scrollHeight, window.innerHeight);
      document.getElementById("scrollBg").style.height = h + "px";
      document.getElementById("globalBg").style.height = h + "px";
    }

    /**********************
     * Tile DOM
     **********************/
    function createTileEl(tile, spawnDrop=false){
      const el = document.createElement("div");
      el.className="tile";
      el.dataset.id = tile.id;

      const {baseKey, variant} = parseTypeId(tile.type);
      el.dataset.base = baseKey;
      el.dataset.variant = variant;
      const base = getBase(baseKey);
      const spec = getSpecial(baseKey);
      const meta = base || spec;

      // palettes
      let pal = ["#7ad8ff","#ff4fb9"];
      if(base){
        pal = (base.palettes?.[variant]) || (base.palettes?.A) || pal;
      }
      el.style.setProperty("--p1", pal[0]);
      el.style.setProperty("--p2", pal[1]);

      const plate = document.createElement("div");
      plate.className="plate";

      // Powerups + ??? + Lovelie: animated background
      if(isPowerupKey(baseKey) || baseKey==="lovelie" || baseKey==="myst" || baseKey==="cit" || baseKey==="worm" || baseKey==="koala"){
        el.classList.add("powerAnim");
      }

      // Big mellow size
      if(tile.big){
        el.classList.add("bigMellow");
      }

      if(baseKey === "myst"){
  const qm = document.createElement("div");
  qm.className="qmark";
  qm.textContent = "?";
  plate.appendChild(qm);
}else{
  const img = document.createElement("img");

  // Resolve image source (bases, specials, bosses)
  let src = meta?.img || "";
  if(baseKey==="mellowlord") src = IMG.mellowlord;
  if(baseKey==="mellowzilla") src = IMG.mellowzilla;
  if(baseKey==="koalazilla") src = IMG.koalazilla || IMG.koala;

  img.src = src;
  img.alt = meta?.name || baseKey;

  // Fallbacks (avoid broken icons)
  img.addEventListener("error", ()=>{
    if(baseKey==="koalazilla" && img.src !== IMG.koala) img.src = IMG.koala;
  }, {once:true});

  plate.appendChild(img);

  // Variant badge so A/B are clearly visible (prevents "combo feels broken")
  if(base && variant==="B"){
    const vb = document.createElement("div");
    vb.className = "variantBadge";
    vb.textContent = "B";
    plate.appendChild(vb);
  }
}

      el.appendChild(plate);
      if(tile.big || baseKey==="mellow"){
        const hp = document.createElement("div");
        hp.className="hp";
        hp.textContent = tile.hp;
        el.appendChild(hp);
      }

      setTileXY(el, tile.r, tile.c);

      if(spawnDrop){
        const fallDist = (tile.r + 3) * (CELL+GAP);
        plate.style.setProperty("--oy", `-${fallDist}px`);
        plate.style.setProperty("--op", "0");

        requestAnimationFrame(()=>{
          plate.style.setProperty("--oy", "0px");
          plate.style.setProperty("--op", "1");
        });

        // Use timeout instead of transitionend for reliability
        setTimeout(()=>{
          el.classList.add("land");
          const center = tileCenter(tile.r, tile.c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>el.classList.remove("land"), 560);
        }, 300);
      }

      el.addEventListener("pointerdown", onPointerDown);
        el.addEventListener("pointerup", onPointerUp);
  return el;
}

// Keep visuals in sync when a tile changes type without recreating the element
function refreshTileEl(tile){
  const el = tileEls.get(tile.id);
  if(!el) return;

  const {baseKey, variant} = parseTypeId(tile.type);
  el.dataset.base = baseKey;
  el.dataset.variant = variant;

  const base = getBase(baseKey);
  const spec = getSpecial(baseKey);
  const meta = base || spec;

  // palettes
  let pal = ["#7ad8ff","#ff4fb9"];
  if(base){
    pal = (base.palettes?.[variant]) || (base.palettes?.A) || pal;
  }
  el.style.setProperty("--p1", pal[0]);
  el.style.setProperty("--p2", pal[1]);

  // image
  const plate = el.querySelector(".plate");
  const img = el.querySelector("img");
  if(img){
    let src = meta?.img || "";
    if(baseKey==="mellowlord") src = IMG.mellowlord;
    if(baseKey==="mellowzilla") src = IMG.mellowzilla;
    if(baseKey==="koalazilla") src = IMG.koalazilla || IMG.koala;
    img.src = src;
    img.alt = meta?.name || baseKey;
  }

  // variant badge
  const oldBadge = el.querySelector(".variantBadge");
  if(oldBadge) oldBadge.remove();
  if(plate && base && variant==="B"){
    const vb = document.createElement("div");
    vb.className="variantBadge";
    vb.textContent="B";
    plate.appendChild(vb);
  }
}

function updateMellowHp(tile){
      const el = tileEls.get(tile.id);
      if(!el) return;
      const hp = el.querySelector(".hp");
      if(hp) hp.textContent = tile.hp;
    }

    function findTileById(id){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t && t.id===id) return t;
        }
      }
      return null;
    }

    /**********************
     * Random tile generation
     **********************/
    // Balancing: Limit active Luvvies on small boards
    function getActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);

      // Limit count based on Difficulty/Size to ensure matches are possible
      // Easy (10x10): Max 7-8 colors?
      // Shock (8x8): Max 5-6 colors.
      let maxColors = 6;
      if(diff.key === "easy") maxColors = 7;
      if(diff.key === "normal") maxColors = 6;
      if(diff.key === "hard") maxColors = 6;
      if(diff.key === "shock") maxColors = 5; // 8x8 with too many colors is impossible

      // If pool is larger, slice it?
      // But we want consistent characters.
      // We can consistently slice based on the current level/seed, or just take the first N.
      // BASES is sorted by appearance? Fledernuss is minLevel 10.
      // We should prioritize "basic" ones + 1-2 advanced.
      if(pool.length > maxColors){
         // Always keep basics (sweety, sleepy, normal, cry, joyce, smokey)
         // Rotate the others?
         // For stability, let's just pick the first 'maxColors' valid ones
         // but Fledernuss/Simba might be cut off.
         // Better: Pick random subset per Level? No, confusing.
         // Pick subset per Game? Yes.
         // We can store 'activeSet' in a variable when game starts.
      }
      return pool;
    }

    let gameActivePool = []; // Set on newGame

    function randNormalType(){
      // Use active subset
      const pool = gameActivePool.length ? gameActivePool : BASES;
      const weights = pool.map(b=>{
        const w = (b.key==="joyce"||b.key==="smokey") ? 9 : (b.key==="donut") ? 10 : 12;
        return {b, w};
      });
      const totalW = weights.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*totalW;
      let pick = weights[0].b;
      for(const x of weights){
        r -= x.w;
        if(r<=0){ pick = x.b; break; }
      }

      const variants = Array.from(unlocked[pick.key]);
      let v="A";
      if(variants.includes("B")){
        v = (Math.random() < 0.28) ? "B" : "A";
      }
      return typeId(pick.key, v);
    }

    function makeId(){
      return (crypto?.randomUUID?.() || (Math.random().toString(16).slice(2)+Date.now().toString(16)));
    }

    function makeTile(r,c,type){
      const id = makeId();
      return { id, r, c, type, hp:0, big:false };
    }

    function wouldCreateMatch(r,c,type){
      const k = parseTypeId(type).baseKey;
      if(c>=2){
        const a=grid[r][c-1], b=grid[r][c-2];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      if(r>=2){
        const a=grid[r-1][c], b=grid[r-2][c];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      return false;
    }

    /**********************
     * Background (no bubbles) + subtle twinkles
     **********************/
    function buildGlobalBg(){
      syncBgHeight();
      const cont = document.getElementById("globalBg");
      cont.innerHTML = "";

      const page = document.getElementById("page");
      const W = page.clientWidth;
      const H = Math.max(page.scrollHeight, window.innerHeight);
      const bgChars = [...BASES].sort(()=>Math.random()-0.5).slice(0,8);

      bgChars.forEach((b)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        const img = document.createElement("img");
        img.src=b.img; img.alt=b.name;

        const leftZone = Math.random() < 0.5;
        const x = leftZone
          ? Math.random()*(Math.max(240, W*0.26) - 120)
          : (W - 300) - Math.random()*(Math.max(240, W*0.26) - 120);

        const y = Math.random()*(Math.max(520,H)-280);

        wrap.style.left = Math.max(0, x)+"px";
        wrap.style.top  = y+"px";
        wrap.style.animationDuration = (16 + Math.random()*10)+"s";

        wrap.appendChild(img);
        cont.appendChild(wrap);

        // subtle twinkles around them (rare)
        const tick = ()=>{
          if(Math.random() < 0.28){
            const rect = wrap.getBoundingClientRect();
            const px = rect.left + rect.width * (0.2 + Math.random()*0.6);
            const py = rect.top  + rect.height* (0.2 + Math.random()*0.6);
            const t = document.createElement("div");
            t.className="twinkle";
            t.style.left = px + "px";
            t.style.top  = (py + window.scrollY) + "px";
            cont.appendChild(t);
            setTimeout(()=>t.remove(), 1300);
          }
        };
        setInterval(tick, 2200 + Math.random()*1400);
      });
    }

    function buildFsBg(){
      const fs = document.getElementById("fsBg");
      fs.innerHTML = "";
      if(!document.body.classList.contains("fs")) return;
      const W = fs.clientWidth || window.innerWidth;
      const H = fs.clientHeight || window.innerHeight;
      const pick = [...BASES].sort(()=>Math.random()-0.5).slice(0,7);
      pick.forEach((b)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        wrap.style.opacity = ".78";
        wrap.style.width = "min(260px, 42vw)";
        const img = document.createElement("img");
        img.src=b.img; img.alt=b.name;

        const leftZone = Math.random() < 0.5;
        const x = leftZone ? Math.random()*(W*0.28) : (W-280) - Math.random()*(W*0.28);
        const y = Math.random()*(H-240);
        wrap.style.left = Math.max(0,x)+"px";
        wrap.style.top  = Math.max(0,y)+"px";
        wrap.style.animationDuration = (16 + Math.random()*10)+"s";

        wrap.appendChild(img);
        fs.appendChild(wrap);
      });
    }

    /**********************
     * Board init
     **********************/
    function initBoard(){
      rows = diff.rows;
      cols = diff.cols;

      ui.tips.innerHTML = `
        ‚Ä¢ 4er-Match ‚áí <b>Sourworm</b> (Reihe/Spalte)<br>
        ‚Ä¢ 5er-Match ‚áí <b>Citrussy</b> (Stern Radius 3)<br>
        ‚Ä¢ T/L-Match ‚áí <b>Koala</b> (Magie)<br>
        ‚Ä¢ <b>2√ó Sleepy + 1√ó Mondlie</b> ‚áí Shuffle 4√ó4 ‚ú®<br>
        ‚Ä¢ <b>2√ó Joyce + 1√ó Smokey</b> ‚áí Buddy Burst<br>
        ‚Ä¢ <b>2√ó Smokey + 1√ó Simba</b> ‚áí Best Buddy Wave<br>
        ‚Ä¢ <b>Falscher Swap</b> ‚áí ‚àí3 Moves<br>
        ‚Ä¢ <b>Keine Z√ºge</b> ‚áí Auto-Shuffle, ‚àí1 Move
      `;

      grid = Array.from({length:rows}, (_,r)=>Array.from({length:cols}, (_,c)=>null));
      tileEls.clear();
      ui.board.innerHTML="";
      ui.fx.innerHTML="";
      bigMellows.clear();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let t;
          let tries=0;
          do{
            t = randNormalType();
            tries++;
          }while(wouldCreateMatch(r,c,t) && tries<40);

          const tile = makeTile(r,c,t);
          grid[r][c]=tile;
        }
      }

      spawnMellow();
      spawnMellowZilla();
      maybeSpawnLovelie();
      layoutBoard();

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const tile = grid[r][c];
          const el = createTileEl(tile, false);
          tileEls.set(tile.id, el);
          ui.board.appendChild(el);
        }
      }

      buildGlobalBg();
      buildFsBg();

      setTimeout(()=>resolveAll(true), 50);
    }

    /**********************
     * Mellow spawn: ab Level 3, dann alle 4 Level (3,7,11...) / immer 3 HP
     **********************/
    function shouldSpawnMellowThisLevel(){
      if(level < 3) return false;
      return level === 3 || ((level - 3) % 4 === 0);
    }

    function spawnMellow(){
      if(!shouldSpawnMellowThisLevel()) return;
      const count = clamp(1 + Math.floor(level/4), 1, Math.floor(rows*cols/10));
      for(let i=0;i<count;i++){
        for(let tries=0;tries<260;tries++){
          const r=Math.floor(Math.random()*rows);
          const c=Math.floor(Math.random()*cols);
          const cur=grid[r][c];
          if(!cur) continue;
          if(isBlocker(cur)) continue;

          const bk = parseTypeId(cur.type).baseKey;
          if(getSpecial(bk)) continue;

          const m = makeTile(r,c,typeId("mellow","P"));
          m.hp = 0; // Small mellow has no HP (invincible)
          const oldEl = tileEls.get(cur.id);
          if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }

          grid[r][c]=m;
          const el = createTileEl(m, false);
          el.classList.add("spawnGlow");
          tileEls.set(m.id, el);
          ui.board.appendChild(el);
          const center = tileCenter(r,c);
          burstFx(center.x, center.y, 10);
          break;
        }
      }
    }

    function maybeSpawnLovelie(){
      if(Math.random() > diff.lovelieChance) return;
      for(let tries=0;tries<220;tries++){
        const r=Math.floor(Math.random()*rows);
        const c=Math.floor(Math.random()*cols);
        const cur=grid[r][c];
        if(!cur) continue;
        if(isBlocker(cur)) continue;
        const bk = parseTypeId(cur.type).baseKey;
        if(getSpecial(bk)) continue;

        const lov = makeTile(r,c,typeId("lovelie","P"));
        const oldEl = tileEls.get(cur.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }
        grid[r][c]=lov;

        const el = createTileEl(lov, false);
        el.classList.add("spawnGlow");
        tileEls.set(lov.id, el);
        ui.board.appendChild(el);
        toast("Lovelie erscheint! üíñ","Ultra selten ‚ú®", 3200);
        break;
      }
    }

    /**********************
     * Mystery reveal (??? click -> random)
     **********************/
    function pickMyst(){
      const total = MYST_POOL.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*total;
      for(const x of MYST_POOL){
        r -= x.w;
        if(r<=0) return x.key;
      }
      return "worm";
    }

    function revealMyst(tile){
      if(busy) return;
      busy = true;
      const el = tileEls.get(tile.id);
      if(el) el.classList.add("puff");

      const {x,y} = tileCenter(tile.r, tile.c);
      burstFx(x,y, 14);

      setTimeout(()=>{
        const pick = pickMyst();

        // replace old tile
        const oldEl = tileEls.get(tile.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(tile.id); }

        let newType = typeId("worm","P");
        if(pick==="cit") newType = typeId("cit","P");
        if(pick==="koala") newType = typeId("koala","P");
        if(pick==="lovelie") newType = typeId("lovelie","P");
        if(pick==="mellow") newType = typeId("mellow","P");

        const t2 = makeTile(tile.r, tile.c, newType);
        if(pick==="mellow") t2.hp = 3;

        grid[tile.r][tile.c] = t2;

        const el2 = createTileEl(t2, false);
        el2.classList.add("spawnGlow");
        tileEls.set(t2.id, el2);
        ui.board.appendChild(el2);

        toast("??? Reveal ‚ú®", pick==="worm" ? "Sourworm!" :
                            pick==="cit" ? "Citrussy!" :
                            pick==="mellow" ? "Mellow Block!" :
                            pick==="koala" ? "Koala!" : "Lovelie üíñ", 2800);
        busy = false;
        updateUI();
      }, 360);
    }

    function collectBonus(tile){
       if(busy) return;
       busy=true;
       toast("Bonus! üíñ", "Lovelie collected!", 2000);
       clearCells([{r:tile.r, c:tile.c}]);
       totalScore += 5000;
       updateUI();
       setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 300);
    }

    /**********************
     * Pointer & Drag System (1:1 Drag Fix)
     **********************/
    let dragStart = {x:0, y:0};
    let currentDrag = null;
    let busyStart = 0; // Watchdog timestamp

    function onPointerDown(e){
      // Watchdog: If busy for too long (>2.5s) without active resolution, force unlock
      if(busy){
         if(!busyStart) busyStart = Date.now();
         if(Date.now() - busyStart > 2500){
             console.warn("Busy state stuck, auto-recovering...");
             busy = false;
             busyStart = 0;
             document.querySelectorAll('.tile.dragging').forEach(el=>el.classList.remove('dragging'));
             toast("Auto-Fix üõ†Ô∏è", "Input block gel√∂st.", 1500);
         } else {
             return;
         }
      }
      busyStart = Date.now();

      const tEl = e.currentTarget;
      const id = tEl.dataset.id;
      const tile = findTileById(id);
      if(!tile) return;

      if(currentDrag) return;

      clearHints();
      tEl.setPointerCapture(e.pointerId);

      const rect = tEl.getBoundingClientRect();
      const boardRect = ui.board.getBoundingClientRect();

      // We calculate current position based on grid logic to ensure we start from "true" position
      // Visual drag uses CSS translate.
      // 1:1 Dragging means: Mouse Delta = Tile Delta.

      // Store initial mouse pos
      dragStart = {
        startX: e.clientX,
        startY: e.clientY,
        // Store initial CSS transform values
        initialLeft: tile.c * (CELL+GAP) + PAD,
        initialTop:  tile.r * (CELL+GAP) + PAD,
      };

      currentDrag = {
        id: id,
        el: tEl,
        r: tile.r,
        c: tile.c,
        moved: false
      };

      tEl.classList.add("dragging");
    }

    function onPointerMove(e){
      if(!currentDrag) return;
      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      if(!currentDrag.moved && Math.hypot(dx,dy) > 6) currentDrag.moved = true;

      if(currentDrag.moved){
         // Apply exact delta to initial CSS position
         // This ensures 1:1 movement regardless of parent scaling/offsets
         const newX = dragStart.initialLeft + dx;
         const newY = dragStart.initialTop + dy;

         currentDrag.el.style.setProperty('--x', newX+"px");
         currentDrag.el.style.setProperty('--y', newY+"px");
      }
    }

    function onPointerUp(e){
      if(!currentDrag) return;
      const {id, el, r, c, moved} = currentDrag;
      const tile = findTileById(id);
      currentDrag = null;
      el.classList.remove("dragging");
      el.releasePointerCapture(e.pointerId);

      // Revert visual to grid slot immediately (animation happens if swap valid)
      setTileXY(el, r, c);

      if(!moved){
         if(tile && tile.type.startsWith("myst")) revealMyst(tile);
         if(tile && parseTypeId(tile.type).baseKey === "lovelie") collectBonus(tile);
         return;
      }

      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      // Determine drag direction based on movement
      // Use threshold relative to cell size for better feel?
      // User requested 1:1 follows.
      // Simple threshold 20px
      if(Math.hypot(dx,dy) < 15) return;

      // Direction
      let dirStr = "";
      if(Math.abs(dx) > Math.abs(dy)) dirStr = dx>0 ? "R" : "L";
      else dirStr = dy>0 ? "D" : "U";

      const dr = (dirStr==="D")?1:(dirStr==="U")?-1:0;
      const dc = (dirStr==="R")?1:(dirStr==="L")?-1:0;

      const r2 = r + dr;
      const c2 = c + dc;

      if(!inBounds(r2,c2)) return;

      // Determine Lock/Direction Logic
      const t1 = tile;
      const t2 = grid[r2][c2];

      if(!t1 || !t2) return;
      if(isBlocker(t1) || isBlocker(t2)) return;

      const k1 = parseTypeId(t1.type).baseKey;
      const k2 = parseTypeId(t2.type).baseKey;
      const p1 = isPowerupKey(k1);
      const p2 = isPowerupKey(k2);

      // Special: Lovelie + Lovelie -> Harmony
      if(k1==="lovelie" && k2==="lovelie"){
         trySwap(r, c, r2, c2);
         return;
      }

      // Special: Powerup + SuperNuss -> Super Combo
      const sn1 = k1==="supernuss";
      const sn2 = k2==="supernuss";
      if((p1 && sn2) || (p2 && sn1)){
         trySwap(r, c, r2, c2);
         return;
      }

      // Bonus: Lovelie interaction logic
      // Priority 1: If mixing with Powerup -> Swap/Combo
      if((k1==="lovelie" && p2) || (k2==="lovelie" && p1)){
         trySwap(r, c, r2, c2);
         return;
      }
      // Priority 2: Just clicking/swapping with normal -> Collect Bonus
      if(k1 === "lovelie"){ collectBonus(t1); return; }
      if(k2 === "lovelie"){ collectBonus(t2); return; }

      // Case 1: Powerup + Powerup -> FORCE SWAP (Combo)
      if(p1 && p2){
         trySwap(r, c, r2, c2);
         return;
      }

      // Case 2: Dragging FROM Powerup (Powerup + Normal) -> LOCK & ACTIVATE
      if(p1 && !p2){
       try{
         // Activate Powerup t1 in direction (dr,dc)
         toast("Powerup Activate! üí•", "Direction: "+dirStr, 1500);
         busy = true; // Lock input immediately

         if(k1 === "koala"){
            koalaMagicOn(k2);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "worm"){
            if(dr !== 0) clearCol(c);
            else clearRow(r);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "cit"){
             citBlast(r,c,3);
             clearCells([{r:t1.r,c:t1.c}]);
             spendMoves(1);
             setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
             return;
         }
         busy = false; // Reset if fallthrough
       }catch(e){
         console.error(e);
         busy=false; // Safety reset
       }
         return;
      }

      // Case 3: Dragging Normal -> Powerup
      if(!p1 && p2){
         // "Nie Powerups verschieben" -> Blocked.
         toast("Blockiert!", "Powerups sind fest verankert.", 1000);
         return;
      }

      // Case 4: Normal Swap
      trySwap(r, c, r2, c2);
    }

    ui.board.removeEventListener("pointermove", ()=>{});
    ui.board.addEventListener("pointermove", onPointerMove);
    ui.board.addEventListener("pointerup", onPointerUp);
    ui.board.addEventListener("pointercancel", onPointerUp);

    /**********************
     * Gameplay core (Swap/Resolve)
     **********************/

    function doSwap(r1,c1,r2,c2){
      const a = grid[r1][c1], b = grid[r2][c2];
      grid[r1][c1]=b; grid[r2][c2]=a;
      a.r=r2; a.c=c2;
      b.r=r1; b.c=c1;

      const elA = tileEls.get(a.id);
      const elB = tileEls.get(b.id);
      if(elA) setTileXY(elA,a.r,a.c);
      if(elB) setTileXY(elB,b.r,b.c);
    }

    function spendMoves(n){
      moves = Math.max(0, moves - n);
      if(moves===0){
        setTimeout(()=>gameOver(), 350);
      }
    }

    function quadMatchKind(t1,t2,t3,t4){
      if(!t1||!t2||!t3||!t4) return null;
      if(isBlocker(t1)||isBlocker(t2)||isBlocker(t3)||isBlocker(t4)) return null;

      const p1=parseTypeId(t1.type), p2=parseTypeId(t2.type), p3=parseTypeId(t3.type), p4=parseTypeId(t4.type);
      const keys=[p1.baseKey,p2.baseKey,p3.baseKey,p4.baseKey];
      const count=(k)=>keys.filter(x=>x===k).length;

      // 3+1 Logic (Ghost combo fix)
      if(count("sleepy")===3 && count("mond")===1) return "moonshuffle";
      if(count("grumpy")===3 && count("happy")===1) return "therapy";
      if(count("donut")===3 && count("sweety")===1) return "sprinkle";
      if(count("donut")===3 && count("happy")===1) return "sugar";

      // Buddies: 3 of either + 1 of other
      if(count("smokey")===3 && count("joyce")===1) return "buddies";
      if(count("joyce")===3 && count("smokey")===1) return "buddies";

      if(count("smokey")===3 && count("simba")===1) return "bestbuddies";
      if(count("simba")===3 && count("smokey")===1) return "bestbuddies";

      return null;
    }

    function findSpecialQuads(){
      const found=[];
      // Horizontal Quads
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols-3;c++){
          const t1=grid[r][c], t2=grid[r][c+1], t3=grid[r][c+2], t4=grid[r][c+3];
          const kind = quadMatchKind(t1,t2,t3,t4);
          if(kind) found.push({kind, cells:[{r,c},{r,c:c+1},{r,c:c+2},{r,c:c+3}]});
        }
      }
      // Vertical Quads
      for(let c=0;c<cols;c++){
        for(let r=0;r<rows-3;r++){
          const t1=grid[r][c], t2=grid[r+1][c], t3=grid[r+2][c], t4=grid[r+3][c];
          const kind = quadMatchKind(t1,t2,t3,t4);
          if(kind) found.push({kind, cells:[{r,c},{r:r+1,c},{r:r+2,c},{r:r+3,c}]});
        }
      }
      return found;
    }

    function findLineMatches(){
      const clear = new Set();
      const hRuns = [];
      const vRuns = [];

      for(let r=0;r<rows;r++){
        let c=0;
        while(c<cols){
          const t = grid[r][c];
          if(!isMatchable(t)){ c++; continue; }
          const k = parseTypeId(t.type).baseKey;
          let start=c;
          while(c<cols && grid[r][c] && isMatchable(grid[r][c]) && parseTypeId(grid[r][c].type).baseKey===k) c++;
          const len = c-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r,c:x});
              clear.add(posKey(r,x));
            }
            hRuns.push({len,cells});
          }
        }
      }

      for(let c=0;c<cols;c++){
        let r=0;
        while(r<rows){
          const t = grid[r][c];
          if(!isMatchable(t)){ r++; continue; }
          const k = parseTypeId(t.type).baseKey;
          let start=r;
          while(r<rows && grid[r][c] && isMatchable(grid[r][c]) && parseTypeId(grid[r][c].type).baseKey===k) r++;
          const len = r-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r:x,c});
              clear.add(posKey(x,c));
            }
            vRuns.push({len,cells});
          }
        }
      }

      const spawn = new Map();
      const inRunH = new Map();
      const inRunV = new Map();

      for(const run of hRuns) for(const p of run.cells) inRunH.set(posKey(p.r,p.c), 1);
      for(const run of vRuns) for(const p of run.cells) inRunV.set(posKey(p.r,p.c), 1);
      for(const key of clear){
        if(inRunH.has(key) && inRunV.has(key)){
          spawn.set(key, {type:typeId("koala","P"), prio:3});
        }
      }

      function pickSpawnCell(run){
        if(lastSwap){
          const pref = posKey(lastSwap.pref.r, lastSwap.pref.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===pref)) return pref;
          const alt = posKey(lastSwap.alt.r, lastSwap.alt.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===alt)) return alt;
        }
        const mid = run.cells[Math.floor(run.cells.length/2)];
        return posKey(mid.r, mid.c);
      }

      for(const run of [...hRuns, ...vRuns]){
        const k = pickSpawnCell(run);
        if(spawn.get(k)?.prio===3) continue;
        if(run.len>=5) spawn.set(k, {type:typeId("cit","P"), prio:2});
        else if(run.len===4) spawn.set(k, {type:typeId("worm","P"), prio:1});
      }

      for(const [k] of spawn) clear.delete(k);

      return {clear, spawn, hRuns, vRuns};
    }

    function hasAnyMatchOrSpecial(){
      const mm = findLineMatches();
      if(mm.clear.size>0) return true;
      const sp = findSpecialQuads();
      return sp.length>0;
    }

    function checkPowerSwap(t1, t2){
      if(!t1 || !t2) return false;
      const p1 = parseTypeId(t1.type).baseKey;
      const p2 = parseTypeId(t2.type).baseKey;

      const isP1 = isPowerupKey(p1);
      const isP2 = isPowerupKey(p2);
      const isS1 = p1 === "supernuss";
      const isS2 = p2 === "supernuss";
      const isL1 = p1 === "lovelie";
      const isL2 = p2 === "lovelie";

      // 1. Lovelie + Lovelie
      if(isL1 && isL2) return true;

      // 2. Powerup + SuperNuss
      if((isP1 && isS2) || (isP2 && isS1)) return true;

      // 3. Any Powerup involved (Combo or Single)
      // This covers Power+Power, Power+Normal, Lovelie+Power
      if(isP1 || isP2) return true;

      // 4. SuperNuss + SuperNuss? (If logic requires, though usually Powerup+SuperNuss is the key)

      return false;
    }

    function trySwap(r1,c1,r2,c2){
      if(busy) return;
      clearHints();
      const a = grid[r1][c1];
      const b = grid[r2][c2];
      if(!a || !b) return;
      if(isBlocker(a) || isBlocker(b)) return;
      if(!isSwappable(a) || !isSwappable(b)) return;
      busy = true;
      lastSwap = { pref:{r:r2,c:c2}, alt:{r:r1,c:c1} };

      doSwap(r1,c1,r2,c2);
      setTimeout(()=>{
       try{
        const A = grid[r1][c1];
        const B = grid[r2][c2];
        const aBk = parseTypeId(A.type).baseKey;
        const bBk = parseTypeId(B.type).baseKey;

        if( checkPowerSwap(A, B) ){
          spendMoves(1);
          resolvePowerSwap(A,B,{dr:r2-r1, dc:c2-c1});
          setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 220);
          return;
        }

        const ok = hasAnyMatchOrSpecial();

        // Free Swapping: No revert if no match.
        // Check if Mellow is involved (Free move)
        if(aBk === "mellow" || bBk === "mellow"){
           // 0 Cost
        } else {
           spendMoves(1);
        }

        // Even if no match immediately, we resolve (maybe gravity falls? no, just check matches)
        // If ok is false, resolveAll will basically find nothing and just unlock busy.
        resolveAll(false, true);
       }catch(e){
         console.error(e);
         busy=false;
         doSwap(r1,c1,r2,c2); // undo on error
       }
      }, 185);
    }

    function hitMellowAt(r,c, dmg=1){
      const t = grid[r][c];
      if(!t) return false;

      let bigId = null;
      if(isPlaceholder(t)) bigId = t.partOf;
      else if(t.big && bigMellows.has(t.id)) bigId = t.id;

      if(bigId){
        const big = bigMellows.get(bigId);
        if(!big) return false;
        big.hp = Math.max(0, big.hp - dmg);
        const anchorTile = grid[big.r][big.c];
        if(anchorTile){
          anchorTile.hp = big.hp;
          updateMellowHp(anchorTile);
        }
        if(big.hp<=0) removeBigMellow(bigId);
        return true;
      }

      const bk = parseTypeId(t.type).baseKey;
      if(bk==="mellow"){
        // Small Mellow is INVINCIBLE (absorbs hit but takes no damage)
        // It must be merged to form MellowLord to be destroyable (or cleared by special effects?)
        // User said: "mellow sollte unsterblich sein ... 2x2 zusammen packen damit er zu mellowlord wird"
        return true;
      }
      return false;
    }

    function damageMellowsAround(clearedCells){
      const dirs = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
      ];
      for(const p of clearedCells){
        for(const [dr,dc] of dirs){
          const rr=p.r+dr, cc=p.c+dc;
          if(!inBounds(rr,cc)) continue;
          hitMellowAt(rr,cc,1);
        }
      }
    }

    function clearCells(cells){
      const uniq = new Set(cells.map(p=>posKey(p.r,p.c)));
      const cleared = [];

      for(const key of uniq){
        const [r,c] = key.split(",").map(Number);
        const t = grid[r][c];
        if(!t) continue;

        if(hitMellowAt(r,c,1)){
          const center = tileCenter(r,c);
          makeStar(center.x, center.y, false);
          continue;
        }
        if(isPlaceholder(t)) continue;

        const el = tileEls.get(t.id);
        if(el){
          el.classList.add("pop");
          const center = tileCenter(r,c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
        }
        grid[r][c]=null;
        cleared.push({r,c});
      }

      damageMellowsAround(cleared);

      const add = Math.round(cleared.length * scorePerTile() * 1.10);
      totalScore += add;
      levelScore += add;
    }

    function clearRow(r){
      const cells=[];
      for(let c=0;c<cols;c++) cells.push({r,c});
      clearCells(cells);
      totalScore += 200; levelScore += 200;
    }
    function clearCol(c){
      const cells=[];
      for(let r=0;r<rows;r++) cells.push({r,c});
      clearCells(cells);
      totalScore += 200; levelScore += 200;
    }
    function citBlast(r,c, radius=3){
      const cells=[];
      // Diagonal band (3-wide) across the whole board
      // Main diagonals: (r-c) = const and (r+c) = const
      const diff = r - c;
      const sum = r + c;

      for(let rr=0; rr<rows; rr++){
        for(let cc=0; cc<cols; cc++){
           // Check bandwidth 3 (center + 1 each side)
           if(Math.abs((rr-cc) - diff) <= 1 || Math.abs((rr+cc) - sum) <= 1){
             cells.push({r:rr, c:cc});
           }
        }
      }
      clearCells(cells);
      totalScore += 260; levelScore += 260;
    }
    function clearWholeBoard(){
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk==="myst") continue;
        cells.push({r,c});
      }
      clearCells(cells);
      totalScore += 800; levelScore += 800;
    }
    function wormWave6(r1,c1,r2,c2){
      const mid = Math.round((c1+c2)/2);
      let start = mid-2;
      let end = mid+3;
      if(start<0){ end += -start; start=0; }
      if(end>cols){ start -= (end-cols); end=cols; start=Math.max(0,start); }

      const cells=[];
      for(let r=0;r<rows;r++){
        for(let c=start;c<end;c++) cells.push({r,c});
      }
      clearCells(cells);
      totalScore += 500; levelScore += 500;
    }
    function koalaMagicOn(targetBaseKey){
      const base = getBase(targetBaseKey);
      toast("üê® Koala-Magie!", "Alles von "+(base?.name||targetBaseKey)+" weg!", 3200);
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk===targetBaseKey) cells.push({r,c});
      }
      clearCells(cells);
    }

    function resolvePowerSwap(A,B,dir){
      const aBk = parseTypeId(A.type).baseKey;
      const bBk = parseTypeId(B.type).baseKey;

      // === 1. Lovelie + Lovelie ===
      if(aBk==="lovelie" && bBk==="lovelie"){
         lovelieHarmony(A,B);
         return;
      }

      // === 2. SuperNuss + Powerup ===
      // Check if one is Powerup and other is SuperNuss
      if(isPowerupKey(aBk) && bBk==="supernuss"){
         superNussCombo(A, B); return;
      }
      if(isPowerupKey(bBk) && aBk==="supernuss"){
         superNussCombo(B, A); return;
      }

      // === 3. Lovelie + Powerup ===
      if(aBk==="lovelie" && isPowerupKey(bBk)){
         activateLovelieCombo(B, A); return;
      }
      if(bBk==="lovelie" && isPowerupKey(aBk)){
         activateLovelieCombo(A, B); return;
      }

      // === 4. Powerup + Powerup ===

      // Koala + Worm
      if((aBk==="koala" && bBk==="worm") || (aBk==="worm" && bBk==="koala")){
        toast("üê®ü™± KOALA √ó WORM!", "MEGA CROSS BLAST! üí•", 3500);
        const rMid = Math.round((A.r + B.r)/2);
        const cMid = Math.round((A.c + B.c)/2);
        const cells = [];
        for(let r=rMid-1; r<=rMid+1; r++){
            if(r<0 || r>=rows) continue;
            for(let c=0; c<cols; c++) cells.push({r,c});
        }
        for(let c=cMid-1; c<=cMid+1; c++){
            if(c<0 || c>=cols) continue;
            for(let r=0; r<rows; r++) cells.push({r,c});
        }
        clearCells(cells);
        return;
      }

      // Koala + Citrussy
      if((aBk==="koala" && bBk==="cit") || (aBk==="cit" && bBk==="koala")){
        toast("üê®üçã KOALA √ó Citrussy!", "DOUBLE BOARD CLEAN √ó2 üí•üí•", 3800);
        clearWholeBoard();
        setTimeout(()=>{
         try{
          dropDown();
          mergeMellows();
          setTimeout(()=>{
           try{
            clearWholeBoard();
            const bonus = Math.round(2200 * diff.scoreMult);
            totalScore += bonus;
            levelScore += bonus;
            setTimeout(()=>{
              try{ dropDown(); mergeMellows(); resolveAll(false, true); }
              catch(e){ console.error(e); busy=false; }
            }, 240);
           }catch(e){ console.error(e); busy=false; }
          }, 260);
         }catch(e){ console.error(e); busy=false; }
        }, 260);
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}]);
        return;
      }

      // Worm + Worm
      if(aBk==="worm" && bBk==="worm"){
        toast("ü™±ü™± WEAVER WEB!", "Checkerboard Wipe! üèÅ", 3200);
        checkerboardWipe(A,B);
        return;
      }

      // Cit + Cit
      if(aBk==="cit" && bBk==="cit"){
        toast("üçãüçã DOUBLE CIT!", "Big Bang! üí•", 3200);
        citBlast(A.r,A.c,6); // Bigger radius
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}]);
        return;
      }

      // Koala + Koala
      if(aBk==="koala" && bBk==="koala"){
        toast("üê®üê® DOUBLE KOALA!", "Magic Wipe! ‚ú®", 3200);
        clearWholeBoard();
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}]);
        return;
      }

      // Worm + Cit
      if((aBk==="worm" && bBk==="cit") || (aBk==="cit" && bBk==="worm")){
         toast("ü™±üçã WORM √ó CIT!", "Star Rows! üí•", 3400);
         // Clear 3 Rows + 3 Cols
         const rMid = Math.round((A.r + B.r)/2);
         const cMid = Math.round((A.c + B.c)/2);
         // 3 Rows
         const cells = [];
         for(let r=rMid-1; r<=rMid+1; r++){
            if(r>=0 && r<rows) for(let c=0; c<cols; c++) cells.push({r,c});
         }
         // 3 Cols
         for(let c=cMid-1; c<=cMid+1; c++){
            if(c>=0 && c<cols) for(let r=0; r<rows; r++) cells.push({r,c});
         }
         clearCells(cells);
         return;
      }

      // === 5. Single Powerup Activation ===

      if(aBk==="koala" && !getSpecial(bBk)){
        koalaMagicOn(bBk);
        clearCells([{r:A.r,c:A.c}]);
        return;
      }
      if(bBk==="koala" && !getSpecial(aBk)){
        koalaMagicOn(aBk);
        clearCells([{r:B.r,c:B.c}]);
        return;
      }

      if(aBk==="worm"){
        if(dir.dr !== 0) clearCol(A.c);
        else clearRow(A.r);
        clearCells([{r:A.r,c:A.c}]);
      }
      if(bBk==="worm"){
        if(dir.dr !== 0) clearCol(B.c);
        else clearRow(B.r);
        clearCells([{r:B.r,c:B.c}]);
      }

      if(aBk==="cit"){
        citBlast(A.r,A.c,3);
        clearCells([{r:A.r,c:A.c}]);
      }
      if(bBk==="cit"){
        citBlast(B.r,B.c,3);
        clearCells([{r:B.r,c:B.c}]);
      }
    }

    function lovelieHarmony(A,B){
       toast("üíñüíñ PURE LOVE!", "Board Clean + Gifts! üéÅ", 4000);
       clearWholeBoard();
       // Spawn 3 Powerups randomly
       setTimeout(()=>{
          for(let i=0;i<3;i++){
             const r=Math.floor(Math.random()*rows);
             const c=Math.floor(Math.random()*cols);
             const types = ["worm:P", "cit:P", "koala:P"];
             const tType = types[Math.floor(Math.random()*types.length)];

             // Directly overwrite logic for spawn (simplified)
             // We can just rely on normal dropDown, but we want to Force spawns.
             // We can just set a flag or modify drop logic?
             // Simplest: Wait for dropDown then replace 3 random tiles?
             // Or just let normal drop happen and add points.
             // Let's add massive points.
             totalScore += 10000;
          }
          // Actually spawning specific powerups is hard because the board is empty and will be refilled by dropDown.
          // Let's just give +10 Moves.
          moves += 10;
          toast("Lovelie Bonus!", "+10 Moves! üéÅ", 3000);
          updateUI();
       }, 300);
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}]);
    }

    function checkerboardWipe(A, B){
       const cells = [];
       // Pattern: (r+c)%2 same as A? Or just a fixed checkerboard.
       // Fixed checkerboard is cooler. (r+c)%2 === 0
       for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
             if( (r+c)%2 === 0 ) cells.push({r,c});
          }
       }
       clearCells(cells);
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}]);
    }

    function superNussCombo(powerup, supernuss){
       const pk = parseTypeId(powerup.type).baseKey;

       if(pk==="worm"){
          toast("ü™±üå∞ GRAND CROSS!", "Rows+Cols+Diagonals! üí•", 3200);
          // Rows + Cols + Diagonals from center
          const r=supernuss.r, c=supernuss.c;
          clearRow(r); clearCol(c);
          const cells=[];
          // Diagonals
          for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
             if(inBounds(r+d, c+d)) cells.push({r:r+d,c:c+d});
             if(inBounds(r+d, c-d)) cells.push({r:r+d,c:c-d});
          }
          clearCells(cells);
       }
       else if(pk==="cit"){
          toast("üçãüå∞ GALAXY RING!", "Double Blast! ü™ê", 3200);
          // Radius 2 + Radius 4 rings
          citBlast(supernuss.r, supernuss.c, 3); // Center blast
          const cells=[];
          const r=supernuss.r, c=supernuss.c;
          // Radius 5 Ring
          for(let rr=0;rr<rows;rr++){
             for(let cc=0;cc<cols;cc++){
                const dist = Math.hypot(rr-r, cc-c);
                if(dist >= 4.5 && dist <= 5.5) cells.push({r:rr, c:cc});
             }
          }
          clearCells(cells);
       }
       else if(pk==="koala"){
           toast("üê®üå∞ GOLDEN ARMY!", "Evolution & Detonation! üí•", 4000);
           // Pick a random color present on board
           // Or neighbor color?
           // Random color.
           const target = BASES[Math.floor(Math.random()*BASES.length)];
           const tKey = target.key;

           // Visual transform + Clear
           const cells = [];
           for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
              const t=grid[r][c];
              if(t && parseTypeId(t.type).baseKey === tKey) cells.push({r,c});
           }

           // Clear them with delay to simulate explosion
           clearCells(cells);
       }

       clearCells([{r:powerup.r,c:powerup.c}, {r:supernuss.r,c:supernuss.c}]);
    }

    function activateLovelieCombo(powerupTile, lovelieTile){
       const pk = parseTypeId(powerupTile.type).baseKey;
       toast("LOVELIE POWER! üíñ", pk.toUpperCase()+" WAVE!", 3000);

       // Massive effect based on powerup
       if(pk === "worm"){
          // Turn 5 random tiles into worms and activate them?
          // Or just clear 5 random rows?
          // Let's clear 5 random rows.
          const rowsToClear = new Set();
          while(rowsToClear.size < 5) rowsToClear.add(Math.floor(Math.random()*rows));
          rowsToClear.forEach(r => clearRow(r));
       } else if(pk === "cit"){
          // 5 random Cit blasts
          for(let i=0;i<5;i++){
             citBlast(Math.floor(Math.random()*rows), Math.floor(Math.random()*cols), 3);
          }
       } else if(pk === "koala"){
          // Clear board + extra points
          clearWholeBoard();
          totalScore += 5000;
       }

       clearCells([{r:powerupTile.r, c:powerupTile.c}, {r:lovelieTile.r, c:lovelieTile.c}]);
    }

    function resolveAll(initial=false, isPlayerSwap=false){
      busy = true; // Safety lock

      // Safety: Auto-reset busy if something hangs deep in recursion
      setTimeout(()=>{
         if(busy && !document.querySelector(".tile.dragging")) busy = false;
      }, 5000);

      let isFirstStep = true;
      // Boss AI Step (only if isPlayerSwap to count turns properly?)
      // User says "Attacke 2 Z√ºge vorher rot an".
      // We can check it at the start of resolution chain.
      if(isPlayerSwap){
        const zilla = findMellowZilla();
        if(zilla){
          zilla.turn = (zilla.turn || 0) + 1;
          const phase = zilla.turn % 4;
          const zName = (zilla.type==="koalazilla") ? "KoalaZilla" : "MellowZilla";
          // Cycle 4:
          // 1: Idle
          // 2: Warn Red (1st turn)
          // 3: Warn Red (2nd turn)
          // 0: Attack

          if(phase === 2 || phase === 3){ // Warn (Red)
             const el = tileEls.get(zilla.id);
             if(el){
               el.style.border = "5px solid #ff0000";
               el.style.boxShadow = "0 0 20px red";
               toast(`${zName} w√ºtend!`, "Attacke in "+(phase===2?"2 Z√ºgen":"1 Zug")+"!", 2000);
             }
          } else if(phase === 0 && zilla.turn > 0){ // Attack
             toast(`${zName} Attacke!`, "3x3 Wipe! üí•", 2600);

             // Wipe random 3x3
             const rr = Math.floor(Math.random()*(rows-2));
             const cc = Math.floor(Math.random()*(cols-2));
             const cells = [];
             for(let r=rr; r<rr+3; r++){
               for(let c=cc; c<cc+3; c++) cells.push({r,c});
             }
             clearCells(cells);

             // Reset visual
             const el = tileEls.get(zilla.id);
             if(el){ el.style.border = "none"; el.style.boxShadow="none"; }
          } else {
             // Idle
             const el = tileEls.get(zilla.id);
             if(el){ el.style.border = "none"; el.style.boxShadow="none"; }
          }
        }
      }

      const step = ()=>{
       try {
        const specials = findSpecialQuads();
        const mm = findLineMatches();

        if(mm.clear.size===0 && specials.length===0){
          busy=false;
          layoutBoard(); // Force sync visual positions to fix drag bugs
          updateUI();
          ensureMovesOrShuffle();
          return;
        }

        combo = clamp(combo+1, 1, 99);

        // Failsafe: Stop infinite loops if combo gets too high
        if(combo > 25){
           busy = false;
           updateUI();
           ensureMovesOrShuffle();
           return;
        }

        let acceptedSpecials = specials;
        // User requested: Special combos only on player swap to prevent loops
        // Only accept specials on the VERY FIRST step of a player swap.
        // Cascades (isFirstStep=false) should not trigger specials.
        if(!isPlayerSwap || !isFirstStep) acceptedSpecials = [];

        // EXIT if acceptedSpecials is empty AND mm.clear is empty
        // This prevents infinite loop if 'specials' are found (so loop continues)
        // but 'acceptedSpecials' is empty (so nothing is cleared),
        // and 'mm.clear' is empty.
        if(acceptedSpecials.length === 0 && mm.clear.size === 0){
           busy=false;
           layoutBoard(); // Force sync
           updateUI();
           ensureMovesOrShuffle();
           return;
        }

        if(acceptedSpecials.length){
          for(const sp of acceptedSpecials){
            const center = sp.cells[Math.floor(sp.cells.length/2)];
            const ctr = tileCenter(center.r, center.c);
            burstFx(ctr.x, ctr.y, 14);

            if(sp.kind==="moonshuffle"){
              toast("üåôüò¥ Mond-Shuffle!", "4√ó4 Bereich ‚ú®", 3200);
              clearCells(sp.cells);
              shuffleArea4x4(center.r, center.c);
              continue;
            }

            if(sp.kind==="therapy"){
              toast("ü©π Therapy Time!", "+3 Moves ‚ú®", 3200);
              moves += 3;
              // Tripel entfernen, damit es NICHT erneut triggert
              clearCells(sp.cells);

              // Alle Grumpy -> Happy (Therapie Effekt)
              for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                  const t=grid[r][c];
                  if(!t) continue;
                  const p=parseTypeId(t.type);
                  if(p.baseKey==="grumpy"){
                    t.type = typeId("happy", p.variant);
                    refreshTileEl(t);
                  }
                }
              }
              continue;
            }

            if(sp.kind==="sprinkle"){
              toast("üç©‚ú® Sprinkle Beam!", "Beam Clear!", 3200);
              clearCells(sp.cells);
              const rr=center.r, cc=center.c;
              const beam = [];
              for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
                if(inBounds(rr, cc+d)) beam.push({r:rr,c:cc+d});
                if(inBounds(rr+d, cc)) beam.push({r:rr+d,c:cc});
                if(inBounds(rr+d, cc+d)) beam.push({r:rr+d,c:cc+d});
                if(inBounds(rr+d, cc-d)) beam.push({r:rr+d,c:cc-d});
              }
              clearCells(beam);
              continue;
            }

            if(sp.kind==="sugar"){
              toast("üç¨ Sugar Rush!", "+5 Moves & Clears!", 3400);
              moves += 5;
              clearCells(sp.cells);
              const picks = [];
              for(let i=0;i<14;i++){
                const r=Math.floor(Math.random()*rows);
                const c=Math.floor(Math.random()*cols);
                picks.push({r,c});
              }
              clearCells(picks);
              continue;
            }

            if(sp.kind==="buddies"){
              toast("üê±üê∂ Buddy Burst!", "Boom!", 3200);
              const area=[];
              for(const p of sp.cells){
                for(let dr=-1; dr<=1; dr++){
                  for(let dc=-1; dc<=1; dc++){
                    const rr=p.r+dr, cc=p.c+dc;
                    if(inBounds(rr,cc)) area.push({r:rr,c:cc});
                  }
                }
              }
              clearCells(sp.cells);
              clearCells(area);
              continue;
            }

            if(sp.kind==="bestbuddies"){
              toast("ü¶Åüê± BEST BUDDIES!", "Buddy Wave ‚ú®", 3400);
              clearCells(sp.cells);

              // Row+Col vom Center + extra Punkte
              clearRow(center.r);
              clearCol(center.c);
              totalScore += Math.round(1200*diff.scoreMult);
              levelScore += Math.round(1200*diff.scoreMult);
              continue;
            }
          }

          setTimeout(()=>{
            dropDown();
            mergeMellows();
            setTimeout(step, 450); // Increased delay to prevent ghost combos
          }, 240);
          checkLevelUp();
          updateUI();
          return;
        }

        // Check for Fledernuss runs in mm.hRuns/vRuns
        const allRuns = [...(mm.hRuns||[]), ...(mm.vRuns||[])];
        for(const run of allRuns){
          const first = run.cells[0];
          const t = grid[first.r][first.c];
          if(t){
            const bk = parseTypeId(t.type).baseKey;
            if(bk==="fledernuss"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"flederheld:A"});
               // prevent clearing the spawn spot? Logic below handles it:
               // "if(old) remove... grid[r][c]=t"
            } else if(bk==="flederheld"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"supernuss:A"});
            } else if(bk==="supernuss"){
               // Explosion
               const mid = run.cells[Math.floor(run.cells.length/2)];
               toast("SUPER NUSS!", "BOOM!", 2000);
               burstFx(tileCenter(mid.r, mid.c).x, tileCenter(mid.r, mid.c).y, 20);
               // Add extra clear radius 2
               const blast = [];
               for(let rr=mid.r-2; rr<=mid.r+2; rr++){
                 for(let cc=mid.c-2; cc<=mid.c+2; cc++){
                   if(inBounds(rr,cc)) blast.push({r:rr,c:cc});
                 }
               }
               clearCells(blast); // Immediate clear
            }
          }
        }

        const toClear = new Set(mm.clear);
        // Remove spawns from clear set
        for(const [k] of mm.spawn) toClear.delete(k);

        const scoreAdd = toClear.size * scorePerTile() * (1 + (combo-1)*0.12);
        totalScore += Math.round(scoreAdd);
        levelScore += Math.round(scoreAdd);

        const clearedCells = [];

        for(const key of toClear){
          const [r,c] = key.split(",").map(Number);
          const t = grid[r][c];
          if(!t) continue;

          if(hitMellowAt(r,c,1)) continue;

          const el = tileEls.get(t.id);
          if(el){
            el.classList.add("pop");
            const ctr = tileCenter(r,c);
            makeStar(ctr.x, ctr.y, true);
            burstFx(ctr.x, ctr.y, 8); // Extra glitter
            setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
          }
          grid[r][c]=null;
          clearedCells.push({r,c});
        }

        damageMellowsAround(clearedCells);

        // Fledernuss Evolution Logic
        // Check if any match was Fledernuss chain
        const alreadyEvolved = new Set();

        for(const [key, s] of mm.spawn){
           // Normal spawn logic (Cit, Worm, Koala)
           const [r,c]=key.split(",").map(Number);
           const old = grid[r][c];
           if(old){
             const oldEl = tileEls.get(old.id);
             if(oldEl) oldEl.remove();
             tileEls.delete(old.id);
           }
           const t = makeTile(r,c,s.type);
           grid[r][c]=t;
           const el = createTileEl(t, false);
           el.classList.add("spawnGlow");
           tileEls.set(t.id, el);
           ui.board.appendChild(el);
           const ctr = tileCenter(r,c);
           makeStar(ctr.x, ctr.y, true);
        }

        // Custom Evolution handling
        // For each cleared cell, check if it was part of a Fledernuss match
        // But mm.clear doesn't tell us the type.
        // We iterate matches in mm.
        // findLineMatches returned 'hRuns' and 'vRuns' internally but only returned clear/spawn sets.
        // We need to intercept the match types.

        // Let's re-scan the cleared cells to see what they were? No they are null now.
        // We should have intercepted before clearing.
        // Refactor resolveAll slightly? Or just look at the 'toClear' set before we nulled them.
        // 'clearedCells' contains the coords. But we need types.
        // 'grid' is already nulled.
        // Wait, the block above:
        // const t = grid[r][c]; ... grid[r][c]=null;
        // inside that loop we have access to 't'.

        // I will add the logic inside the clearing loop.
        /*
          const old = grid[r][c];
          if(old){
            const oldEl = tileEls.get(old.id);
            if(oldEl) oldEl.remove();
            tileEls.delete(old.id);
          }

          const t = makeTile(r,c,s.type);
          grid[r][c]=t;
          const el = createTileEl(t, false);
          el.classList.add("spawnGlow");
          tileEls.set(t.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          makeStar(ctr.x, ctr.y, true);
        */

        setTimeout(()=>{
          dropDown();
          mergeMellows();
          isFirstStep = false;
          // Add timeout limit for safety?
          setTimeout(step, 420); // Increased delay to prevent ghost combos
        }, 240);
        checkLevelUp();
        updateUI();
       } catch(e) {
         console.error("Game Logic Error:", e);
         busy = false;
       }
      };

      // Safety: If step crashes or hangs, reset busy after 5s?
      // But step() is recursive.
      // We can just rely on step() logic.
      try{
        step();
      }catch(e){
        console.error(e);
        busy=false;
      }
    }

    function shuffleArea4x4(centerR, centerC){
      const top = clamp(centerR-1, 0, rows-4);
      const left= clamp(centerC-1, 0, cols-4);

      const coords=[];
      const tiles=[];
      for(let r=top;r<top+4;r++){
        for(let c=left;c<left+4;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk=parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }

      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }

      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function dropDown(){
      for(let c=0;c<cols;c++){
        let r = rows-1;
        while(r>=0){
          while(r>=0 && isBlocker(grid[r][c])) r--;
          if(r<0) break;

          const segEnd = r;
          let segStart = segEnd;
          while(segStart>=0 && !isBlocker(grid[segStart][c])) segStart--;

          let write = segEnd;
          for(let rr=segEnd; rr>=segStart+1; rr--){
            const t = grid[rr][c];
            if(t){
              if(write !== rr){
                grid[write][c]=t;
                grid[rr][c]=null;
                t.r=write; t.c=c;
                const el = tileEls.get(t.id);
                if(el) setTileXY(el, t.r, t.c);
              }
              write--;
            }
          }

          for(let rr=write; rr>=segStart+1; rr--){
            let tType = randNormalType();
            if(level >= 2 && Math.random() < diff.mystChance){
              tType = "myst:P";
            }
            const t = makeTile(rr,c,tType);
            grid[rr][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }

          r = segStart;
        }
      }

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(grid[r][c]===null){
            const t = makeTile(r,c,randNormalType());
            grid[r][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }
        }
      }

      if(Math.random() < diff.lovelieChance*0.45){
        maybeSpawnLovelie();
      }
    }

    function mergeMellows(){
      for(let r=0;r<rows-1;r++){
        for(let c=0;c<cols-1;c++){
          const a = grid[r][c];
          const b = grid[r][c+1];
          const d = grid[r+1][c];
          const e = grid[r+1][c+1];
          if(!a||!b||!d||!e) continue;

          if(isPlaceholder(a)||isPlaceholder(b)||isPlaceholder(d)||isPlaceholder(e)) continue;

          const ak = parseTypeId(a.type).baseKey;
          const bk = parseTypeId(b.type).baseKey;
          const dk = parseTypeId(d.type).baseKey;
          const ek = parseTypeId(e.type).baseKey;

          if(ak!=="mellow" || bk!=="mellow" || dk!=="mellow" || ek!=="mellow") continue;
          if(a.big || b.big || d.big || e.big) continue;

          const hpSum = (a.hp||0) + (b.hp||0) + (d.hp||0) + (e.hp||0);
          const bigHp = 15; // Fixed HP for MellowLord

          [a,b,d,e].forEach(t=>{
            const el = tileEls.get(t.id);
            if(el){ el.remove(); tileEls.delete(t.id); }
          });
          const bigId = makeId();
          // MellowLord uses special type
          const bigTile = { id: bigId, r, c, type: "mellowlord:P", hp: bigHp, big:true };
          bigMellows.set(bigId, {id:bigId, r, c, hp:bigHp, type:"mellowlord"});

          grid[r][c] = bigTile;
          grid[r][c+1] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c+1] = { type:"mellow_part", partOf: bigId };

          const el = createTileEl(bigTile, false);
          el.classList.add("spawnGlow");
          tileEls.set(bigTile.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          burstFx(ctr.x + (CELL+GAP)/2, ctr.y + (CELL+GAP)/2, 25);
          // Peng Peng Glitter
          for(let i=0;i<5;i++){
             setTimeout(()=>makeStar(ctr.x + (Math.random()*60-30), ctr.y + (Math.random()*60-30), true), i*100);
          }
          toast("Mellowlord! üòà","4 Mellows verschmelzen!", 2800);
          setTileXY(el, r, c);
        }
      }
    }

    function findMellowZilla(){
      for(const [id, m] of bigMellows){
        if(m.type === "mellowzilla" || m.type === "koalazilla") return m;
      }
      return null;
    }

    function spawnMellowZilla(){
      if(level < 20) return;
      if(level % 20 !== 0) return;

      // Random alternate: KoalaZilla <-> MellowZilla (avoid same twice in a row)
      let zType = (Math.random() < 0.5) ? "mellowzilla" : "koalazilla";
      if(lastZillaType && zType === lastZillaType){
        zType = (zType === "mellowzilla") ? "koalazilla" : "mellowzilla";
      }
      lastZillaType = zType;

      // Clear 3x3 center
      const cr = Math.floor(rows/2)-1;
      const cc = Math.floor(cols/2)-1;

      const bigId = makeId();
      const zillaHp = 100;
      const zilla = { id: bigId, r: cr, c: cc, type: `${zType}:P`, hp: zillaHp, big:true, zilla:true };

      for(let r=cr; r<cr+3; r++){
        for(let c=cc; c<cc+3; c++){
           if(inBounds(r,c)){
             const t = grid[r][c];
             if(t){
               const el = tileEls.get(t.id);
               if(el) el.remove();
               tileEls.delete(t.id);
             }
             grid[r][c] = { type:"mellow_part", partOf: bigId };
           }
        }
      }

      // Anchor
      grid[cr][cc] = zilla;
      bigMellows.set(bigId, {id:bigId, r:cr, c:cc, hp:zillaHp, type:zType});

      const el = createTileEl(zilla, false);
      el.classList.add("spawnGlow");
      // Scale for 3x3
      el.style.width = `calc(var(--cell) * 3 + var(--gap) * 2)`;
      el.style.height = `calc(var(--cell) * 3 + var(--gap) * 2)`;

      tileEls.set(zilla.id, el);
      ui.board.appendChild(el);

      if(zType==="mellowzilla"){
        toast("MELLOW ZILLA!! ü¶ñ", "Boss Fight!", 4000);
      } else {
        toast("KOALA ZILLA!! üê®ü¶ñ", "Boss Fight!", 4000);
      }

      setTileXY(el, cr, cc);
    }

    function shiftMellowZilla(zilla){
      // Shift center by 2 blocks? Or move Zilla?
      // User: "Mitte verschieben um 2 Bl√∂cke"
      // Let's assume shuffling the center or moving Zilla.
      // Moving Zilla is hard if board is full.
      // Let's shuffle the board AROUND Zilla.
      shuffleAll();
      toast("Zilla Roar!", "Alles geshuffelt!", 2000);
    }

    function removeBigMellow(bigId){
      const big = bigMellows.get(bigId);
      if(!big) return;
      bigMellows.delete(bigId);

      const anchor = grid[big.r][big.c];
      if(anchor && anchor.id){
        const el = tileEls.get(anchor.id);
        if(el){
          el.classList.add("pop");
          setTimeout(()=>{ el.remove(); tileEls.delete(anchor.id); }, 420);
        }
      }

      // Boss Check for points
      if(big.type === "mellowzilla" || big.type === "koalazilla"){
        const bonus = 20000;
        totalScore += bonus;
        levelScore += bonus;
        if(big.type === "mellowzilla"){
          toast("MELLOW ZILLA BESIEGT! üèÜ", "+20.000 PUNKTE!", 4000);
        } else {
          toast("KOALA ZILLA BESIEGT! üèÜ", "+20.000 PUNKTE!", 4000);
        }
      } else {
        toast("Mellow gel√∂st! ‚ú®","Nice!", 2600);
      }

      const size = (big.type==="mellowzilla" || big.type==="koalazilla") ? 3 : 2;
      for(let rLoop=big.r; rLoop<big.r+size; rLoop++){
        for(let cLoop=big.c; cLoop<big.c+size; cLoop++){
          if(!inBounds(rLoop,cLoop)) continue;
          const t = grid[rLoop][cLoop];
          if(t && isPlaceholder(t) && t.partOf===bigId) grid[rLoop][cLoop]=null;
          if(t && t.id===bigId) grid[rLoop][cLoop]=null;
        }
      }
    }

    function hasMove(){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          // Free move logic: if t is mellow, it's always movable
          const isMellow = parseTypeId(t.type).baseKey === "mellow";

          const dirs=[[1,0],[0,1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            if(isMellow) return true;
            const uIsMellow = parseTypeId(u.type).baseKey === "mellow";
            if(uIsMellow) return true;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok) return true;
          }
        }
      }
      return false;
    }

    function shuffleAll(){
      const coords=[];
      const tiles=[];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk = parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }
      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }
      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function ensureMovesOrShuffle(){
      if(busy) return;
      if(hasMove()) return;
      if(moves <= 0) return; // Prevent infinite loop if game over

      busy = true; // STRICT BUSY LOCK during shuffle

      toast("Keine Z√ºge m√∂glich üòµ","Auto-Shuffle: ‚àí1 Move", 3600);
      spendMoves(1);
      combo = 1; // Reset combo

      // Shuffle until valid move exists (or max tries)
      let tries = 0;
      do {
        const zilla = findMellowZilla();
        if(zilla){
          shiftMellowZilla(zilla);
        } else {
          // Use full shuffle if center shuffle fails repeatedly?
          // Let's alternate or stick to requested logic.
          // User: "gemischt jedoch nur mittig"
          shuffleArea4x4(Math.floor(rows/2), Math.floor(cols/2));
        }
        tries++;
      } while(!hasMove() && tries < 20);

      setTimeout(()=>resolveAll(false, false), 180);
    }

    function hint(){
      clearHints();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok){
              const el1=tileEls.get(t.id);
              const el2=tileEls.get(u.id);
              if(el1) el1.classList.add("hint");
              if(el2) el2.classList.add("hint");
              toast("Hint ‚ú®","Probier die zwei!", 3000);
              return;
            }
          }
        }
      }
      toast("Keine direkten Moves üòµ","Shuffle kommt gleich‚Ä¶", 3000);
      ensureMovesOrShuffle();
    }

    async function toggleFullscreen(){
      const root = document.getElementById("playArea");
      try{
        if(document.fullscreenElement){
          await document.exitFullscreen();
        }else{
          await root.requestFullscreen();
        }
      }catch(e){}
    }
    document.addEventListener("fullscreenchange", ()=>{
      if(document.fullscreenElement){
        document.body.classList.add("fs");
        buildFsBg();
      }else{
        document.body.classList.remove("fs");
        document.getElementById("fsBg").innerHTML="";
      }
      layoutBoard();
    });

    function updateUI(){
      ui.level.textContent = level;
      ui.goal.textContent = fmt(target);
      ui.score.textContent = fmt(totalScore);
      ui.moves.textContent = moves;
      ui.combo.textContent = "x"+combo;

      const pct = clamp(Math.round((levelScore/target)*100), 0, 100);
      ui.bar.style.width = pct+"%";
      ui.pct.textContent = pct+"%";

      ui.hudLevel.textContent = "Level "+level;
      ui.hudScore.textContent = "Score "+fmt(totalScore);
      ui.hudMoves.textContent = "Moves "+moves;
      ui.hudCombo.textContent = "Combo x"+combo;
      ui.hudBar.style.width = pct+"%";
      ui.hudPct.textContent = pct+"%";
    }

    function checkLevelUp(){
      if(levelScore >= target){
        level++;
        levelScore = 0;
        maybeUnlockVariant();
        refreshActivePool(); // Recalculate allowed colors

        target = calcTarget(level);
        moves = calcMoves(level);

        toast("üéâ Ziel erreicht!","Next Level: "+level, 3200);
        spawnMellow();
        spawnMellowZilla(); // Check if Boss level
        maybeSpawnLovelie();
      }
    }

    function gameOver(){
      // Show dedicated Game Over Modal
      document.getElementById("goScore").textContent = fmt(totalScore);

      const saved = getCookie("luvvies_name");
      document.getElementById("goName").value = saved || document.getElementById("lbName").value || document.getElementById("greetName").value || "";

      document.getElementById("gameOverBack").style.display = "flex";

      // Auto-fill lbName if changed
      document.getElementById("lbName").value = document.getElementById("goName").value;
    }

    // Game Over Buttons
    document.getElementById("goNew").addEventListener("click", ()=>{
      document.getElementById("gameOverBack").style.display = "none";
      newGame(false);
    });
    document.getElementById("goPost").addEventListener("click", async ()=>{
       // Sync name
       const n = document.getElementById("goName").value;
       document.getElementById("lbName").value = n;
       await postScore();
       document.getElementById("gameOverBack").style.display = "none";
       newGame(false);
    });

    function newGame(fromDiffChange=false){
      busy=false;
      level=1;
      totalScore=0;
      levelScore=0;
      combo=1;
      resetUnlocked();
      target = calcTarget(level);
      moves = calcMoves(level);
      lastSwap=null;

      // Determine active pool for this game (based on difficulty)
      // Recalculate if level goes up?
      // If we limit colors, new characters won't appear.
      // Maybe we shouldn't limit statically.
      // But 8x8 with 10 colors is unplayable.
      // Strategy: On initBoard, we set the pool.
      // But BASES changes with Level (minLevel).
      // We will handle pool logic dynamically but cap the count.
      // Actually, simplest is: select Max N types from available.
      // Which ones?
      // Always basics + current "featured" ones?
      // Let's implement `refreshActivePool()` called on Level Up.
      refreshActivePool();

      initBoard();
      buildMenu();
      updateUI();
      refreshLeaderboard();
      if(!fromDiffChange){
        toast("Neues Spiel ‚ú®", diff.name+" ‚Ä¢ "+diff.rows+"√ó"+diff.cols, 2600);
      }
      syncLbHeight();
    }

    /**********************
     * Menu + Steckbrief
     **********************/
    function buildMenu(){
      ui.menu.innerHTML="";
      const menuGrid = document.getElementById("menuLuvGrid");
      if(menuGrid) menuGrid.innerHTML="";

      const all = [...BASES,
        {key:"myst",name:"???",img:null,tag:"powerup",ability:"Klicken ‚Üí random Reveal (Puff!)",story:"Mystery ist Gl√ºck + Rarity.",lines:{easy:["???","Puff ‚ú®","Gl√ºck!"],normal:["Reveal time.","Puff.","Random!"],hard:["Risk it.","Puff.","Roll!"],shock:["ALL IN üòà","Puff!","GAMBLE!"]}},
        {key:"worm",name:"Sourworm",img:IMG.worm,tag:"powerup",ability:"Reihe/Spalte (je nach Drag)",story:"Sauer, aber r√§umt sauber.",lines:{easy:["Chomp!","Weg damit!","Sauer!"],normal:["Line clear.","Crunch.","Nice."],hard:["Pr√§zise.","Perfekt.","Clean."],shock:["WELLE!","CRUNCH!","RIP Reihe!"]}},
        {key:"cit",name:"Citrussy",img:IMG.citrussy,tag:"powerup",ability:"Stern Radius 3 (8 Richtungen)",story:"Zitrus-Boom in alle Richtungen.",lines:{easy:["CIT!","Spritz!","Boom!"],normal:["Cross clear.","Zing!","Nice."],hard:["Setz‚Äôs gut.","Perfekt.","Value!"],shock:["ZITRUS-NUKE!","BOOM!","MEHR!"]}},
        {key:"koala",name:"Koala",img:IMG.koala,tag:"powerup",ability:"Koala+Sorte clear",story:"Boss-Magie: eine Sorte komplett weg.",lines:{easy:["Boss!","Magie!","Clean!"],normal:["Koala time.","Alles weg.","Nice."],hard:["Richtig w√§hlen.","Perfekt.","Carry."],shock:["BOSS MODE üòà","Wipe!","SWEET!"]}},
        {key:"mellow",name:"Mellow",img:IMG.mellow,tag:"obstacle",ability:"Block (3 HP) ‚Äì Clears daneben ziehen HP ab",story:"Klebt fest‚Ä¶ bis du ihn knackbar machst.",lines:{easy:["Kleb üòà","HP runter!","Block!"],normal:["Nicht ignorieren.","Knacken!","Weg!"],hard:["Gef√§hrlich.","Planen.","Ziel!"],shock:["BLOCK HELL üòà","RIP Moves","KNACKEN!"]}},
        {key:"lovelie",name:"Lovelie",img:IMG.lovelie,tag:"bonus",ability:"Ultra selten (Bonus)",story:"Wenn Lovelie kommt, lohnt‚Äôs sich.",lines:{easy:["OMG üíñ","So selten!","Bonus!"],normal:["Lovelie!","Lucky!","Nice."],hard:["Rare!","Take it.","Value!"],shock:["ULTRA RARE üíñ","LETS GO!","HYPE!"]}},
      ];

      const createCard = (b) => {
        const card=document.createElement("div");
        card.className="luvCard";
        const imgHtml = b.img ?
          `<img src="${b.img}" alt="${b.name}">` : `<div style="width:78px;height:78px;border-radius:18px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ff4fb9,#7ad8ff);color:#fff;font-weight:1000;font-size:32px;box-shadow:0 12px 20px rgba(0,0,0,.12);">?</div>`;
        card.innerHTML = `
          ${imgHtml}
          <div>
            <b>${b.name}</b>
            <small>${b.tag || "normal"}</small>
          </div>
        `;
        card.addEventListener("click", ()=>openInfo(b));
        return card;
      };

      for(const b of all){
        ui.menu.appendChild(createCard(b));
        if(menuGrid) menuGrid.appendChild(createCard(b));
      }
      syncLbHeight();
    }

    function openInfo(b){
      document.getElementById("infoImg").src = b.img || "";
      document.getElementById("infoImg").style.display = b.img ? "block" : "none";
      document.getElementById("infoName").textContent = b.name;
      document.getElementById("infoTag").textContent = (b.tag || "normal") + " ‚Ä¢ Varianten: A/B (ab Level 5)";
      document.getElementById("infoAbility").textContent = b.ability || "‚Äî";
      document.getElementById("infoStory").textContent = b.story || "‚Äî";

      const ul = document.getElementById("infoLines");
      ul.innerHTML="";
      const lines = (b.lines?.[diff.key] || b.lines?.easy || []).slice(0,3);
      for(const line of lines){
        const li=document.createElement("li");
        li.textContent=line;
        ul.appendChild(li);
      }
      document.getElementById("infoBack").style.display="flex";
    }

    /**********************
     * Leaderboard
     **********************/
    function cleanName(s){
      let out = s.replace(/[^a-zA-Z0-9\s√§√∂√º√Ñ√ñ√ú√ü!._-]/g, "");
      // Expanded Bad words filter
      const bad = [
        "hitler", "nazi", "arsch", "wichser", "hurensohn", "idiot", "dummbatz", "fuck", "bitch", "whore", "cunt", "nigger", "faggot", "fotze", "missgeburt", "bastard", "penis", "vagina", "sex", "anal"
      ];
      const lower = out.toLowerCase();
      // Whitelist
      if(lower.includes("koalaaufpillen")) return out;

      for(const b of bad){
        if(lower.includes(b)) return "***";
      }
      return out;
    }

    function getUuid(){
      let u = getCookie("luvvies_uuid");
      if(!u){
        u = crypto.randomUUID();
        setCookie("luvvies_uuid", u, 36500); // 100 years
      }
      return u;
    }

    async function postScore(){
      if(!sb){ toast("Leaderboard offline","(Supabase nicht erreichbar)", 3200); return; }
      let name = (document.getElementById("lbName").value || document.getElementById("greetName").value || "Anonymous").trim().slice(0,24);
      name = cleanName(name);

      // Save name to cookie
      setCookie("luvvies_name", name, 36500);

      // Check for name change -> New UUID
      let uuid = getUuid();
      const last = localStorage.getItem("luvvies_last_name");
      if(last && last !== name){
         uuid = crypto.randomUUID();
         setCookie("luvvies_uuid", uuid, 36500);
      }
      localStorage.setItem("luvvies_last_name", name);

      try{
        const payload = {
          player_name: name,
          score: totalScore,
          level: level,
          difficulty: diff.key,
          version:"luvvies-crush",
          user_id: uuid // Send UUID to backend
        };
        const { error } = await sb.from(SCORE_TABLE).insert(payload);
        if(error) throw error;
        toast("Score gepostet ‚úÖ", name+" ‚Ä¢ "+fmt(totalScore), 3200);
        await refreshLeaderboard();
      }catch(e){
        // Handle unique constraint error gracefully if setup
        if(String(e.message||e).includes("unique")){
           toast("Bereits gepostet!", "Du hast diesen Score schon gesendet.", 3000);
        } else {
           toast("Post fehlgeschlagen ‚ùå", String(e.message||e), 3400);
        }
      }
    }

    async function refreshLeaderboard(){
      const list = document.getElementById("lbList");
      const sel = document.getElementById("lbDiffSelect");
      // Use selected diff if available, else current game diff
      let dKey = sel ? sel.value : diff.key;

      const title = document.getElementById("lbTitle");
      // if(title) title.textContent = "Leaderboard"; // Static title now

      list.innerHTML = "";
      if(!sb){
        list.innerHTML = `<div class="tiny">Leaderboard aktuell nicht verf√ºgbar.</div>`;
        return;
      }
      try{
        // Filter by selected difficulty
        const { data, error } = await sb
          .from(SCORE_TABLE)
          .select("player_name,score,level,difficulty,created_at,user_id")
          .eq('difficulty', dKey)
          .order("score", { ascending:false })
          .limit(80);
        if(error) throw error;

        // Filter unique by UUID
        const unique = [];
        const seen = new Set();
        for(const row of (data||[])){
           const key = row.user_id || (row.player_name||"").toLowerCase();
           if(seen.has(key)) continue;
           seen.add(key);
           unique.push(row);
           if(unique.length >= 25) break;
        }

        unique.forEach((x, i)=>{
          const item = document.createElement("div");
          item.className="lbItem";
          item.style.animationDelay = (i * 0.05) + "s";
          if(i===0) item.classList.add("rank1");
          if(i===1) item.classList.add("rank2");
          if(i===2) item.classList.add("rank3");

          const d = new Date(x.created_at);
          const stamp = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.${d.getFullYear()} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
          // Use diffLabel to force correct name
          item.innerHTML = `
            <div class="left">
              <b>${i+1}. ${escapeHtml(x.player_name||"Anonymous")}</b>
              <small>Lvl ${x.level} ‚Ä¢ ${diffLabel(x.difficulty)} ‚Ä¢ ${stamp}</small>
            </div>
            <div class="score">${fmt(x.score)}</div>
          `;
          list.appendChild(item);
        });
        if(!data || data.length===0){
          list.innerHTML = `<div class="tiny">Noch keine Scores. Sei die/der Erste üòà‚ú®</div>`;
        }
      }catch(e){
        list.innerHTML = `<div class="tiny">Leaderboard Fehler.</div>`;
      }
      syncLbHeight();
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    /**********************
     * Make Leaderboard same height as luvvies panel
     **********************/
    function syncLbHeight(){
      // Disabled
    }

    /**********************
     * Intro/Greet events
     **********************/
    function showGreetingIfNeeded(){
      const k = "luvvies_greet_seen";
      const seen = getCookie(k);
      const today = todayKey();
      if(seen !== today){
        document.getElementById("greetBack").style.display="flex";
      }
    }
    function closeGreeting(setToday=true){
      if(setToday) setCookie("luvvies_greet_seen", todayKey(), 14);
      document.getElementById("greetBack").style.display="none";
    }

    document.getElementById("greetPlay").addEventListener("click", ()=>{
      closeGreeting(true);
      toast("Let‚Äôs go! ‚ú®","Viel Spa√ü!", 2600);
    });
    document.getElementById("greetGuide").addEventListener("click", ()=>{
      closeGreeting(true);
      document.getElementById("introBack").style.display="flex";
    });

    document.getElementById("introClose").addEventListener("click", ()=>document.getElementById("introBack").style.display="none");
    document.getElementById("infoClose").addEventListener("click", ()=>document.getElementById("infoBack").style.display="none");

    /**********************
     * Buttons & Menu
     **********************/
    // Old listeners removed (btnNew, btnHint etc replaced by menu versions)

    // Main Menu Trigger
    document.getElementById("btnMenu").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "flex";
    });
    document.getElementById("menuClose").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
    });

    // Menu Actions
    document.getElementById("menuNew").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       newGame(false);
    });
    document.getElementById("menuHint").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       hint();
    });
    document.getElementById("menuFs").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       toggleFullscreen();
    });
    document.getElementById("menuIntro").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       document.getElementById("introBack").style.display = "flex";
    });

    // Zoom Slider & Persistence
    const zoomSlider = document.getElementById("zoomSlider");
    if(zoomSlider){
      // Load saved zoom
      const savedZoom = getCookie("luvvies_zoom");
      if(savedZoom){
         const z = parseFloat(savedZoom);
         if(!isNaN(z) && z>=0.6 && z<=1.2){
           zoomSlider.value = z;
           window.gameZoomFactor = z;
           layoutBoard();
         }
      }

      zoomSlider.addEventListener("input", (e)=>{
         const z = parseFloat(e.target.value);
         window.gameZoomFactor = z;
         layoutBoard();
         setCookie("luvvies_zoom", z, 30); // 30 days
      });
    }

    document.getElementById("btnPost").addEventListener("click", postScore);
    document.getElementById("btnRefresh").addEventListener("click", refreshLeaderboard);

    const lbSel = document.getElementById("lbDiffSelect");
    if(lbSel) lbSel.addEventListener("change", refreshLeaderboard);

    // Dark Mode
    const btnTheme = document.getElementById("btnTheme");
    function syncTheme(){
      const isDark = document.body.classList.contains("dark");
      btnTheme.textContent = isDark ? "‚òÄÔ∏è" : "üåô";
      localStorage.setItem("luvvies_dark", isDark ? "1" : "0");
    }
    if(localStorage.getItem("luvvies_dark")==="1"){
      document.body.classList.add("dark");
      syncTheme();
    }
    btnTheme.addEventListener("click", ()=>{
      document.body.classList.toggle("dark");
      syncTheme();
    });

    // Maximize Button
    const btnMax = document.getElementById("btnMax");
    if(btnMax){
       btnMax.addEventListener("click", ()=>{
          document.body.classList.toggle("maximized");
          layoutBoard();
       });
    }

    // FX Slider (Dimmer Overlay)
    function updateFx(v){
      // v: 0-100. Opacity: 0 -> 0.7
      const op = (v / 100) * 0.7;
      const ov = document.getElementById("darkOverlay");
      if(ov) ov.style.opacity = op;

      // Reset filter on body if switching back from old method
      document.body.style.filter = "none";

      // Sync sliders
      if(document.getElementById("fxSlider")) document.getElementById("fxSlider").value = v;
      if(document.getElementById("fsMenuFx")) document.getElementById("fsMenuFx").value = v;
    }

    const fxSlider = document.getElementById("fxSlider");
    fxSlider.addEventListener("input", (e)=>updateFx(e.target.value));

    const fsMenuFx = document.getElementById("fsMenuFx");
    if(fsMenuFx) fsMenuFx.addEventListener("input", (e)=>updateFx(e.target.value));

    document.getElementById("diffPills").addEventListener("change", ()=>{
      const v = document.querySelector('input[name="diff"]:checked').value;
      diff = DIFFS[v];

      // Sync leaderboard filter
      const lbSel = document.getElementById("lbDiffSelect");
      if(lbSel) lbSel.value = v;

      newGame(true);
      buildGlobalBg();
      buildFsBg();
    });
    document.getElementById("fsHint").addEventListener("click", hint);
    // Menu Btn
    const btnMenu = document.getElementById("fsMenuBtn");
    if(btnMenu) btnMenu.addEventListener("click", ()=>{
       // Populate tips
       const t = document.getElementById("quickTips");
       if(t) document.getElementById("fsMenuTips").innerHTML = t.innerHTML;
       document.getElementById("fsMenuBack").style.display="flex";
    });

    const menuClose = document.getElementById("fsMenuClose");
    if(menuClose) menuClose.addEventListener("click", ()=>document.getElementById("fsMenuBack").style.display="none");

    const menuIntro = document.getElementById("fsMenuIntro");
    if(menuIntro) menuIntro.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    const menuLuv = document.getElementById("fsMenuLuv");
    if(menuLuv) menuLuv.addEventListener("click", ()=>{
       toast("Luvvies Men√º", "Bitte Spiel beenden f√ºr Details", 2000);
    });

    // Dark mode in FS Menu
    const fsTheme = document.getElementById("fsMenuTheme");
    if(fsTheme) fsTheme.addEventListener("click", ()=>{
      document.body.classList.toggle("dark");
      syncTheme();
      // Sync icon
      fsTheme.textContent = document.body.classList.contains("dark") ? "‚òÄÔ∏è" : "üåô";
    });

    // Old FS listeners (kept for safety if buttons exist)
    const fsIntroBtn = document.getElementById("fsIntro");
    if(fsIntroBtn) fsIntroBtn.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    document.getElementById("fsExit").addEventListener("click", async ()=>{
      if(document.fullscreenElement) await document.exitFullscreen();
    });

    /**********************
     * Boot
     **********************/
    attachResize();
    syncBgHeight();
    function refreshActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);

      const pairs = [
        ["sleepy", "mond"],
        ["joyce", "smokey"],
        ["simba", "smokey"],
        ["grumpy", "happy"],
        ["donut", "sweety"]
      ];

      let max = 6;
      if(diff.key === "easy") max = 7;
      if(diff.key === "normal") max = 6;
      if(diff.key === "hard") max = 6;
      if(diff.key === "shock") max = 5;

      const selected = new Set();
      const add = (k) => {
         if(selected.has(k)) return;
         if(selected.size >= max) return;
         selected.add(k);
      };

      // Shuffle pool
      const shuffled = [...pool].sort(()=>Math.random()-0.5);

      for(const b of shuffled){
         if(selected.size >= max) break;

         const myPairs = pairs.filter(p => p.includes(b.key));
         if(myPairs.length > 0){
            // Has partner
            const partnerKey = myPairs[0].find(k => k !== b.key);
            // Check if partner exists in pool (level req)
            if(!pool.find(x=>x.key===partnerKey)){
               add(b.key); // Partner not available (level too low), add alone
               continue;
            }

            // Check space
            if(!selected.has(partnerKey) && selected.size >= max - 1){
               // Not enough space for pair
               continue;
            }
            add(b.key);
            add(partnerKey);
         } else {
            add(b.key);
         }
      }

      // Fallback fill
      if(selected.size < 4){
         for(const b of pool){
            if(selected.size >= max) break;
            add(b.key);
         }
      }

      gameActivePool = BASES.filter(b => selected.has(b.key));
    }

    resetUnlocked();
    newGame(true);
    showGreetingIfNeeded();
  </script>
</body>
</html>
