<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sweet Swap ‚Äì KOALA Candy Match-3</title>

  <!-- Supabase (optional). Wenn du kein Leaderboard willst, kannst du diese Zeile entfernen. -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg1:#ffe6f1;
      --bg2:#e7f6ff;
      --panel:#ffffffcc;
      --text:#2b2b2b;
      --shadow: 0 12px 30px rgba(0,0,0,.12);
      --ring: 0 0 0 4px rgba(255, 105, 180, .35);

      /* Board sizing */
      --gap: clamp(7px, 1.05vw, 12px);
      --radius: 18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color:var(--text);
      min-height:100vh;
      background:
        radial-gradient(circle at 20% 20%, #fff 0 18%, transparent 19%),
        radial-gradient(circle at 70% 25%, #fff 0 14%, transparent 15%),
        radial-gradient(circle at 25% 75%, #fff 0 12%, transparent 13%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      display:flex;
      justify-content:center;
    }

    .wrap{
      width: min(1280px, 98vw);
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 16px;
      padding: 18px 0 22px;
      align-items:start;
    }
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

    .card{
      background:var(--panel);
      backdrop-filter: blur(10px);
      border: 1px solid #ffffffaa;
      border-radius: 26px;
      box-shadow: var(--shadow);
      padding: 16px;
      position:relative;
      overflow:hidden;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 6px 10px 14px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
    }
    .logo{
      width:46px;height:46px;border-radius:16px;
      background: conic-gradient(from 200deg, #ff4fb9, #ffd15a, #5ad1ff, #8b7bff, #ff4fb9);
      box-shadow: 0 10px 20px rgba(255,79,185,.25);
      position:relative;
      flex: 0 0 auto;
    }
    .logo:after{
      content:"";
      position:absolute; inset:8px;
      border-radius:12px;
      background: radial-gradient(circle at 30% 30%, #ffffffcc 0 35%, transparent 36%),
                  radial-gradient(circle at 70% 70%, #ffffff66 0 25%, transparent 26%);
      mix-blend-mode:soft-light;
    }
    h1{ font-size: 20px; margin:0; line-height:1.1; letter-spacing:.2px; }
    .sub{ font-size:12px; opacity:.8; margin-top:2px; }

    .btns{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
    button{
      appearance:none; border:0; cursor:pointer;
      padding:10px 12px; border-radius: 14px;
      background: linear-gradient(135deg, #ff4fb9, #ff8ad8);
      color:white; font-weight:900;
      box-shadow: 0 12px 22px rgba(255,79,185,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    button.secondary{
      background: linear-gradient(135deg, #7ad8ff, #7b7bff);
      box-shadow: 0 12px 22px rgba(123,123,255,.2);
    }
    button.ghost{
      background: #ffffffb3;
      color: #3b3b3b;
      border: 1px solid #ffffffd9;
      box-shadow: 0 12px 22px rgba(0,0,0,.08);
    }
    button:active{transform: translateY(1px) scale(.99)}
    button:hover{filter:saturate(1.05) brightness(1.02)}

    .hud{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      padding: 0 10px 12px;
    }
    @media (max-width: 520px){ .hud{grid-template-columns: repeat(2,1fr);} }
    .stat{
      background:#ffffffb3;
      border: 1px solid #ffffffd9;
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
    }
    .stat .k{font-size:12px; opacity:.75}
    .stat .v{font-size:18px; font-weight:900; margin-top:2px}

    /* Board fills available space */
    .boardWrap{
      padding: 6px 10px 10px;
      height: clamp(520px, 68vh, 820px); /* <-- f√ºllt mehr ‚ÄûFeld‚Äú */
      display:flex;
    }
    .board{
      width: 100%;
      height: 100%;
      border-radius: 26px;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.8) 0 18%, transparent 19%),
        radial-gradient(circle at 75% 30%, rgba(255,255,255,.55) 0 12%, transparent 13%),
        linear-gradient(135deg, #fff, #ffffff80);
      border: 1px solid #ffffffcc;
      box-shadow: 0 18px 34px rgba(0,0,0,.10);
      position:relative;
      touch-action:none;
      padding: 10px;
      overflow: visible;
    }
    .grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: var(--gap);
      padding: 10px;
      border-radius: 20px;
      background: linear-gradient(135deg, #ffd7ec, #dff4ff);
      border: 1px solid rgba(255,255,255,.85);
      position:relative;
    }
    .cell{
      position:relative;
      border-radius: var(--radius);
      background: rgba(255,255,255,.35);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.7);
      overflow: visible;
      aspect-ratio: 1 / 1;
    }

    .candy{
      position:absolute; inset:0;
      border-radius: var(--radius);
      display:grid;
      place-items:center;
      user-select:none;
      transform: translateZ(0);
      transition: transform 280ms ease; /* <-- langsamer */
      box-shadow: inset 0 -10px 16px rgba(0,0,0,.08), 0 14px 18px rgba(0,0,0,.10);
      overflow:hidden;
      will-change: transform;
    }
    .candy::before{
      content:"";
      position:absolute;
      inset: 10px 12px auto 12px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,.55);
      transform: rotate(-10deg);
      pointer-events:none;
    }
    .candy img{
      width: 82%;
      height: 82%;
      object-fit: contain;
      filter: drop-shadow(0 8px 10px rgba(0,0,0,.15));
      pointer-events:none;
      transform: translateZ(0);
    }

    .selected{
      box-shadow: var(--ring), inset 0 -10px 16px rgba(0,0,0,.08), 0 14px 18px rgba(0,0,0,.12);
      transform: scale(1.06);
    }
    .blocked{ pointer-events:none; opacity:.98; }

    /* backplates */
    .t-sweety  { background: linear-gradient(135deg, #ff4fb9, #ff9adf); }
    .t-sleepy  { background: linear-gradient(135deg, #7ad8ff, #b7f0ff); }
    .t-normal  { background: linear-gradient(135deg, #ffd15a, #ffe7a0); }
    .t-cry     { background: linear-gradient(135deg, #7b7bff, #b8b1ff); }
    .t-sourworm{ background: linear-gradient(135deg, #5ef2b5, #b6ffd6); }
    .t-citrussy{ background: linear-gradient(135deg, #ff9f43, #ffd1a6); }
    .t-koala   { background: linear-gradient(135deg, #ff6b6b, #ffb3b3); }

    /* Pop + Bling */
    @keyframes pop{
      0%{transform:scale(1)}
      35%{transform:scale(1.18)}
      100%{transform:scale(0)}
    }
    .pop{ animation: pop 280ms ease forwards; } /* <-- langsamer */

    @keyframes wobble{
      0%{transform:scale(1) rotate(0deg)}
      25%{transform:scale(1.03) rotate(-4deg)}
      50%{transform:scale(1.06) rotate(4deg)}
      100%{transform:scale(1) rotate(0deg)}
    }
    .wobble{ animation: wobble 320ms ease; } /* <-- langsamer */

    @keyframes sparkle{
      0%{transform: translate(-50%,-50%) scale(.2); opacity:0}
      20%{opacity:1}
      100%{transform: translate(-50%,-95%) scale(1.35); opacity:0}
    }
    .sparkle{
      position:absolute; left:50%; top:55%;
      width: 12px; height:12px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.2));
      box-shadow: 0 0 18px rgba(255,255,255,.9), 0 0 28px rgba(255,79,185,.45);
      animation: sparkle 620ms ease forwards;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    @keyframes boom{
      0%{transform: translate(-50%,-50%) scale(.2); opacity:.9}
      100%{transform: translate(-50%,-50%) scale(2.9); opacity:0}
    }
    .boomRing{
      position:absolute; left:50%; top:50%;
      width: 40px; height:40px;
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.9);
      box-shadow: 0 0 20px rgba(255,79,185,.35), 0 0 30px rgba(122,216,255,.25);
      animation: boom 720ms ease forwards; /* <-- langsamer */
      pointer-events:none;
      mix-blend-mode: screen;
    }

    @keyframes floatUp{
      from{transform: translate(-50%, 0); opacity:1}
      to{transform: translate(-50%, -18px); opacity:0}
    }
    .toast{
      position:absolute; left:50%; top:10px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      background: #ffffffd9;
      border: 1px solid #ffffff;
      box-shadow: 0 12px 22px rgba(0,0,0,.10);
      font-weight:900;
      pointer-events:none;
      animation: floatUp 1000ms ease forwards;
      white-space:nowrap;
      z-index: 20;
    }

    .dragging{
      transition: transform 0ms !important;
      z-index: 5;
      filter: drop-shadow(0 18px 16px rgba(0,0,0,.18));
    }

    /* Side */
    .side h2{ margin: 8px 0 6px; font-size: 16px; }
    .help{
      font-size: 13px;
      line-height:1.35;
      opacity:.95;
      background:#ffffffb3;
      border:1px solid #ffffffd9;
      border-radius: 18px;
      padding: 12px 12px;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
    }
    .help kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      background:#fff;
      border:1px solid #eee;
      border-bottom-width:2px;
      padding: 2px 6px;
      border-radius: 8px;
    }
    .progress, .leader{
      margin-top: 10px;
      background:#ffffffb3;
      border:1px solid #ffffffd9;
      border-radius: 18px;
      padding: 12px 12px;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
    }
    .bar{
      height: 14px;
      border-radius: 999px;
      background: #ffffff;
      border: 1px solid #eee;
      overflow:hidden;
      margin-top: 8px;
    }
    .bar > div{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff4fb9, #ffd15a, #7ad8ff);
      transition: width .25s ease;
    }

    .row{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin-top:10px;
    }
    input{
      width: 100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid #eee;
      background:#fff;
      outline:none;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
      font-weight:700;
    }
    .tiny{
      font-size:12px; opacity:.75;
    }
    .lb{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .lbItem{
      display:flex; justify-content:space-between; gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      background:#fff;
      border:1px solid #eee;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
      font-size:13px;
      align-items:center;
    }
    .lbLeft{display:flex; gap:10px; align-items:center}
    .rank{
      width:26px; height:26px; border-radius: 10px;
      display:grid; place-items:center;
      background: linear-gradient(135deg, #ffd15a, #ff8ad8);
      color:#fff; font-weight:900;
      flex:0 0 auto;
    }
    .footerNote{ margin-top:12px; font-size:12px; opacity:.75; text-align:center; }

    /* Intro */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(20,10,30,.40);
      backdrop-filter: blur(10px);
      display:grid;
      place-items:center;
      z-index: 50;
      padding: 16px;
    }
    .modal{
      width: min(760px, 96vw);
      border-radius: 26px;
      background: linear-gradient(135deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
      border:1px solid rgba(255,255,255,.85);
      box-shadow: 0 30px 80px rgba(0,0,0,.25);
      overflow:hidden;
      position:relative;
    }
    .modalHead{
      padding: 16px 18px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .modalTitle{
      display:flex; align-items:center; gap:10px;
    }
    .modalTitle h3{ margin:0; font-size:18px; letter-spacing:.2px; }
    .modalBody{
      padding: 0 18px 16px;
      font-size: 13.5px;
      line-height: 1.35;
      color:#2b2b2b;
    }
    .modalGrid{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 640px){ .modalGrid{grid-template-columns:1fr} }
    .modalCard{
      background:#ffffffd0;
      border:1px solid #ffffff;
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 12px 22px rgba(0,0,0,.10);
    }
    .modalFoot{
      padding: 12px 18px 18px;
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      border-top:1px solid rgba(255,255,255,.7);
      background: rgba(255,255,255,.55);
    }

    /* Win/Gameover overlay */
    .overlayBack{
      position:fixed; inset:0;
      background: rgba(10,8,18,.45);
      backdrop-filter: blur(10px);
      display:none;
      place-items:center;
      z-index: 60;
      padding: 16px;
    }
    .overlay{
      width:min(560px, 96vw);
      border-radius: 26px;
      background: linear-gradient(135deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
      border:1px solid rgba(255,255,255,.85);
      box-shadow: 0 30px 80px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .overlay .body{ padding: 16px 18px 6px; }
    .overlay h3{ margin:0 0 6px; }
    .overlay p{ margin: 6px 0; opacity:.9; }
    .overlay .foot{
      padding: 12px 18px 18px;
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      border-top:1px solid rgba(255,255,255,.7);
      background: rgba(255,255,255,.55);
    }
  </style>
</head>

<body>

  <!-- Anleitung -->
  <div class="modalBack" id="intro">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h3>Sweet Swap ‚Äì Anleitung</h3>
            <div class="sub">Best√§tigen, dann startet das Spiel ‚ú®</div>
          </div>
        </div>
      </div>

      <div class="modalBody">
        <p><b>Ziel:</b> Tausche 2 benachbarte Candies ‚Üí mach <b>3+</b> in Reihe/Spalte. Kettenreaktionen erh√∂hen den <b>Combo</b>-Multiplikator.</p>

        <div class="modalGrid">
          <div class="modalCard">
            <b>Steuerung</b>
            <ul style="margin:0; padding-left:18px">
              <li><b>PC:</b> Klick Candy ‚Üí Klick Nachbar</li>
              <li><b>Mobile:</b> Antippen & <b>wischen</b></li>
              <li><kbd>R</kbd> Neustart, <kbd>H</kbd> Hint</li>
            </ul>
          </div>
          <div class="modalCard">
            <b>Specials (weniger Spawn)</b>
            <div style="opacity:.92">
              <div style="margin:6px 0"><b>Citrussy</b>: Kreuz-Explosion Radius <b>3</b>.</div>
              <div style="margin:6px 0"><b>Sourworm</b>: l√∂scht <b>ganze Reihe</b> (horizontal).</div>
              <div style="margin:6px 0"><b>Koala</b>:
                <ul style="margin:6px 0 0; padding-left:18px">
                  <li>Koala + Citrussy ‚Üí <b>Board wipe</b> + Bonus</li>
                  <li>Koala + Sourworm ‚Üí wie Citrussy (Radius 3)</li>
                  <li>Koala + Sweety/Sleepy/Normal/Cry ‚Üí l√∂scht <b>alle</b> dieser Sorte</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <div class="help" style="margin-top:12px">
          <div style="font-weight:900; margin-bottom:6px">Leaderboard (optional)</div>
          <div style="opacity:.9">
            Du kannst ein Supabase-Leaderboard aktivieren. Daf√ºr brauchst du <b>URL</b> + <b>Anon Key</b> (nie Secret Key im Browser!).
          </div>
        </div>
      </div>

      <div class="modalFoot">
        <button class="ghost" id="introCloseHint">Sp√§ter nochmal anzeigen</button>
        <button id="introStart">Verstanden, los geht‚Äôs! ‚ú®</button>
      </div>
    </div>
  </div>

  <!-- GameOver / LevelUp Overlay -->
  <div class="overlayBack" id="overlayBack">
    <div class="overlay">
      <div class="body">
        <h3 id="overlayTitle">Game Over</h3>
        <p id="overlayText">‚Äî</p>
        <p class="tiny" id="overlaySmall">‚Äî</p>
      </div>
      <div class="foot">
        <button class="ghost" id="overlayPost">Score posten</button>
        <button id="overlayPlay">Weiter / Neues Spiel</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <section class="card">
      <div class="header">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Sweet Swap</h1>
            <div class="sub">Langsamere Swaps, weniger Specials, mehr ‚ÄûBling & Peng‚Äú ‚ú®üí•</div>
          </div>
        </div>
        <div class="btns">
          <button class="ghost" id="howBtn">Anleitung</button>
          <button id="newBtn">Neues Spiel</button>
          <button class="secondary" id="hintBtn">Hint</button>
        </div>
      </div>

      <div class="hud">
        <div class="stat"><div class="k">Level</div><div class="v" id="level">1</div></div>
        <div class="stat"><div class="k">Ziel</div><div class="v" id="goal">4000</div></div>
        <div class="stat"><div class="k">Score</div><div class="v" id="score">0</div></div>
        <div class="stat"><div class="k">Moves</div><div class="v" id="moves">30</div></div>
      </div>

      <div class="boardWrap">
        <div class="board" id="board">
          <div class="grid" id="grid"></div>
        </div>
      </div>

      <div class="footerNote">Pro-Tipp: Koala + Sweety entfernt alle Sweeties ‚Äì KOALA ist jetzt eine echte ‚ÄûColor Bomb‚Äú üê®‚ú®</div>
    </section>

    <aside class="card side">
      <h2>Quick-Tipps</h2>
      <div class="help">
        <p style="margin-top:0"><b>Weniger Specials:</b> Sourworm / Citrussy / Koala sind jetzt selten und zus√§tzlich gecappt, damit nicht nur W√ºrmer spawnen.</p>
        <p><b>Level-System:</b> Erreiche das Ziel ‚Üí n√§chstes Level mit h√∂herem Ziel & Bonus-Moves.</p>
        <p style="margin-bottom:0"><b>Leaderboard:</b> Poste deinen Score bei ‚ÄûGame Over‚Äú (oder manuell).</p>
      </div>

      <div class="progress">
        <div><b>Fortschritt zum Ziel</b></div>
        <div class="bar"><div id="goalBar"></div></div>
        <div style="margin-top:10px; font-size:13px; opacity:.9" id="status">Match ein paar Candies ‚ú®</div>
      </div>

      <div class="leader">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
          <div><b>Leaderboard</b></div>
          <button class="ghost" id="refreshLb" style="padding:8px 10px; border-radius:12px;">Refresh</button>
        </div>

        <div class="row">
          <div style="flex:1 1 180px">
            <div class="tiny" style="margin:8px 0 6px">Dein Name</div>
            <input id="playerName" placeholder="z.B. KOALAaufPILLEN" maxlength="24" />
            <div class="tiny" style="margin-top:6px;">
              Auto-Post bei Game Over:
              <label style="font-weight:800; margin-left:6px;">
                <input type="checkbox" id="autoPost" checked />
                an
              </label>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px; justify-content:flex-end;">
          <button class="ghost" id="postNow">Score posten</button>
        </div>

        <div class="tiny" id="sbStatus" style="margin-top:8px;">
          Supabase: <b>nicht konfiguriert</b> (unten im Code URL/Key setzen)
        </div>

        <div class="lb" id="lbList" style="margin-top:10px;"></div>
      </div>

      <div class="footerNote">
        Candy-Bilder werden von Wix geladen (Internet n√∂tig). F√ºr Offline: Base64 einbetten.
      </div>
    </aside>
  </div>

<script>
(() => {
  const N = 8;

  // --- Candy Images (deine URLs) ---
  const IMG = {
    citrussy: "https://static.wixstatic.com/media/d05122_9cdc763a1ec94a90a3fd91ee3481b2c4~mv2.png",
    sourworm: "https://static.wixstatic.com/media/d05122_a8e7a37e04694ff2a99b8af60f1567b7~mv2.png",
    sweety:   "https://static.wixstatic.com/media/d05122_efe39fec7e5c4d569dfb3fef75e5b6ff~mv2.png",
    sleepy:   "https://static.wixstatic.com/media/d05122_cfd779a0aad04c72bd08efbc0f363f53~mv2.png",
    normal:   "https://static.wixstatic.com/media/d05122_8a7c2f43a31247a6994651163c2898c5~mv2.png",
    cry:      "https://static.wixstatic.com/media/d05122_1950f2496b344e56bcac10ea51286750~mv2.png",
    koala:    "https://static.wixstatic.com/media/d05122_9cb17e901a1a4775819bfda895d0f1c9~mv2.png",
  };

  // --- Types ---
  const T = { SWEETY:0, SLEEPY:1, NORMAL:2, CRY:3, SOUR:4, CIT:5, KOALA:6 };

  // Weniger Specials + zus√§tzlich Caps (damit nicht ‚Äúnur W√ºrmer‚Äù)
  const CANDIES = [
    { id:T.SWEETY,   name:"Sweety",   cls:"t-sweety",   img:IMG.sweety,   weight:36, special:false },
    { id:T.SLEEPY,   name:"Sleepy",   cls:"t-sleepy",   img:IMG.sleepy,   weight:28, special:false },
    { id:T.NORMAL,   name:"Normal",   cls:"t-normal",   img:IMG.normal,   weight:28, special:false },
    { id:T.CRY,      name:"Cry",      cls:"t-cry",      img:IMG.cry,      weight:24, special:false },

    { id:T.SOUR,     name:"Sourworm", cls:"t-sourworm", img:IMG.sourworm, weight:5,  special:true  },
    { id:T.CIT,      name:"Citrussy", cls:"t-citrussy", img:IMG.citrussy, weight:2,  special:true  },
    { id:T.KOALA,    name:"Koala",    cls:"t-koala",    img:IMG.koala,    weight:1,  special:true  },
  ];

  // Caps per board (hart)
  const CAPS = { [T.SOUR]: 4, [T.CIT]: 2, [T.KOALA]: 1 };

  // --- Supabase config (F√úLLE DAS AUS) ---
  // WICHTIG: Nur Anon Key hier rein, niemals Secret Key.
  const SUPABASE_URL = "";       // z.B. "https://xxxx.supabase.co"
  const SUPABASE_ANON = "";      // z.B. "eyJhbGciOiJIUzI1NiIs..."
  // Tabelle (SQL) Vorschlag:
  // create table leaderboard (
  //   id uuid primary key default gen_random_uuid(),
  //   player text not null,
  //   score int not null,
  //   level int not null,
  //   created_at timestamptz not null default now()
  // );
  // RLS: an (row level security) + Policies:
  // - Select: public
  // - Insert: public
  // (Oder restriktiver wenn du willst)

  // --- DOM ---
  const gridEl   = document.getElementById("grid");
  const boardEl  = document.getElementById("board");

  const levelEl = document.getElementById("level");
  const goalEl  = document.getElementById("goal");
  const scoreEl = document.getElementById("score");
  const movesEl = document.getElementById("moves");
  const goalBarEl = document.getElementById("goalBar");
  const statusEl = document.getElementById("status");

  const newBtn  = document.getElementById("newBtn");
  const hintBtn = document.getElementById("hintBtn");
  const howBtn  = document.getElementById("howBtn");

  const intro = document.getElementById("intro");
  const introStart = document.getElementById("introStart");
  const introCloseHint = document.getElementById("introCloseHint");

  const overlayBack = document.getElementById("overlayBack");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlaySmall = document.getElementById("overlaySmall");
  const overlayPlay = document.getElementById("overlayPlay");
  const overlayPost = document.getElementById("overlayPost");

  const playerNameEl = document.getElementById("playerName");
  const autoPostEl = document.getElementById("autoPost");
  const postNowBtn = document.getElementById("postNow");
  const refreshLbBtn = document.getElementById("refreshLb");
  const lbList = document.getElementById("lbList");
  const sbStatus = document.getElementById("sbStatus");

  // Persist name
  playerNameEl.value = localStorage.getItem("sweetSwap_player") || "";
  playerNameEl.addEventListener("input", () => localStorage.setItem("sweetSwap_player", playerNameEl.value.trim()));

  // --- State ---
  let board = [];
  let score = 0;
  let moves = 30;

  let level = 1;
  let goal = 4000;

  let busy = false;
  let first = null;

  let down = null;
  let downCell = null;
  let draggingEl = null;

  // Supabase client
  let sb = null;
  function initSupabase(){
    try{
      if(SUPABASE_URL && SUPABASE_ANON && window.supabase){
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
        sbStatus.innerHTML = `Supabase: <b>aktiv</b> ‚úÖ`;
      } else {
        sb = null;
        sbStatus.innerHTML = `Supabase: <b>nicht konfiguriert</b> (unten im Code URL/Key setzen)`;
      }
    } catch {
      sb = null;
      sbStatus.innerHTML = `Supabase: <b>Fehler</b> (SDK blockiert?)`;
    }
  }
  initSupabase();

  // --- Utils ---
  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function toast(text){
    const t = document.createElement("div");
    t.className = "toast";
    t.textContent = text;
    boardEl.appendChild(t);
    setTimeout(() => t.remove(), 1100);
  }
  function setStatus(text){ statusEl.textContent = text; }

  function updateHUD(){
    levelEl.textContent = level;
    goalEl.textContent  = goal;
    scoreEl.textContent = score;
    movesEl.textContent = moves;

    const pct = clamp((score/goal)*100, 0, 100);
    goalBarEl.style.width = pct.toFixed(1) + "%";

    if(moves <= 0){
      setStatus("‚è≥ Keine Moves mehr ‚Äì Game Over!");
    } else if(score >= goal){
      setStatus("üéâ Ziel erreicht! Weiter zum n√§chsten Level!");
    } else {
      setStatus("Finde ein Match ‚ú®");
    }
  }

  function candyMeta(type){ return CANDIES.find(c => c.id === type); }

  function countTypes(){
    const counts = {};
    for(const c of CANDIES) counts[c.id] = 0;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const t = board[r][c];
      if(t != null) counts[t] = (counts[t]||0) + 1;
    }
    return counts;
  }

  // weighted random with caps
  function randTypeCapped(counts){
    // build effective weights
    let total = 0;
    const eff = CANDIES.map(c => {
      let w = c.weight;
      if(CAPS[c.id] != null && (counts[c.id]||0) >= CAPS[c.id]) w = 0;
      total += w;
      return w;
    });

    // fallback if everything 0 (shouldn't happen)
    if(total <= 0){
      return T.SWEETY;
    }

    let x = Math.random() * total;
    for(let i=0;i<CANDIES.length;i++){
      x -= eff[i];
      if(x <= 0) return CANDIES[i].id;
    }
    return CANDIES[0].id;
  }

  function enforceCaps(){
    const counts = countTypes();
    for(const [tStr, cap] of Object.entries(CAPS)){
      const t = +tStr;
      while(counts[t] > cap){
        // replace one extra with a normal type
        let replaced = false;
        for(let tries=0; tries<200 && !replaced; tries++){
          const r = Math.floor(Math.random()*N);
          const c = Math.floor(Math.random()*N);
          if(board[r][c] === t){
            // choose a non-special type
            const normals = [T.SWEETY, T.SLEEPY, T.NORMAL, T.CRY];
            const nt = normals[Math.floor(Math.random()*normals.length)];
            board[r][c] = nt;
            counts[t]--;
            counts[nt] = (counts[nt]||0)+1;
            replaced = true;
          }
        }
        if(!replaced) break;
      }
    }
  }

  // --- Grid DOM build (stable elements) ---
  function buildGridDom(){
    gridEl.innerHTML = "";
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.r = r;
        cell.dataset.c = c;

        const candy = document.createElement("div");
        candy.className = "candy";
        candy.dataset.r = r;
        candy.dataset.c = c;

        const img = document.createElement("img");
        img.alt = "candy";
        img.draggable = false;

        candy.appendChild(img);
        cell.appendChild(candy);
        gridEl.appendChild(cell);
      }
    }
  }
  const cellEl = (r,c) => gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  const candyEl = (r,c) => gridEl.querySelector(`.candy[data-r="${r}"][data-c="${c}"]`);

  function syncCell(r,c){
    const t = board[r][c];
    const el = candyEl(r,c);
    if(!el) return;

    el.classList.remove("t-sweety","t-sleepy","t-normal","t-cry","t-sourworm","t-citrussy","t-koala");
    if(t==null){
      el.style.visibility = "hidden";
      return;
    }
    el.style.visibility = "visible";
    const meta = candyMeta(t);
    el.classList.add(meta.cls);
    el.querySelector("img").src = meta.img;
  }

  function renderAll(){
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) syncCell(r,c);
  }

  // --- Matches ---
  function hasMatchAt(r,c){
    const t = board[r][c];
    if(t==null) return false;

    // horizontal
    let cnt=1;
    for(let x=c-1; x>=0 && board[r][x]===t; x--) cnt++;
    for(let x=c+1; x<N && board[r][x]===t; x++) cnt++;
    if(cnt>=3) return true;

    // vertical
    cnt=1;
    for(let y=r-1; y>=0 && board[y][c]===t; y--) cnt++;
    for(let y=r+1; y<N && board[y][c]===t; y++) cnt++;
    return cnt>=3;
  }

  function findMatches(){
    const marks = Array.from({length:N}, () => Array(N).fill(false));

    // horizontal
    for(let r=0;r<N;r++){
      let c=0;
      while(c<N){
        const t = board[r][c];
        let run=1;
        while(c+run<N && board[r][c+run]===t) run++;
        if(t!=null && run>=3){
          for(let k=0;k<run;k++) marks[r][c+k]=true;
        }
        c += run;
      }
    }

    // vertical
    for(let c=0;c<N;c++){
      let r=0;
      while(r<N){
        const t = board[r][c];
        let run=1;
        while(r+run<N && board[r+run][c]===t) run++;
        if(t!=null && run>=3){
          for(let k=0;k<run;k++) marks[r+k][c]=true;
        }
        r += run;
      }
    }

    const cells=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(marks[r][c]) cells.push({r,c});
    }
    return cells;
  }

  // --- Bling ---
  function addSparkles(r,c, count=6){
    const el = cellEl(r,c);
    if(!el) return;
    for(let i=0;i<count;i++){
      const s = document.createElement("div");
      s.className = "sparkle";
      s.style.left = (30 + Math.random()*40) + "%";
      s.style.top  = (35 + Math.random()*40) + "%";
      s.style.animationDelay = (Math.random()*90) + "ms";
      el.appendChild(s);
      setTimeout(()=>s.remove(), 800);
    }
  }
  function addBoomRing(r,c){
    const el = cellEl(r,c);
    if(!el) return;
    const ring = document.createElement("div");
    ring.className = "boomRing";
    el.appendChild(ring);
    setTimeout(()=>ring.remove(), 820);
  }
  function wobble(r,c){
    const el = candyEl(r,c);
    if(!el) return;
    el.classList.remove("wobble");
    void el.offsetWidth;
    el.classList.add("wobble");
  }

  // --- Special clearing patterns ---
  function addCrossRadius3(set, r, c){
    for(let d=0; d<=3; d++){
      if(r-d>=0) set.add(`${r-d},${c}`);
      if(r+d<N) set.add(`${r+d},${c}`);
      if(c-d>=0) set.add(`${r},${c-d}`);
      if(c+d<N) set.add(`${r},${c+d}`);
    }
  }
  function addRow(set, r){
    for(let c=0;c<N;c++) set.add(`${r},${c}`);
  }
  function addAll(set){
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) set.add(`${r},${c}`);
  }

  function expandClearsFromSpecials(matchCells){
    const set = new Set(matchCells.map(p => `${p.r},${p.c}`));
    for(const p of matchCells){
      const t = board[p.r][p.c];
      if(t === T.CIT){
        addBoomRing(p.r,p.c);
        addCrossRadius3(set, p.r, p.c);
      }
      if(t === T.SOUR){
        addBoomRing(p.r,p.c);
        addRow(set, p.r);
      }
    }
    return set;
  }

  async function animatePopCells(set){
    for(const key of set){
      const [r,c] = key.split(",").map(Number);
      const el = candyEl(r,c);
      if(el && board[r][c]!=null){
        el.classList.add("pop");
        addSparkles(r,c, 6);
      }
    }
    await sleep(300);
    for(const key of set){
      const [r,c] = key.split(",").map(Number);
      const el = candyEl(r,c);
      if(el) el.classList.remove("pop");
    }
  }

  function collapseAndRefill(){
    // gravity
    for(let c=0;c<N;c++){
      let write = N-1;
      for(let r=N-1;r>=0;r--){
        if(board[r][c]!=null){
          board[write][c] = board[r][c];
          if(write!==r) board[r][c]=null;
          write--;
        }
      }
      // refill with caps-aware RNG
      const counts = countTypes();
      for(let r=write;r>=0;r--){
        const t = randTypeCapped(counts);
        board[r][c] = t;
        counts[t] = (counts[t]||0)+1;
      }
    }
    enforceCaps();
  }

  function swapBoard(a,b){
    const tmp = board[a.r][a.c];
    board[a.r][a.c] = board[b.r][b.c];
    board[b.r][b.c] = tmp;
  }
  function isAdjacent(a,b){
    const dr = Math.abs(a.r-b.r);
    const dc = Math.abs(a.c-b.c);
    return (dr+dc)===1;
  }

  // Swap animation by measuring actual element positions (works with responsive 1fr grid)
  async function animateSwap(a,b){
    const elA = candyEl(a.r,a.c);
    const elB = candyEl(b.r,b.c);
    if(!elA || !elB) return;

    const ra = elA.getBoundingClientRect();
    const rb = elB.getBoundingClientRect();
    const dx = rb.left - ra.left;
    const dy = rb.top  - ra.top;

    elA.style.transform = `translate(${dx}px, ${dy}px)`;
    elB.style.transform = `translate(${-dx}px, ${-dy}px)`;
    await sleep(290);
    elA.style.transform = "";
    elB.style.transform = "";
    await sleep(10);
  }

  // --- Selection ---
  function clearSelection(){
    gridEl.querySelectorAll(".candy.selected").forEach(el => el.classList.remove("selected"));
    first = null;
  }
  function select(r,c){
    if(moves<=0 || busy) return;
    clearSelection();
    first = {r,c};
    const el = candyEl(r,c);
    if(el) el.classList.add("selected");
  }

  // --- Settle loop (cascades) ---
  async function settle(){
    let chain = 0;
    while(true){
      const matches = findMatches();
      if(matches.length === 0) break;

      chain++;
      const clearSet = expandClearsFromSpecials(matches);

      // score
      const gained = clearSet.size * (12 + chain*2);
      score += gained;
      toast(`+${gained} ‚ú® BLING!`);

      // wobble a few
      let i=0;
      for(const k of clearSet){ if(i++<5){ const [r,c]=k.split(",").map(Number); wobble(r,c);} }

      await animatePopCells(clearSet);

      for(const key of clearSet){
        const [r,c] = key.split(",").map(Number);
        board[r][c] = null;
      }

      collapseAndRefill();
      renderAll();
      await sleep(90);
    }

    updateHUD();
    await maybeLevelUp();
    if(moves<=0) await onGameOver();
  }

  function anyPossibleMove(){
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const a = {r,c};
        const neigh = [];
        if(c+1<N) neigh.push({r,c:c+1});
        if(r+1<N) neigh.push({r:r+1,c});
        for(const b of neigh){
          swapBoard(a,b);
          const ok = findMatches().length>0;
          swapBoard(a,b);
          if(ok) return {a,b};
        }
      }
    }
    return null;
  }

  // --- Level system ---
  async function maybeLevelUp(){
    if(score < goal) return;

    // Level complete!
    overlayTitle.textContent = `üéâ Level ${level} geschafft!`;
    overlayText.textContent = `Du hast das Ziel ${goal} erreicht. Weiter geht‚Äôs!`;
    overlaySmall.textContent = `Bonus: +8 Moves und neues Ziel.`;
    overlayBack.style.display = "grid";

    // next level params
    level++;
    moves += 8;
    goal = Math.round(goal * 1.35 + 450);

    // little board sparkle
    for(let k=0;k<18;k++){
      const r = Math.floor(Math.random()*N);
      const c = Math.floor(Math.random()*N);
      addSparkles(r,c, 7);
      if(k%5===0) addBoomRing(r,c);
    }

    updateHUD();
  }

  async function onGameOver(){
    if(overlayBack.style.display === "grid") return;

    overlayTitle.textContent = `üíÄ Game Over`;
    overlayText.textContent = `Score: ${score} | Level: ${level}`;
    overlaySmall.textContent = `Wenn du willst: poste deinen Run ins Leaderboard.`;
    overlayBack.style.display = "grid";

    if(autoPostEl.checked){
      await postScore();
    }
  }

  overlayPlay.addEventListener("click", () => {
    overlayBack.style.display = "none";
    if(moves<=0) start(); // new run
    else updateHUD();     // continue after level-up
  });

  overlayPost.addEventListener("click", async () => {
    await postScore();
  });

  // --- Special activation by swap ("merge") ---
  async function activateSpecialBySwap(a,b){
    const tA = board[a.r][a.c];
    const tB = board[b.r][b.c];
    const set = new Set();

    const isKoalaA = (tA === T.KOALA);
    const isKoalaB = (tB === T.KOALA);

    if(isKoalaA || isKoalaB){
      const koalaPos = isKoalaA ? a : b;
      const otherPos = isKoalaA ? b : a;
      const otherT   = isKoalaA ? tB : tA;

      addBoomRing(koalaPos.r, koalaPos.c);
      addSparkles(koalaPos.r, koalaPos.c, 12);

      if(otherT === T.CIT){
        addAll(set);
        score += 900;
        toast("üê®üí• MEGA WIPE! +900");
      } else if(otherT === T.SOUR){
        addCrossRadius3(set, koalaPos.r, koalaPos.c);
        score += 300;
        toast("üê®‚ö° KOALA BLAST! +300");
      } else {
        // remove all of that color/type
        for(let r=0;r<N;r++) for(let c=0;c<N;c++){
          if(board[r][c] === otherT) set.add(`${r},${c}`);
        }
        score += 400;
        toast("üê®‚ú® FARBE WEG! +400");
      }

      // remove swapped pair too
      set.add(`${a.r},${a.c}`);
      set.add(`${b.r},${b.c}`);

      await animateSwap(a,b);
      moves--;
      updateHUD();

      for(const k of set){ const [r,c]=k.split(",").map(Number); if(Math.random()<0.35) addBoomRing(r,c); }

      await animatePopCells(set);
      for(const k of set){
        const [r,c]=k.split(",").map(Number);
        board[r][c] = null;
      }
      collapseAndRefill();
      renderAll();
      await sleep(70);
      await settle();
      return true;
    }

    const hasCit  = (tA===T.CIT || tB===T.CIT);
    const hasSour = (tA===T.SOUR || tB===T.SOUR);

    if(hasCit || hasSour){
      await animateSwap(a,b);
      moves--;
      updateHUD();

      if(tA===T.CIT) { addBoomRing(a.r,a.c); addCrossRadius3(set, a.r,a.c); }
      if(tB===T.CIT) { addBoomRing(b.r,b.c); addCrossRadius3(set, b.r,b.c); }

      if(tA===T.SOUR) { addBoomRing(a.r,a.c); addRow(set, a.r); }
      if(tB===T.SOUR) { addBoomRing(b.r,b.c); addRow(set, b.r); }

      set.add(`${a.r},${a.c}`);
      set.add(`${b.r},${b.c}`);

      const gained = set.size * 18;
      score += gained;
      toast(`+${gained} üí• PENG!`);

      await animatePopCells(set);
      for(const k of set){
        const [r,c]=k.split(",").map(Number);
        board[r][c]=null;
      }
      collapseAndRefill();
      renderAll();
      await sleep(70);
      await settle();
      return true;
    }

    return false;
  }

  async function trySwap(a,b){
    if(busy || moves<=0) return;
    if(!isAdjacent(a,b)) return;

    busy = true;
    gridEl.classList.add("blocked");

    const didSpecial = await activateSpecialBySwap(a,b);
    if(didSpecial){
      clearSelection();
      if(!anyPossibleMove() && moves>0){
        toast("üîÑ Keine Z√ºge ‚Äì Mische neu!");
        reshuffle();
        renderAll();
        await settle();
      }
      busy = false;
      gridEl.classList.remove("blocked");
      return;
    }

    // normal swap (must create match)
    await animateSwap(a,b);
    swapBoard(a,b);
    syncCell(a.r,a.c); syncCell(b.r,b.c);
    await sleep(10);

    const matches = findMatches();
    if(matches.length===0){
      toast("‚ùå Kein Match");
      await animateSwap(a,b);
      swapBoard(a,b);
      syncCell(a.r,a.c); syncCell(b.r,b.c);
      busy = false;
      gridEl.classList.remove("blocked");
      updateHUD();
      return;
    }

    moves--;
    clearSelection();
    updateHUD();
    await settle();

    if(!anyPossibleMove() && moves>0){
      toast("üîÑ Keine Z√ºge ‚Äì Mische neu!");
      reshuffle();
      renderAll();
      await settle();
    }

    busy = false;
    gridEl.classList.remove("blocked");
  }

  function reshuffle(){
    const flat = board.flat();
    for(let i=flat.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [flat[i],flat[j]] = [flat[j],flat[i]];
    }
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      board[r][c] = flat[r*N + c];
    }
    enforceCaps();
  }

  // --- Input handling ---
  function cellFromEvent(e){
    const target = e.target.closest(".candy");
    if(!target) return null;
    return { r:+target.dataset.r, c:+target.dataset.c };
  }

  // Click
  gridEl.addEventListener("click", async (e) => {
    if(intro.style.display !== "none") return;
    if(overlayBack.style.display === "grid") return;

    const p = cellFromEvent(e);
    if(!p || busy || moves<=0) return;

    if(!first) select(p.r,p.c);
    else{
      const a = first;
      const b = p;
      if(a.r===b.r && a.c===b.c){ clearSelection(); return; }
      if(isAdjacent(a,b)) await trySwap(a,b);
      else select(b.r,b.c);
    }
  });

  // Drag/swipe feel (slower + more ‚Äúpull‚Äù)
  gridEl.addEventListener("pointerdown", (e) => {
    if(intro.style.display !== "none") return;
    if(overlayBack.style.display === "grid") return;
    if(busy || moves<=0) return;

    const p = cellFromEvent(e);
    if(!p) return;

    down = {x:e.clientX, y:e.clientY};
    downCell = p;
    select(p.r,p.c);

    draggingEl = candyEl(p.r,p.c);
    if(draggingEl){
      draggingEl.classList.add("dragging");
    }
  });

  gridEl.addEventListener("pointermove", (e) => {
    if(!down || !downCell || !draggingEl) return;
    const dx = e.clientX - down.x;
    const dy = e.clientY - down.y;

    // dynamic clamp based on cell size
    const cell = cellEl(downCell.r, downCell.c);
    const rect = cell.getBoundingClientRect();
    const lim = Math.max(18, rect.width * 0.35);

    const tx = clamp(dx, -lim, lim);
    const ty = clamp(dy, -lim, lim);
    draggingEl.style.transform = `translate(${tx}px, ${ty}px) scale(1.04) rotate(${tx*0.12}deg)`;
  });

  gridEl.addEventListener("pointerup", async (e) => {
    if(!down || !downCell) { down=null; downCell=null; return; }

    const dx = e.clientX - down.x;
    const dy = e.clientY - down.y;
    const ax = Math.abs(dx), ay = Math.abs(dy);

    // reset drag style
    if(draggingEl){
      draggingEl.classList.remove("dragging");
      draggingEl.style.transform = "";
      draggingEl = null;
    }

    if(Math.max(ax,ay) >= 16){
      let dir;
      if(ax > ay) dir = dx > 0 ? "R" : "L";
      else dir = dy > 0 ? "D" : "U";

      const a = downCell;
      const b = {r:a.r, c:a.c};
      if(dir==="R") b.c++;
      if(dir==="L") b.c--;
      if(dir==="D") b.r++;
      if(dir==="U") b.r--;

      down=null; downCell=null;

      if(b.r<0 || b.r>=N || b.c<0 || b.c>=N) return;
      await trySwap(a,b);
      return;
    }

    down=null; downCell=null;
  });

  // Hint
  async function hint(){
    if(intro.style.display !== "none") return;
    if(overlayBack.style.display === "grid") return;
    if(busy || moves<=0) return;

    const mv = anyPossibleMove();
    if(!mv){ toast("üòµ Keine Moves!"); return; }
    const {a,b} = mv;
    const ea = candyEl(a.r,a.c);
    const eb = candyEl(b.r,b.c);
    if(ea) ea.classList.add("selected");
    if(eb) eb.classList.add("selected");
    toast("üí° Versuch diese zwei!");
    setTimeout(() => {
      if(ea) ea.classList.remove("selected");
      if(eb) eb.classList.remove("selected");
      clearSelection();
    }, 600);
  }
  hintBtn.addEventListener("click", hint);

  // Keyboard
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k==="r") start();
    if(k==="h") hint();
  });

  // Intro controls
  function showIntro(){ intro.style.display = "grid"; }
  function hideIntro(){ intro.style.display = "none"; }
  howBtn.addEventListener("click", showIntro);
  introStart.addEventListener("click", () => { localStorage.setItem("sweetSwap_hideIntro","1"); hideIntro(); });
  introCloseHint.addEventListener("click", hideIntro);

  // --- Leaderboard ---
  async function fetchLeaderboard(){
    if(!sb){
      lbList.innerHTML = `<div class="tiny">Kein Supabase konfiguriert.</div>`;
      return;
    }
    const { data, error } = await sb
      .from("leaderboard")
      .select("player, score, level, created_at")
      .order("score", { ascending:false })
      .limit(10);

    if(error){
      lbList.innerHTML = `<div class="tiny">Leaderboard Fehler: ${escapeHtml(error.message)}</div>`;
      return;
    }

    if(!data || data.length===0){
      lbList.innerHTML = `<div class="tiny">Noch keine Scores. Sei der Erste üòÑ</div>`;
      return;
    }

    lbList.innerHTML = data.map((row, idx) => `
      <div class="lbItem">
        <div class="lbLeft">
          <div class="rank">${idx+1}</div>
          <div>
            <div style="font-weight:900">${escapeHtml(row.player || "Unknown")}</div>
            <div class="tiny">Lvl ${row.level} ¬∑ ${new Date(row.created_at).toLocaleString()}</div>
          </div>
        </div>
        <div style="font-weight:900">${row.score}</div>
      </div>
    `).join("");
  }

  async function postScore(){
    const player = (playerNameEl.value || "").trim();
    if(!player){
      toast("‚úçÔ∏è Bitte Namen eingeben");
      return;
    }
    if(!sb){
      toast("‚ö†Ô∏è Supabase nicht konfiguriert");
      return;
    }

    const payload = { player, score, level, created_at: new Date().toISOString() };
    const { error } = await sb.from("leaderboard").insert(payload);

    if(error){
      toast("‚ùå Post fehlgeschlagen");
      sbStatus.innerHTML = `Supabase: <b>Fehler</b> (${escapeHtml(error.message)})`;
      return;
    }

    toast("‚úÖ Score gepostet!");
    await fetchLeaderboard();
  }

  postNowBtn.addEventListener("click", postScore);
  refreshLbBtn.addEventListener("click", fetchLeaderboard);

  // refresh every 20s (competition feel)
  setInterval(() => { fetchLeaderboard(); }, 20000);

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }

  // --- Start game ---
  function makeBoard(){
    board = Array.from({length:N}, () => Array.from({length:N}, () => null));
    const counts = {};
    for(const c of CANDIES) counts[c.id]=0;

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        let t, tries=0;
        do{
          t = randTypeCapped(counts);
          board[r][c] = t;
          tries++;
        } while(tries<50 && hasMatchAt(r,c));
        counts[t] = (counts[t]||0)+1;
      }
    }
    enforceCaps();
  }

  async function start(){
    score = 0;
    moves = 30;
    level = 1;
    goal  = 4000;

    busy = true;
    clearSelection();

    makeBoard();
    renderAll();
    updateHUD();

    await settle();

    if(!anyPossibleMove()){
      reshuffle();
      renderAll();
      await settle();
    }

    busy = false;
    toast("üç¨ Let‚Äôs go!");
    updateHUD();

    await fetchLeaderboard();
  }

  // Boot
  buildGridDom();
  start();

  // show intro unless hidden before (wenn du‚Äôs JEDES MAL willst: diese 2 Zeilen l√∂schen + showIntro() immer)
  const hide = localStorage.getItem("sweetSwap_hideIntro") === "1";
  if(!hide) showIntro(); else hideIntro();

  // New game button
  newBtn.addEventListener("click", () => {
    overlayBack.style.display = "none";
    start();
  });

})();
</script>
</body>
</html>
