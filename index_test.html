<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Luvvies Crush</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg1:#f7f2ff;
      --bg2:#eaf6ff;
      --card:#ffffffd9;
      --card2:#ffffffef;
      --stroke:rgba(17,13,26,.10);
      --shadow: 0 18px 60px rgba(20,10,60,.12);
      --txt:#1d1334;

      --cols: 10;
      --rows: 10;
      --cell: 54px;
      --gap: 8px;
      --pad: 14px;
      --boardRadius: 26px;

      --toastMs: 2600ms;
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body.dark{
      --bg1:#141020;
      --bg2:#1f1830;
      --card:#252035d9;
      --card2:#2d2640ef;
      --stroke:rgba(255,255,255,.08);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --txt:#f2f0ff;
    }
    body.dark .diffPills{
      background: rgba(30,25,45,.78);
      border:1px solid rgba(255,255,255,.08);
    }
    body.dark .diffPills label{ color:#cfc5e5; }
    body.dark .luvCard, body.dark .lbItem, body.dark .toast{
      background: rgba(40,35,60,.82);
      border:1px solid rgba(255,255,255,.08);
      color: var(--txt);
    }
    body.dark .lbRow input{
      background: rgba(40,35,60,.92);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }
    body.dark .modal{
      background: rgba(30,26,45,.96);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txt);
      overflow:hidden;
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      position:relative;
      transition: background 0.3s ease, color 0.3s ease;
    }

    /* Scroll container (scrollbar hidden) */
    #page{
      height:100vh;
      overflow:auto;
      position:relative;
      z-index:0;
    }
    #page{ scrollbar-width:none; }
    #page::-webkit-scrollbar{ width:0; height:0; }

    /* Scrollender Background Layer */
    #scrollBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      min-height: 120vh;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,105,180,.14), transparent 48%),
        radial-gradient(circle at 85% 25%, rgba(122,216,255,.20), transparent 52%),
        radial-gradient(circle at 55% 75%, rgba(255,209,90,.16), transparent 50%),
        linear-gradient(120deg,
          rgba(255,79,185,.18),
          rgba(255,209,90,.14),
          rgba(122,216,255,.18),
          rgba(139,92,246,.14),
          rgba(255,79,185,.18)
        );
      background-size: auto, auto, auto, 300% 300%;
      filter: blur(18px);
      opacity:.55;
      animation: bgMove 18s ease-in-out infinite;
    }
    @keyframes bgMove{
      0%{ background-position: 0% 50% }
      50%{ background-position: 100% 50% }
      100%{ background-position: 0% 50% }
    }

    #globalBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      overflow:hidden;
    }

    #darkOverlay{
      position:fixed;
      inset:0;
      z-index:4;
      background:#000;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }

    /* Background luvvies: langsamer + fade, immer hinter allem */
    .bgLuv{
      position:absolute;
      width: clamp(150px, 17vw, 300px);
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.10));
      opacity:.72;
      animation: floaty 18s ease-in-out infinite;
      z-index:0;
      pointer-events:none;
    }
    .bgLuv img{ width:100%; height:auto; display:block; }
    @keyframes floaty{
      0%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
      50%{ transform: translate(10px,-16px) rotate(1.2deg); opacity:.82; }
      100%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
    }

    /* Subtle twinkles (statt bubbles) */
    .twinkle{
      position:absolute;
      width: 10px; height: 10px;
      left:0; top:0;
      transform: translate(-50%,-50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.15));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: tw 1200ms ease-out forwards;
      filter: drop-shadow(0 0 18px rgba(255,79,185,.18));
    }
    @keyframes tw{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(0deg)}
      20%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-65%) scale(1.15) rotate(140deg)}
    }

    #app{
      width:min(1100px, 96vw);
      margin: 18px auto 28px;
      position:relative;
      z-index:5; /* Vordergrund */
    }

    .topRow{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
      z-index:6;
    }

    #infoBack{ z-index: 100000; } /* Ensure Bio is above Menu */
    /* Hide menus in fullscreen */
    body.fs .below, body.fs .topRow, body.fs .stats, body.fs .progressRow, body.fs #luvPanel, body.fs #rightPanel, body.fs #settingsBack {
      display: none !important;
    }

    .diffWrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .diffWrap .label{font-weight:900;opacity:.9;margin-right:4px}
    .diffPills{
      display:flex;
      gap:8px; padding:6px;
      border-radius:999px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(17,13,26,.08);
    }
    .diffPills input{display:none}
    .diffPills label{
      cursor:pointer;
      user-select:none;
      padding:10px 14px; border-radius:999px;
      font-weight:900; font-size:14px;
      color:#2b1b4f;
      transition: transform .12s ease, background .2s ease;
    }
    .diffPills input:checked + label{
      background: linear-gradient(135deg, #ff4fb9, #7ad8ff);
      background-size:200% 100%;
      animation: pillGlow 2.2s ease-in-out infinite;
      color:#fff;
      box-shadow: 0 10px 22px rgba(255,79,185,.22);
      transform: translateY(-1px);
    }
    @keyframes pillGlow{
      0%{ background-position:0% 50% }
      50%{ background-position:100% 50% }
      100%{ background-position:0% 50% }
    }

    /* Jelly Button (Custom Image) */
    .Btn{
      position: relative;
      height: 48px;
      padding: 0 20px;
      border-radius: 999px;
      border: none;
      background: url('Images/Button/candies.png') center/cover no-repeat;
      color: white;
      box-shadow: 0 8px 16px rgba(0,0,0,.16);
      text-shadow: 0 2px 4px rgba(0,0,0,.25);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap:8px;
      font-weight:1000;
      letter-spacing:.1px;
      transition: transform .12s ease, filter .12s ease;
      white-space:nowrap;
      filter: saturate(1.1);
    }
    .Btn::before, .Btn::after { display:none; }
    .Btn:hover { animation: jello-horizontal 0.9s both; }
    .Btn:active{ transform: scale(.98); }
    @keyframes jello-horizontal {
      0% { transform: scale3d(1, 1, 1); }
      30% { transform: scale3d(1.20, 0.80, 1); }
      40% { transform: scale3d(0.80, 1.20, 1); }
      50% { transform: scale3d(1.12, 0.88, 1); }
      65% { transform: scale3d(0.96, 1.04, 1); }
      75% { transform: scale3d(1.04, 0.96, 1); }
      100% { transform: scale3d(1, 1, 1); }
    }
    .Btn.secondary{
      background: linear-gradient(135deg, #ff4fb9, #ff9adf);
      box-shadow: 0px 10px 10px rgba(255,200,235,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.15),
                  0px -10px 10px rgba(255,60,180,.55) inset;
    }
    .Btn.ghost{
      background: rgba(255,255,255,.8);
      color:#2a1849;
      box-shadow: 0px 10px 10px rgba(240,240,255,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.10),
                  0px -10px 10px rgba(220,220,255,.55) inset;
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      z-index:6;
    }

    .stats{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
      position:relative;
      z-index:6;
    }
    .stat{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      min-height: 62px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .stat .k{font-weight:900; font-size:12px; opacity:.7}
    .stat .v{font-weight:1000; font-size:20px; margin-top:2px}

    .progressRow{
      margin-top: 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      display:flex;
      align-items:center;
      gap:10px;
      position:relative;
      z-index:6;
    }
    .progressRow b{font-size:14px}
    .bar{
      flex:1;
      height: 14px;
      border-radius:999px;
      background: rgba(140,120,200,.18);
      overflow:hidden;
      border:1px solid rgba(60,20,120,.10);
      position:relative;
    }
    .bar > i{
      display:block;
      height:100%;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg,
        #ff4fb9,
        #ffcf5a,
        #7ad8ff,
        #8b5cf6,
        #ff4fb9
      );
      background-size: 300% 100%;
      animation: barHue 3.2s linear infinite;
      box-shadow: 0 0 18px rgba(255,79,185,.22);
      transition: width .25s ease;
    }
    @keyframes barHue{
      0%{background-position:0% 50%}
      100%{background-position:100% 50%}
    }
    .pct{font-weight:1000; min-width:46px; text-align:right}

    .playArea{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 14px;
      position:relative;
      overflow:visible;
      z-index:6; /* Vordergrund */
      transition: all 0.3s ease;
    }

    /* Maximize Mode */
    body.maximized .topRow, body.maximized .stats, body.maximized .progressRow, body.maximized .below {
       display:none !important;
    }
    body.maximized #app {
       width: 98vw; margin: 10px auto;
    }
    body.maximized .playArea {
       height: 90vh; /* force height */
       padding: 4px;
       border-radius: 12px;
    }

    #boardWrap{
      position:relative;
      width:100%;
      min-height: 64vh;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
      padding: 8px;
      touch-action: none;
    }
    body.maximized #boardWrap { min-height: 90vh; }

    #board{
      position:relative;
      z-index:12; /* Board immer vorne */
      padding: var(--pad);
      border-radius: var(--boardRadius);
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.86), rgba(255,255,255,.35)),
        radial-gradient(circle at 80% 70%, rgba(255,209,90,.16), transparent 55%),
        radial-gradient(circle at 30% 75%, rgba(255,79,185,.12), transparent 55%),
        radial-gradient(circle at 75% 25%, rgba(122,216,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.62), rgba(255,255,255,.36));
      border: 1px solid rgba(17,13,26,.08);
      box-shadow:
        0 18px 70px rgba(20,10,60,.10),
        0 6px 16px rgba(0,0,0,.06) inset;
      overflow:hidden;
      animation: boardFade 20s ease-in-out infinite;
      transition: filter 0.3s ease;
    }
    /* Dark Mode Board */
    body.dark #board{
      background:
        radial-gradient(circle at 20% 20%, rgba(60,50,90,.86), rgba(40,30,60,.35)),
        radial-gradient(circle at 80% 70%, rgba(100,80,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(40,35,60,.62), rgba(30,25,50,.36));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 70px rgba(0,0,0,.5), 0 6px 16px rgba(0,0,0,.3) inset;
    }
    @keyframes boardFade{
      0%{ filter:hue-rotate(0deg) saturate(1) }
      50%{ filter:hue-rotate(10deg) saturate(1.04) }
      100%{ filter:hue-rotate(0deg) saturate(1) }
    }

    /* Swirl overlay (statt bubble pattern) */
    #board:before{
      content:"";
      position:absolute; inset:-20px;
      background:
        conic-gradient(from 180deg at 35% 35%,
          rgba(255,255,255,.18),
          rgba(255,255,255,0) 22%,
          rgba(255,255,255,.12) 45%,
          rgba(255,255,255,0) 65%,
          rgba(255,255,255,.18)
        );
      opacity:.45;
      mix-blend-mode: soft-light;
      filter: blur(0.2px);
      pointer-events:none;
    }
    #board:after{
      content:"";
      position:absolute; inset:0;
      border-radius: var(--boardRadius);
      box-shadow:
        0 2px 0 rgba(255,255,255,.55) inset,
        0 -6px 12px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    #fxLayer{
      pointer-events:none;
      position:absolute;
      inset:0;
      z-index:20;
    }

    #fsBg{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      width: 0px;
      height: 0px;
      z-index:5; /* hinter board */
      pointer-events:none;
      overflow:hidden;
      display:none;
      border-radius: var(--boardRadius);
    }
    body.fs #fsBg{ display:block; }
    body.maximized #fsBg{ display:block; }

    /* Tiles */
    .tile{
      position:absolute;
      width: var(--cell);
      height: var(--cell);
      left:0; top:0;
      transform: translate(var(--x), var(--y));
      transition: transform 190ms cubic-bezier(.2,.9,.2,1.0);
      will-change: transform;
      z-index:15;
    }
    .tile.bigMellow{
      width: calc(var(--cell) * 2 + var(--gap));
      height: calc(var(--cell) * 2 + var(--gap));
      z-index:25;
    }
    .tile.dragging{ transition:none !important; z-index: 50; filter: drop-shadow(0 22px 20px rgba(0,0,0,.20)); }
    .tile.locked{ pointer-events:none; }

    .plate{
      width:100%; height:100%;
      border-radius: 16px;

      /* Jelly Tile Background (image only) + per-Luvvie pastel tint (background layers only) */
      background-image: var(--bg-img, url('Images/Button/Variant-A1.png'));
      /* Crop away PNG "frame/outline" by slightly oversizing the background (keeps tile size the same) */
      background-size: 118% 118%;
      background-position: center;
      background-repeat: no-repeat;

      /* tint only affects background layers (NOT the sprite image) */
      background-color: var(--p1, rgba(255,255,255,.0));
      background-blend-mode: hard-light;

      /* 3D depth without shrinking the tile */
      border: none;
      box-shadow:
        0 14px 22px rgba(0,0,0,.12),
        0 2px 0 rgba(255,255,255,.22) inset,
        0 -10px 16px rgba(0,0,0,.08) inset;

      position:relative;
      overflow:hidden;

      transform: translateY(var(--oy, 0px)) scale(1);
      opacity: var(--op, 1);
      transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease, filter 200ms ease;
    }

    /* Variant B specific styling */
    .tile[data-variant="B"] .plate{
      
      /* keep Variant B as jelly-only too (no extra border/backplate) */
      border: none;
      filter: none;
}

    .variantBadge{
      position:absolute;
      top:6px;
      left:6px;
      width:18px;
      height:18px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:11px;
      letter-spacing:.02em;
      color:#fff;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.72);
      box-shadow: 0 10px 16px rgba(0,0,0,.16);
      pointer-events:none;
      z-index:3;
      text-shadow: 0 1px 2px rgba(0,0,0,.22);
    }
    /* Enhance image contrast */
    .tile img {
       filter: drop-shadow(0 10px 14px rgba(0,0,0,.18)) drop-shadow(0 0 1px rgba(255,255,255,.60)) saturate(1.18) contrast(1.05);
    }
    .tile.bigMellow .plate{ border-radius: 26px; }

    /* Swirl on tile (subtle) */
    /* IMPORTANT: user wants ONLY the jelly tile visible (no extra swirl/backplate overlays) */
    .plate:before, .plate:after{ display:none !important; }

    
    .plate:before{
      content:"";
      position:absolute; inset:-18px;
      background:
        conic-gradient(from 120deg at 35% 35%,
          rgba(255,255,255,.18),
          rgba(255,255,255,0) 26%,
          rgba(255,255,255,.12) 54%,
          rgba(255,255,255,0) 72%,
          rgba(255,255,255,.18)
        );
      opacity:.35;
      mix-blend-mode: soft-light;
      pointer-events:none;
    }
    .plate:after{
      content:"";
      position:absolute; inset:0;
      border-radius:inherit;
      box-shadow:
        0 2px 0 rgba(255,255,255,.55) inset,
        0 -6px 12px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    /* Zilla attack warning */
    .attackWarn{
      position:absolute;
      background: rgba(255,0,0,.18);
      border: 2px dashed rgba(255,0,0,.65);
      border-radius: 10px;
      pointer-events:none;
      animation: attackPulse 0.8s ease-in-out infinite;
      box-shadow: 0 0 18px rgba(255,0,0,.35);
    }
    @keyframes attackPulse{
      0%{ opacity:.6; transform: scale(1); }
      50%{ opacity:1; transform: scale(1.03); }
      100%{ opacity:.6; transform: scale(1); }
    }

    /* Luvvies auf der Karte gr√∂√üer */
    .tile img{
      position:absolute;
      inset: 6%;
      width:88%;
      height:88%;
      object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.10));
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }
    .tile.bigMellow img{
      inset: 8%;
      width:84%;
      height:84%;
    }

    /* Question mark powerup visual */
    .qmark{
      display:none; /* Integrated in Powerup.png */
    }

    /* Animierter Power Background (f√ºr Powerups + ??? + Lovelie) */
    .powerAnim .plate{
      background-image: url('Images/Button/PowerUpButton.png') !important;
      background-color: transparent !important;
      background-blend-mode: normal !important;
      box-shadow: 0 0 22px rgba(255,79,185,.45), 0 0 32px rgba(122,216,255,.35);
      animation: powerPulse 1.8s ease-in-out infinite;
    }
    /* Mystery Tile specific */
    .tile[data-base="myst"] .plate {
       background-image: url('Images/Button/Powerup.png') !important;
    }
    @keyframes powerPulse{
      0%{ transform: scale(1); filter:saturate(1); }
      50%{ transform: scale(1.05); filter:saturate(1.2); }
      100%{ transform: scale(1); filter:saturate(1); }
    }
    /* Boss tint */
    .tile[data-base="mellowzilla"] .plate,
    .tile[data-base="koalazilla"] .plate{
      filter: hue-rotate(-12deg) saturate(1.2);
      box-shadow: 0 0 30px rgba(255,80,80,.45), 0 0 40px rgba(255,120,120,.35);
    }
    .tile[data-base="mellowzilla"] img,
    .tile[data-base="koalazilla"] img{
      inset: 0;
      width:100%;
      height:100%;
    }

    /* Puff reveal (??? -> random) */
    .tile.puff .plate{ animation: puff 520ms ease both; }
    @keyframes puff{
      0%{ transform: translateY(0) scale(1); filter: blur(0px); }
      40%{ transform: translateY(-2px) scale(1.12); filter: blur(0.2px); }
      100%{ transform: translateY(0) scale(1); filter: blur(0px); }
    }

    /* Pop */
    .pop .plate{ animation: popPlate 420ms ease-in both; }
    @keyframes popPlate{
      0%{ transform: translateY(0) scale(1); opacity:1; }
      55%{ transform: translateY(-2px) scale(1.14); opacity:1; }
      100%{ transform: translateY(8px) scale(.30); opacity:0; }
    }
    /* Jelly bump when combos resolve */
    .tile.bump .plate{ animation: jellyBump 540ms cubic-bezier(.18,.95,.2,1.05) both; }
    @keyframes jellyBump{
      0%{ transform: translateY(0) scale(1); }
      20%{ transform: translateY(-9px) scale(1.10, 0.90); }
      45%{ transform: translateY(6px) scale(0.92, 1.10); }
      70%{ transform: translateY(-4px) scale(1.05, 0.96); }
      100%{ transform: translateY(0) scale(1); }
    }

    /* Landing bounce - Jelly Style */
    .land .plate{ animation: landPlate 600ms linear both; }
    @keyframes landPlate{
      0% { transform: scale(1, 1) translateY(0); }
      30% { transform: scale(1.25, 0.75) translateY(10px); }
      40% { transform: scale(0.75, 1.25) translateY(-5px); }
      50% { transform: scale(1.15, 0.85) translateY(4px); }
      65% { transform: scale(0.95, 1.05) translateY(-2px); }
      75% { transform: scale(1.05, 0.95) translateY(1px); }
      100% { transform: scale(1, 1) translateY(0); }
    }

    /* Spawn glow */
    .spawnGlow .plate{ animation: spawnGlow 700ms ease-out both; }
    @keyframes spawnGlow{
      0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(.92); }
      55%{ filter: drop-shadow(0 0 20px rgba(255,255,255,.95)); transform: translateY(0) scale(1.05); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(1); }
    }

    /* Hint auff√§lliger */
    .tile.hint .plate{
      outline: 3px solid rgba(255,79,185,.85);
      box-shadow:
        0 0 0 5px rgba(122,216,255,.35),
        0 0 30px rgba(255,79,185,.28),
        0 18px 40px rgba(0,0,0,.12);
      animation: hintGlow 1.0s ease-in-out infinite;
    }
    @keyframes hintGlow{
      0%,100%{ filter: saturate(1) brightness(1); }
      50%{ filter: saturate(1.25) brightness(1.12); }
    }

    /* Mellow HP Zahl: kein Background, gr√∂√üer, fade */
    .hp{
      position:absolute;
      right:10px; top:8px;
      font-weight:1000;
      font-size: 18px;
      color: rgba(255,255,255,.98);
      text-shadow:
        0 10px 20px rgba(0,0,0,.18),
        0 2px 0 rgba(0,0,0,.12);
      z-index:30;
      background:none;
      border:none;
      box-shadow:none;
      padding:0;
      animation: hpFade 2.2s ease-in-out infinite;
      pointer-events:none;
    }
    .tile.bigMellow .hp{
      font-size: 22px;
      right:14px;
      top:12px;
    }
    @keyframes hpFade{
      0%,100%{ opacity:.60; transform: translateY(0); }
      50%{ opacity:1; transform: translateY(-1px); }
    }

    /* Below panels */
    .below{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:stretch;
      position:relative;
      z-index:6;
    }
    .below > .panel{height:100%}

    @media (max-width: 880px){
      .stats{grid-template-columns: repeat(2, minmax(0,1fr));}
      .below{grid-template-columns:1fr;}
      #boardWrap{min-height: 52vh;}
    }

    .panel{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      position:relative;
      z-index:6;
    }
    .panel h3{margin:0 0 10px;font-size:16px}

    .luvGrid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:10px}
    .luvCard{
      display:flex;gap:10px;align-items:center;
      padding:10px;border-radius:18px;
      background: rgba(255,255,255,.82);
      border:1px solid rgba(17,13,26,.08);
      box-shadow: 0 12px 26px rgba(20,10,60,.08);
      cursor:pointer;transition: transform .12s ease;
    }
    .luvCard:hover{ transform: translateY(-1px); }
    .luvCard img{
      width: 78px;height: 78px;object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.12));
      flex:0 0 auto;
    }
    .luvCard b{display:block}
    .luvCard small{opacity:.7;font-weight:900}

    #rightPanel{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 100%;
    }

    .lbRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .lbRow input{
      flex:1; min-width: 170px; height:44px;
      border-radius:14px; border:1px solid rgba(17,13,26,.12);
      padding:0 12px; font-weight:900; outline:none;
      background: rgba(255,255,255,.92);
    }

    /* Leaderboard scrollbar: aktiv, aber optisch clean */
    .lbList{
      display:flex;
      flex-direction:column; gap:8px;
      overflow:auto;
      padding-right:6px;
      flex:1;
      min-height: 260px;
      max-height: 65vh;
      border-radius: 16px;
      scrollbar-width: thin;
    }
    .lbList::-webkit-scrollbar{ width: 10px; }
    .lbList::-webkit-scrollbar-thumb{
      background: rgba(151,95,255,.35);
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.6);
    }
    .lbList::-webkit-scrollbar-track{
      background: rgba(255,255,255,.35);
      border-radius: 999px;
    }
    body.dark .lbList{
      background: rgba(20,18,32,.55);
    }
    body.dark .lbList::-webkit-scrollbar-thumb{
      background: rgba(210,190,255,.35);
      border: 3px solid rgba(32,28,46,.9);
    }
    body.dark .lbList::-webkit-scrollbar-track{
      background: rgba(32,28,46,.9);
    }

    .lbItem{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.95), rgba(245,245,255,.85));
      border:1px solid rgba(17,13,26,.06);
      border-radius:16px;
      padding:10px 10px;
      box-shadow: 0 10px 24px rgba(20,10,60,.07);
      opacity:1;
      transform:none;
      animation:none;
    }
    .lbItem .left b{display:block}
    .lbItem .left small{opacity:.7;font-weight:900}
    .lbItem .score{
      font-weight:1000;
      color:#4a2c6f;
    }
    body.dark .lbItem{
      background: linear-gradient(135deg, rgba(40,35,60,.92), rgba(32,28,50,.88));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
    }
    body.dark .lbItem .score{
      color:#e6ddff;
    }

    /* Ranks */
    .lbItem.rank1{
      background:linear-gradient(90deg, rgba(255,215,0,.20), rgba(255,255,255,.12));
      box-shadow:0 0 12px rgba(255,215,0,.45);
    }
    .lbItem.rank2{
      background:linear-gradient(90deg, rgba(192,192,192,.18), rgba(255,255,255,.10));
      box-shadow:0 0 10px rgba(220,220,220,.38);
    }
    .lbItem.rank3{
      background:linear-gradient(90deg, rgba(205,127,50,.18), rgba(255,255,255,.08));
      box-shadow:0 0 10px rgba(205,127,50,.35);
    }
    /* Non-podium entries: cooler lilac gradient */
    .lbItem:not(.rank1):not(.rank2):not(.rank3){
      background: linear-gradient(135deg, rgba(234, 231, 255, 0.92), rgba(220, 240, 255, 0.92));
      border:1px solid rgba(111, 80, 200, 0.18);
      box-shadow:
        0 14px 30px rgba(20,10,60,.10),
        0 0 0 1px rgba(255,255,255,.35) inset;
    }
    body.dark .lbItem.rank1{
      background:linear-gradient(90deg, rgba(255,215,0,.18), rgba(120,90,0,.20));
      box-shadow:0 0 10px rgba(255,215,0,.35);
    }
    body.dark .lbItem.rank2{
      background:linear-gradient(90deg, rgba(200,200,210,.18), rgba(70,70,90,.24));
      box-shadow:0 0 8px rgba(200,200,210,.32);
    }
    body.dark .lbItem.rank3{
      background:linear-gradient(90deg, rgba(205,127,50,.18), rgba(90,60,30,.22));
      box-shadow:0 0 8px rgba(205,127,50,.30);
    }
    body.dark .lbItem:not(.rank1):not(.rank2):not(.rank3){
      background: linear-gradient(135deg, rgba(52,46,82,0.96), rgba(46,44,70,0.92));
      border:1px solid rgba(255,255,255,.08);
      box-shadow:
        0 14px 30px rgba(0,0,0,.25),
        0 0 0 1px rgba(255,255,255,.06) inset;
    }
    @keyframes shine{
      0%{filter:brightness(1)}
      50%{filter:brightness(1.25)}
      100%{filter:brightness(1)}
    }
    @keyframes pulse{
      0%,100%{transform:scale(1)}
      50%{transform:scale(1.03)}
    }
    @keyframes bounceMedal{
      0%,100%{transform:translateY(0)}
      50%{transform:translateY(-2px)}
    }

    /* Toasts -> rechts seitlich (Desktop/Fullscreen), Mobile oben */
    #toast{
      position: fixed;
      right: 16px;
      top: 110px;
      z-index: 9999;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
      max-width: min(420px, 92vw);
    }
    @media (max-width: 560px){
      #toast{
        left: 50%;
        right: auto;
        top: 10%;
        transform: translateX(-50%);
        align-items:center;
      }
    }
    .toast{
      width: 100%;
      background: rgba(255,255,255,.92);
      border:1px solid rgba(17,13,26,.12);
      border-radius: 20px;
      padding: 12px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.15);
      font-weight:1000;
      text-align:left;
      animation: toastIn var(--toastMs) ease forwards;
    }
    .toast small{display:block;font-weight:900;opacity:.75;margin-top:3px}
    @keyframes toastIn{
      0%{opacity:0; transform: translateY(-10px) scale(.96)}
      16%{opacity:1; transform: translateY(0) scale(1)}
      86%{opacity:1}
      100%{opacity:0; transform: translateY(-10px) scale(.98)}
    }

    /* Modal */
    .modalBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(10,8,18,.55);
      z-index: 99998;
      padding: 18px;
    }
    .modal{
      width: min(760px, 96vw);
      max-height: min(82vh, 780px);
      overflow:auto;
      background: rgba(255,255,255,.96);
      border-radius: 24px;
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 28px 90px rgba(0,0,0,.25);
      padding: 14px 14px 12px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{font-weight:800; opacity:.9}
    .modal .foot{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      margin-top:12px;
    }
    .tiny{font-size:12px; opacity:.8; font-weight:900}

    /* Greeting */
    .greet{
      text-align:center;
      padding: 18px 14px 14px;
    }
    .greet input{
       width: 80%;
       max-width: 320px;
       margin: 10px auto;
       display:block;
       padding: 12px;
       border-radius: 12px;
       border: 1px solid rgba(17,13,26,.15);
       font-weight: 900;
       font-size: 16px;
       text-align:center;
       background: rgba(255,255,255,.9);
    }
    .greet img{
      width:min(380px, 82vw);
      height:auto;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,.14));
      margin: 4px auto 10px;
      display:block;
    }
    .greet h2{ margin: 6px 0 8px; }
    .greet .sub{
      font-weight:900;
      opacity:.8;
      margin: 0 auto 10px;
      max-width: 560px;
    }
    .greet .cta{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }

    /* Combo GIF Overlay (GIF only, no HTML particle spam) */
    .comboFx {
      position: absolute;
      width: 160px; height: 160px; /* JS will override per CELL */
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 999;
      background-position: center;
      background-size: contain;
      background-repeat: no-repeat;
      display: none; /* shown by JS */
      align-items: center;
      justify-content: center;
    }
    .comboFx.show{ display:flex; }

    /* Death GIF Overlay */
    .deathFx{
      position:absolute;
      width: 160px; height: 160px; /* JS will override */
      transform: translate(-50%, -50%);
      pointer-events:none;
      z-index: 998;
      background-position:center;
      background-size:contain;
      background-repeat:no-repeat;
      display:none;
    }
    .deathFx.show{ display:block; }
    .comboScore {
      font-size: 32px;
      font-weight: 900;
      color: #9d4edd;
      text-shadow: 0 0 10px #e0aaff, 2px 2px 0px #fff;
      animation: popScore 0.8s ease-out forwards;
      margin-top: -20px; /* Center it nicely over the burst */
    }
    @keyframes popScore {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1.0); opacity: 0; }
    }

    /* FX star */
    .star{
      position:absolute;
      left:0; top:0;
      width: 12px; height: 12px;
      transform: translate(-50%, -50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.2));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: starPop 820ms ease forwards;
      filter: drop-shadow(0 0 8px rgba(255,255,255,.8)); /* Brighter flash */
    }
    @keyframes starPop{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.4) rotate(0deg)}
      20%{opacity:1; transform:translate(-50%,-50%) scale(1) rotate(20deg)}
      100%{opacity:0; transform:translate(-50%,-75%) scale(.9) rotate(160deg)}
    }

    .ring{
      position:absolute; left:0; top:0;
      width: 10px; height: 10px;
      border-radius:999px;
      border: 3px solid rgba(255,255,255,.95);
      box-shadow: 0 0 30px rgba(255,79,185,.28);
      transform: translate(-50%,-50%) scale(.4);
      opacity:0;
      animation: ring 720ms ease-out forwards;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes ring{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.35)}
      15%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(4.2)}
    }

    /* Fullscreen */
    body.fs{ overflow:hidden; }
    body.fs #app{ width: min(1200px, 98vw); margin: 10px auto; }
    body.fs #boardWrap{
      min-height: 100vh;
      padding-top: 84px;
      padding-bottom: 12px;
    }

    /* FS HUD: left / center / right */
    #fsHud{
      position:absolute;
      left: 14px;
      right: 14px;
      top: 12px;
      z-index: 60;
      display:none;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    body.fs #fsHud{display:flex}

    .hudLeft, .hudCenter, .hudRight{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .hudCenter{
      justify-content:center;
      flex: 1;
      min-width: 240px;
    }

    .hudChip{
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      font-weight:1000;
      font-size: 13px;
      white-space:nowrap;
      pointer-events:none;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    @keyframes chipFade{
      0%,100%{ opacity:.92; }
      50%{ opacity:1; }
    }
    .hudChip.color{
      background: linear-gradient(135deg, rgba(255,79,185,.88), rgba(122,216,255,.86));
      color:#fff;
      border:1px solid rgba(255,255,255,.35);
      background-size: 200% 200%;
      animation: hudGlow 3.2s ease-in-out infinite;
      opacity:1;
    }
    @keyframes hudGlow{
      0%{ background-position: 0% 50%; }
      50%{ background-position: 100% 50%; }
      100%{ background-position: 0% 50%; }
    }

    .hudProg{
      pointer-events:none;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      min-width: min(520px, 70vw);
      justify-content:center;
    }
    .hudProg .pbar{
      flex:1;
      height: 12px;
      border-radius:999px;
      overflow:hidden;
      background: rgba(140,120,200,.18);
      border:1px solid rgba(60,20,120,.10);
      min-width: 160px;
    }
    .hudProg .pbar i{
      display:block;height:100%;width:0%;
      border-radius:999px;
      background: linear-gradient(90deg,#ff4fb9,#ffcf5a,#7ad8ff,#8b5cf6,#ff4fb9);
      background-size: 300% 100%;
      animation: barHue 3.2s linear infinite;
      transition: width .25s ease;
      box-shadow:0 0 18px rgba(255,79,185,.22);
    }

    .hudBtn{
      pointer-events:auto;
      height: 40px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(17,13,26,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 14px 34px rgba(0,0,0,.12);
      font-weight:1000;
      cursor:pointer;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    .hudBtn:hover{ animation: jello-horizontal .9s both; }

    /* Colored fullscreen buttons */
    .hudBtn.exit{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,130,130,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
    .hudBtn.guide{
      background: linear-gradient(135deg, rgba(90,170,255,.92), rgba(140,220,255,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
    .hudBtn.hint{
      background: linear-gradient(135deg, rgba(255,79,185,.92), rgba(255,170,230,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
      animation: pulseBtn 2s infinite;
    }
    @keyframes pulseBtn{
      0%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0.7); }
      70%{ transform:scale(1.05); box-shadow: 0 0 0 10px rgba(255,79,185, 0); }
      100%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0); }
    }

    /* Mobile/Tablet fullscreen layout */
    @media (max-width: 820px){
      body.fs #boardWrap{ padding-top: 2px; padding-bottom: 90px; min-height: 98vh; }
      #fsHud{
        top:auto;
        bottom: 10px;
        align-items:flex-end;
      }
      .hudProg{ min-width: min(520px, 92vw); }
      .hudBtn{ height:44px; padding:0 14px; }
    }
    @media (orientation: portrait) and (min-width: 600px){
      body.fs #boardWrap{ padding-top: 16px; padding-bottom: 110px; }
      .hudProg{ min-width: min(560px, 92vw); }
    }

    /* Better large screen FS */
    @media (min-width: 1600px) and (min-height: 900px){
       body.fs #boardWrap{ padding-top: 60px; padding-bottom: 40px; min-height: 100vh; }
       #scrollBg{ min-height: 150vh; }
    }
    @media (min-height: 1400px){
       body.fs #boardWrap{ min-height: 1500px; justify-content:center; }
    }
  

    /* Maximize HUD (shown in body.maximized) */
    #maxHud{
      display:none;
      position:fixed;
      left:50%;
      top:10px;
      transform: translateX(-50%);
      z-index:99998;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding:10px 12px;
      border-radius:18px;
      background: rgba(255,255,255,.86);
      border:1px solid rgba(17,13,26,.10);
      box-shadow: 0 16px 40px rgba(20,10,60,.10);
      backdrop-filter: blur(10px);
    }
    body.dark #maxHud{
      background: rgba(40,35,60,.86);
      border:1px solid rgba(255,255,255,.12);
    }
    body.maximized #maxHud{ display:flex; }

    #maxHud .pill{
      padding:8px 10px;
      border-radius:14px;
      background: rgba(255,255,255,.72);
      border:1px solid rgba(17,13,26,.08);
      font-weight:900;
      display:flex; gap:6px; align-items:center;
    }
    body.dark #maxHud .pill{
      background: rgba(30,26,45,.72);
      border:1px solid rgba(255,255,255,.10);
    }


    /* Luvvies cards: subtle per-character background to make them easier to recognize */
    .luvCard.hasPal{
      background:
        linear-gradient(145deg, rgba(255,255,255,.88), rgba(255,255,255,.70)),
        radial-gradient(circle at 20% 20%, var(--c1, #ffffff), transparent 55%),
        radial-gradient(circle at 80% 80%, var(--c2, #f2f3ff), transparent 60%);
    }
    body.dark .luvCard.hasPal{
      background:
        linear-gradient(145deg, rgba(40,35,60,.86), rgba(30,26,45,.80)),
        radial-gradient(circle at 20% 20%, color-mix(in srgb, var(--c1, #ffffff) 30%, transparent), transparent 60%),
        radial-gradient(circle at 80% 80%, color-mix(in srgb, var(--c2, #ffffff) 25%, transparent), transparent 65%);
      border:1px solid rgba(255,255,255,.10);
    }
</style>
</head>

<body>
  <div id="page">
    <div id="scrollBg"></div>
    <div id="globalBg"></div>
    <div id="darkOverlay"></div>
    <div id="toast"></div>

    <div class="modalBack" id="greetBack">
      <div class="modal greet">
        <img id="greetLogo" alt="Logo" />
        <h2>Willkommen bei Luvvies Crush üç≠</h2>
        <div class="sub">
          Match ‚Ä¢ Powerups ‚Ä¢ Mellow-Blocks ‚Ä¢ Lovelie-Bonus ‚ú®<br>
          Bounciger, weicher Candy-Style ‚Äì und jetzt mit richtigem Fullscreen-HUD.
        </div>
        <input id="greetName" placeholder="Dein Name" maxlength="24" />
        <div class="cta">
          <button class="Btn ghost" id="greetGuide">Anleitung</button>
          <button class="Btn secondary" id="greetPlay">Spielen</button>
        </div>
        <div class="tiny" style="margin-top:10px;">(Dieser Screen erscheint ca. alle 3 Stunden.)</div>
      </div>
    </div>

    <div class="modalBack" id="introBack">
      <div class="modal">
        <h2>Anleitung ‚Äì Luvvies Crush üç≠</h2>
        <ul>
          <li><b>Match 3+</b> gleiche Luvvies (gleiche Figur + gleiche Variant-Farbe).</li>
          <li><b>4er Match</b> ‚Üí <b>Sourworm</b> (Reihe/Spalte je nach Drag)</li>
          <li><b>5er Match</b> ‚Üí <b>Citrussy</b> (Stern Radius 3)</li>
          <li><b>T/L Match</b> ‚Üí <b>Koala</b> (Magie)</li>
          <li><b>Koala + Citrussy</b> ‚Üí 2√ó Board Clean & 2√ó Punkte!</li>
          <li><b>Wurm + Wurm</b> ‚Üí ‚ÄúZu sauer!‚Äù Welle</li>
          <li><b>2√ó Sleepy + 1√ó Mondlie</b> ‚Üí Shuffle <b>4√ó4</b> ‚ú®</li>
          <li><b>2√ó Joyce + 1√ó Smokey</b> ‚Üí Buddy Burst</li>
          <li><b>2√ó Smokey + 1√ó Simba</b> ‚Üí Best Buddy Wave (ab Lvl 4)</li>
          <li><b>Mellow</b> ab Level 3 (alle 4 Level), hat 3 HP ‚Ä¢ Clears daneben ziehen HP ab</li>
          <li><b>???</b> klicken ‚Üí <b>random</b> Powerup/Bonus/Block (mit Puff-Animation)</li>
          <li><b>Swap ohne Match</b> kostet <b>1 Move</b> (Live-Swap).</li>
          <li><b>Keine Z√ºge</b> ‚Üí Auto-Shuffle, ‚àí1 Move.</li>
        </ul>
        <div class="foot">
          <button class="Btn ghost" id="introClose">Schlie√üen</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="gameOverBack" style="z-index:99999;">
      <div class="modal" style="text-align:center;">
        <h2 style="font-size:32px;margin-bottom:4px;">GAME OVER üòµ</h2>
        <div class="sub" style="font-size:18px;margin-bottom:18px;">Keine Moves mehr m√∂glich!</div>

        <div class="stat" style="margin:0 auto 18px; max-width:200px;">
           <div class="k">Final Score</div>
           <div class="v" id="goScore">0</div>
        </div>

        <input id="goName" placeholder="Dein Name" maxlength="24" style="width:80%;max-width:320px;margin:0 auto 14px;display:block;padding:12px;border-radius:12px;border:1px solid rgba(17,13,26,.15);font-weight:900;font-size:16px;text-align:center;background:rgba(255,255,255,.9);" />

        <div class="cta" style="justify-content:center;gap:12px;">
           <button class="Btn" id="goPost">Score Posten</button>
           <button class="Btn secondary" id="goNew">Neues Spiel</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="infoBack">
      <div class="modal">
        <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
          <img id="infoImg" src="" alt=""
               style="width:172px;height:172px;object-fit:contain;filter:drop-shadow(0 18px 28px rgba(0,0,0,.18));">
          <div style="min-width:240px;">
            <h2 id="infoName" style="margin:0 0 6px">‚Äî</h2>
            <div class="tiny" id="infoTag">‚Äî</div>
            <div style="height:10px"></div>
            <div class="panel" style="padding:10px; border-radius:18px;">
              <b>Ability</b>
              <div id="infoAbility" style="margin-top:6px;font-weight:900;opacity:.9;">‚Äî</div>
            </div>
          </div>
        </div>

        <p id="infoStory" style="margin:12px 0 10px;font-weight:900;opacity:.9;">‚Äî</p>

        <div class="panel" style="padding:10px; border-radius:18px;">
          <b>3 Spr√ºche</b>
          <ul id="infoLines" style="margin:8px 0 0; padding-left:18px;"></ul>
        </div>

        <p class="tiny" style="margin:10px 0 0;">(Platzhalter) Sp√§ter: Plushie-Shop Link ‚ú®</p>
        <div class="foot">
          <button class="Btn ghost" id="infoClose">Schlie√üen</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="settingsBack">
      <div class="modal">
         <h2>Men√º</h2>

         <div class="panel" style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <b>FX Dimmer</b>
            <input type="range" id="fxSlider" min="0" max="100" value="0" style="flex:1">
         
            <button class="Btn ghost" id="menuHintQuick" style="height:40px;min-width:86px;">Hint</button>
         </div>

         <div class="cta" style="margin:16px 0; justify-content:center; gap:10px;">
            <button class="Btn secondary" id="menuNew">Neues Spiel</button>
            <button class="Btn ghost" id="menuIntro">Anleitung</button>
            <!-- Fullscreen handled via top bar -->
            <button class="Btn" id="menuHint">Hint</button>
         </div>

         <div class="panel">
            <h3>Deine Luvvies</h3>
            <div class="luvGrid" id="menuLuvGrid"></div>
         </div>
         <div class="foot"><button class="Btn ghost" id="menuClose">Schlie√üen</button></div>
      </div>
    </div>

    <div class="modalBack" id="fsMenuBack" style="z-index:99999;">
      <div class="modal">
         <h2>Pause</h2>
         <div class="tiny" style="margin-bottom:12px;">Fullscreen Men√º</div>

         <div class="panel" style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <b>FX Dimmer</b>
            <input type="range" id="fsMenuFx" min="0" max="100" value="0" style="flex:1">
         </div>

         <div class="panel" style="margin-bottom:12px;">
            <h3>Quick-Tipps</h3>
            <div class="tiny" id="fsMenuTips"></div>
         </div>

         <div class="cta" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
            <button class="Btn secondary" id="fsMenuClose">Weiter</button>
            <button class="Btn ghost" id="fsMenuIntro">Anleitung</button>
            <button class="Btn" id="fsMenuLuv">Luvvies</button>
            <button class="Btn" id="fsMenuTheme">üåô</button>
         </div>
         <div style="margin-top:12px; text-align:center;">
            <button class="Btn ghost" onclick="document.exitFullscreen()">Exit Fullscreen</button>
         </div>
      </div>
    </div>

    <div id="app">
      <div class="topRow">
        <img id="mainLogo" alt="Luvvies Crush" style="height:46px;width:auto;margin-right:12px;filter:drop-shadow(0 4px 6px rgba(0,0,0,.1));display:block;" />

        <div class="diffWrap">
          <div class="diffPills" id="diffPills">
            <input type="radio" name="diff" id="d_easy" value="easy" checked><label for="d_easy">Easy</label>
            <input type="radio" name="diff" id="d_normal" value="normal"><label for="d_normal">Normal</label>
            <input type="radio" name="diff" id="d_hard" value="hard"><label for="d_hard">Hard</label>
            <input type="radio" name="diff" id="d_shock" value="shock"><label for="d_shock">Zuckerschock</label>
          </div>
        </div>

        <div style="flex:1; min-width:10px;"></div>

        <div class="actions">
          <button class="Btn ghost" id="btnMax" title="Maximize Board">‚õ∂</button>
          <button class="Btn ghost" id="btnTheme" style="padding:0 12px;min-width:46px;">üåô</button>
          <button class="Btn ghost" id="btnHintTop" title="Hint (kostet 1 Move)">üí°</button>
          <button class="Btn" id="btnMenu">Men√º</button>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><div class="k">Level</div><div class="v" id="uiLevel">1</div></div>
        <div class="stat"><div class="k">Ziel</div><div class="v" id="uiGoal">4000</div></div>
        <div class="stat"><div class="k">Score</div><div class="v" id="uiScore">0</div></div>
        <div class="stat"><div class="k">Moves</div><div class="v" id="uiMoves">30</div></div>
        <div class="stat"><div class="k">Combo</div><div class="v" id="uiCombo">x1</div></div>
      </div>

      <div class="progressRow">
        <b>Fortschritt zum Ziel</b>
        <div class="bar"><i id="uiBar"></i></div>
        <div class="pct" id="uiPct">0%</div>
      </div>

      <div class="playArea" id="playArea">
        <div id="boardWrap">
          <div id="fsBg"></div>
          <div id="board"></div>
          <div id="fxLayer"></div>

          <div id="fsHud">
            <div class="hudLeft">
              <div class="hudChip color" id="hudLevel">Level 1</div>
              <div class="hudChip color" id="hudScore">Score 0</div>
              <div class="hudChip" id="hudMoves">Moves 0</div>
              <div class="hudChip" id="hudCombo">Combo x1</div>
            </div>

            <div class="hudCenter">
              <div class="hudProg">
                <div class="tiny" style="opacity:.85;">Ziel</div>
                <div class="pbar"><i id="hudBar"></i></div>
                <div class="tiny" id="hudPct" style="min-width:40px;text-align:right;">0%</div>
              </div>
            </div>

            <div class="hudRight">
              <button class="hudBtn hint" id="fsHint">Hint</button>
              <button class="hudBtn" id="fsMenuBtn">Men√º</button>
              <button class="hudBtn exit" id="fsExit">Exit</button>
            </div>
          </div>
        </div>
      </div>
        <!-- Maximize HUD: visible when board is maximized (so you still see score + can go back) -->
        <div id="maxHud">
          <button class="hudBtn exit" id="btnUnmax">Zur√ºck</button>
          <div class="pill"><b>Lvl</b> <span id="maxLvl">1</span></div>
          <div class="pill"><b>Score</b> <span id="maxScore">0</span></div>
          <div class="pill"><b>Moves</b> <span id="maxMoves">0</span></div>
          <div class="pill"><b>Combo</b> <span id="maxCombo">x1</span></div>
          <button class="hudBtn hint" id="maxHint">Hint</button>
        </div>


      <div class="below">
        <div class="panel" id="luvPanel">
          <h3>Deine Luvvies <span class="tiny">(anklicken f√ºr Steckbrief)</span></h3>
          <div class="luvGrid" id="luvMenu"></div>
          <div id="comboList" class="tiny" style="margin-top:6px;"></div>
        </div>

        <div class="panel" id="rightPanel">
          <div>
            <h3>Quick-Tipps</h3>
            <div class="tiny" id="quickTips"></div>
          </div>
          <div style="height:1px;background:rgba(17,13,26,.08);"></div>
          <div style="display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
               <h3 style="margin:0;" id="lbTitle">Leaderboard</h3>

               <!-- Leaderboard filter tabs (like the difficulty pills above) -->
               <div class="diffPills" id="lbTabs">
                 <input type="radio" name="lbDiff" id="lb_easy" value="easy" checked><label for="lb_easy">Easy</label>
                 <input type="radio" name="lbDiff" id="lb_normal" value="normal"><label for="lb_normal">Normal</label>
                 <input type="radio" name="lbDiff" id="lb_hard" value="hard"><label for="lb_hard">Hard</label>
                 <input type="radio" name="lbDiff" id="lb_shock" value="shock"><label for="lb_shock">Zuckerschock</label>
               </div>

               <!-- Keep select for compatibility, but hide it (tabs drive the selection) -->
               <select id="lbDiffSelect" style="display:none;">
                 <option value="easy">Easy</option>
                 <option value="normal">Normal</option>
                 <option value="hard">Hard</option>
                 <option value="shock">Zuckerschock</option>
               </select>
            </div>
            <div class="lbRow">
              <input id="lbName" maxlength="24" placeholder="Dein Name (z.B. KOALAaufPILLEN)" />
              <label class="tiny" style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" id="lbAuto" checked>
                Auto-Post bei Game Over
              </label>
            </div>
            <div class="lbRow">
              <button class="Btn secondary" id="btnPost">Score posten</button>
              <button class="Btn ghost" id="btnRefresh">Refresh</button>
            </div>
            <div class="lbList" id="lbList"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     * Helpers
     **********************/
    function fmt(n){ return Number(n||0).toLocaleString("de-DE"); }

    /**********************
     * Identity / Seasons
     **********************/
    function seasonStartIso(){
      // Rolling 90-day "season" (‚âà 3 months) so leaderboards stay fresh without hard resets
      return new Date(Date.now() - 90*24*60*60*1000).toISOString();
    }

    /**********************
     * Visual helpers (neutral tile backgrounds)
     * - Background is NOT tied to the character (avoids confusion)
     * - Still varied and candy-ish so tiles are readable
     **********************/
    const NEUTRAL_PALS = {
      A: ["#ff4fb9", "#7ad8ff"],      // knallig pink -> cyan
      B: ["#ffcf5a", "#8b5cf6"]       // knallig gelb -> violet
    };

    const SPECIAL_PALS = {
      worm: ["#ffe082", "#ff7043"],
      cit: ["#b2ff59", "#69f0ae"],
      koala: ["#a5b4fc", "#7c3aed"],
      mellow: ["#ffccbc", "#ff8a65"],
      lovelie: ["#ff9adf", "#ff4fb9"],
      myst: ["#d1c4e9", "#9575cd"],
      supernuss: ["#ffd740", "#ff8f00"]
    };
    // -------------------------
    // Tile background + tinting
    // -------------------------
    // We want each Luvvie (baseKey) to have a stable, UNIQUE pastel tint that CONTRASTS the character
    // (no "yellow on yellow"), and we want the board tile background to be the jelly image (no extra backplate).
    const TILE_TINT_CACHE = new Map();     // key -> [c1,c2]
    const USED_TINT_HUES = [];             // assigned hues to keep them unique

    function clamp(n,min,max){ return Math.min(max, Math.max(min,n)); }
    function hueDist(a,b){
      let d = Math.abs(a-b) % 360;
      return d > 180 ? 360 - d : d;
    }
    function hexToRgb(hex){
      if(!hex) return null;
      let h = (""+hex).trim().replace("#","");
      if(h.length===3) h = h.split("").map(x=>x+x).join("");
      if(h.length!==6) return null;
      const n = parseInt(h,16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0, s=0;
      const l=(max+min)/2;
      const d=max-min;
      if(d!==0){
        s = d / (1 - Math.abs(2*l - 1));
        switch(max){
          case r: h = ((g-b)/d) % 6; break;
          case g: h = (b-r)/d + 2; break;
          case b: h = (r-g)/d + 4; break;
        }
        h = (h*60+360) % 360;
      }
      return {h, s:s*100, l:l*100};
    }
    function hslToRgb(h,s,l){
      s/=100; l/=100;
      const c=(1-Math.abs(2*l-1))*s;
      const x=c*(1-Math.abs((h/60)%2 - 1));
      const m=l-c/2;
      let r=0,g=0,b=0;
      if(h<60){ r=c; g=x; b=0; }
      else if(h<120){ r=x; g=c; b=0; }
      else if(h<180){ r=0; g=c; b=x; }
      else if(h<240){ r=0; g=x; b=c; }
      else if(h<300){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      return { r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255) };
    }
    function rgbToHex(r,g,b){
      const to = (n)=>n.toString(16).padStart(2,"0");
      return "#"+to(r)+to(g)+to(b);
    }
    function pastelFromHue(h, isLightSprite){
      // pastel but with visible contrast
      const sat = 55;
      const l1 = isLightSprite ? 62 : 78;
      const l2 = isLightSprite ? 52 : 66;
      const c1 = hslToRgb(h, sat, l1);
      const c2 = hslToRgb(h, sat-8, l2);
      return [rgbToHex(c1.r,c1.g,c1.b), rgbToHex(c2.r,c2.g,c2.b)];
    }

    function deriveSpriteHueAndLight(baseKey){
      // Prefer explicit palettes from BASES (fast, stable, no async).
      const base = getBase(baseKey);
      const spec = getSpecial(baseKey);
      const meta = base || spec;
      const palA = meta?.palettes?.A;
      const palB = meta?.palettes?.B;
      const src = (palA && palA[0]) || (SPECIAL_PALS[baseKey] && SPECIAL_PALS[baseKey][0]) || (NEUTRAL_PALS.A[0]);
      const rgb = hexToRgb(src);
      const hsl = rgb ? rgbToHsl(rgb.r,rgb.g,rgb.b) : {h:210, l:60};
      return {h: hsl.h, l: hsl.l};
    }

    function uniqueHue(preferredHue){
      let h = (preferredHue%360+360)%360;
      // enforce uniqueness against already assigned hues
      for(let attempt=0; attempt<48; attempt++){
        const clash = USED_TINT_HUES.some(u => hueDist(u,h) < 18);
        if(!clash) { USED_TINT_HUES.push(h); return h; }
        h = (h + 29) % 360; // pseudo-golden-ish step
      }
      // fallback (should never happen)
      USED_TINT_HUES.push(h);
      return h;
    }

    function paletteForKey(baseKey, variant){
      const k = baseKey + ":" + (variant || "A");
      const cached = TILE_TINT_CACHE.get(k);
      if(cached) return cached;

      const {h: spriteHue, l: spriteLight} = deriveSpriteHueAndLight(baseKey);
      const isLightSprite = spriteLight >= 62;

      // prefer complementary hue
      const preferred = (spriteHue + 180) % 360;
      const h = uniqueHue(preferred);
      const pal = pastelFromHue(h, isLightSprite);

      TILE_TINT_CACHE.set(k, pal);
      return pal;
    }

    function hashStr(str){
      let h=2166136261>>>0;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h>>>0;
    }

        const BG_PICK_CACHE = new Map();

function tileBgFor(tile){
      const { baseKey, variant } = parseTypeId(tile?.type || "");
      const v = (variant || "A") === "B" ? "B" : "A";
      const list = (v === "B") ? (IMG.variantsB || []) : (IMG.variantsA || []);
      if(!list.length) return null;

      // Stable choice per (baseKey, variant) so identical Luvvies keep identical jelly backgrounds
      const k = (baseKey || (tile?.type||"")) + ":" + v;
      let idx = BG_PICK_CACHE.get(k);
      if(idx == null){
        idx = hashStr(k) % list.length;
        BG_PICK_CACHE.set(k, idx);
      }
      return list[idx];
    }


    // Color helpers (small + cached) to derive complementary gradients per character
    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||"");
      if(!m) return null;
      return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
    }
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h,s,l=(max+min)/2;
      if(max===min){ h=s=0; }
      else{
        const d=max-min;
        s=l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d+(g<b?6:0); break;
          case g: h=(b-r)/d+2; break;
          case b: h=(r-g)/d+4; break;
        }
        h/=6;
      }
      return {h,s,l};
    }
    function hslToHex(h,s,l){
      const hue2rgb=(p,q,t)=>{
        if(t<0) t+=1;
        if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3 - t)*6;
        return p;
      };
      let r,g,b;
      if(s===0){ r=g=b=l; }
      else{
        const q=l<0.5 ? l*(1+s) : l+s-l*s;
        const p=2*l-q;
        r=hue2rgb(p,q,h+1/3);
        g=hue2rgb(p,q,h);
        b=hue2rgb(p,q,h-1/3);
      }
      const toHex=(x)=>{
        const v=Math.round(x*255).toString(16).padStart(2,"0");
        return v;
      };
      return "#"+toHex(r)+toHex(g)+toHex(b);
    }
    function complementHex(hex){
      const rgb=hexToRgb(hex);
      if(!rgb) return null;
      const hsl=rgbToHsl(rgb.r,rgb.g,rgb.b);
      const nh=((hsl.h*360 + 160) % 360)/360;
      const ns=Math.min(1, hsl.s*0.9 + 0.05);
      const nl=Math.min(1, hsl.l*0.9 + 0.08);
      return hslToHex(nh, ns, nl);
    }

    function paletteForTile(tile){
      const { baseKey, variant } = parseTypeId(tile?.type || "");
      // Keep explicit special palettes where they matter visually (powerups etc.)
      if(SPECIAL_PALS[baseKey]) return SPECIAL_PALS[baseKey];
      // Unique, stable, contrast-first pastel tint for each (baseKey, variant)
      return paletteForKey(baseKey, (variant||"A")==="B" ? "B" : "A");
    }
/**********************
     * DOM safety: remove orphan tile elements (prevents rare "static tiles" you can't drag)
     **********************/
    function collectGridIds(){
      const ids = new Set();
      if(!isGridReady()) return ids;
      for(let r=0;r<rows;r++){
        const row = grid[r];
        if(!row) continue;
        for(let c=0;c<cols;c++){
          const t = row[c];
          if(t && t.id) ids.add(t.id);
        }
      }
      return ids;
    }
    function pruneOrphanTileEls(){
      const ids = collectGridIds();
      for(const [id, el] of tileEls.entries()){
        if(!ids.has(id)){
          try{ el.remove(); }catch(e){}
          tileEls.delete(id);
        }
      }
    }

    function diffLabel(k){
      const key = (k||"").toLowerCase();
      if(key==="shock" || key==="schock" || key==="zuschock" || key==="zuckerschock") return "Zuckerschock";
      if(key==="easy") return "Easy";
      if(key==="normal") return "Normal";
      if(key==="hard") return "Hard";
      return k || "";
    }

    /**********************
     * Supabase (intern)
     **********************/
    const SUPABASE_URL = "https://qgeddoqvzajpeawlythi.supabase.co";
    const SUPABASE_KEY_PUBLISHABLE = "sb_publishable_EQUOdDGiCGgm8vA3YjN_jg_BwPnAiI_";
    const SCORE_TABLE = "luvvies_crush_scores";

    let sb = null;
    try{
      if(window.supabase?.createClient){
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY_PUBLISHABLE, {
          auth: { persistSession:false, autoRefreshToken:false }
        });
      }
    }catch(e){ sb = null; }

    /**********************
     * Cookies (1x/day greeting)
     **********************/
    function getCookie(name){
      const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([$?*|{}\(\)\[\]\\\/\+^])/g,'\\$1') + '=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : "";
    }
    function setCookie(name, value, days=7){
      const maxAge = days * 24 * 60 * 60;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
    }
    const todayKey = ()=>new Date().toISOString().slice(0,10);

    /**********************
     * Difficulty
     **********************/
    const DIFFS = {
      easy:   { key:"easy",   name:"Easy",        rows:10, cols:10, scoreMult:1.00, baseMoves:30, movesPerLevel:2, baseTarget:3500, targetGrow:0.18, lovelieChance:0.006, mystChance:0.010 },
      normal: { key:"normal", name:"Normal",      rows: 9, cols: 9, scoreMult:1.25, baseMoves:26, movesPerLevel:2, baseTarget:4200, targetGrow:0.20, lovelieChance:0.005, mystChance:0.009 },
      hard:   { key:"hard",   name:"Hard",        rows: 9, cols: 8, scoreMult:1.60, baseMoves:24, movesPerLevel:1, baseTarget:5000, targetGrow:0.22, lovelieChance:0.004, mystChance:0.008 },
      shock:  { key:"shock",  name:"Zuckerschock",rows: 8, cols: 8, scoreMult:2.00, baseMoves:22, movesPerLevel:1, baseTarget:6500, targetGrow:0.24, lovelieChance:0.003, mystChance:0.007 }
    };
    let diff = DIFFS.easy;

    /**********************
     * Images (Local)
     **********************/
    const IMG = {
      logo:     "https://raw.githubusercontent.com/KOALAaufPILLEN/KOALAaufPILLEN.github.io/main/Luvvies/Luvvies-logo.png",
      sweety:   "Images/Luvvies/Sweety.png",
      sleepy:   "Images/Luvvies/Sleepy.png",
      normal:   "Images/Luvvies/Normalo.png",
      cry:      "Images/Luvvies/Cry.png",
      koala:    "Images/Luvvies/KOALA.png",
      citrussy: "Images/Luvvies/CItrussie.png",
      
      // Random Worms
      worm: "Images/Luvvies/Sourwurm-1.png", // Fallback
      sourwurm: ["Images/Luvvies/Sourwurm-1.png", "Images/Luvvies/Sourwurm-2.png", "Images/Luvvies/Sourwurm-3.png"],
      
      grumpy:   "Images/Luvvies/Grumpycookie.png",
      happy:    "Images/Luvvies/HappyCookie.png",
      mond:     "Images/Luvvies/Mondlie.png",
      donut:    "Images/Luvvies/Donutlie.png",
      joyce:    "Images/Luvvies/joyce.png",
      smokey:   "Images/Luvvies/Smokey.png",
      mellow:   "Images/Luvvies/mellow.png",
      lovelie:  "Images/Luvvies/lovvelie.png",
      simba:    "Images/Luvvies/Simba.png",
      mellowlord: "Images/Luvvies/MellowLord.png",
      
      // Boss Animations (Frame 1-4)
      mellowzilla: ["Images/Luvvies/Mellowzilla-1.png", "Images/Luvvies/MellowZilla-2.png", "Images/Luvvies/Mellowzilla-3.png", "Images/Luvvies/Mellowzilla-4.png"],
      koalazilla:  ["Images/Luvvies/KoalaZilla-1.png", "Images/Luvvies/KoalaZilla-2.png", "Images/Luvvies/KoalaZilla-3.png", "Images/Luvvies/KoalaZilla-4.png"],
      
      fledernuss: "Images/Luvvies/FlederNuss.png",
      flederheld: "Images/Luvvies/FlederHeld.png",
      supernuss: "Images/Luvvies/SuperNuss.png",
      giraffie: "Images/Luvvies/Giraffie.png",
      
      // Jelly Buttons (Variants)
      variantsA: ["Images/Button/Variant-A1.png", "Images/Button/Variant-A2.png", "Images/Button/Variant-A3.png", "Images/Button/Variant-A4.png"],
      variantsB: ["Images/Button/Variant-B1.png", "Images/Button/Variant-B2.png", "Images/Button/Variant-B3.png", "Images/Button/Variant-B4.png"],
      
      // Special Buttons
      powerBtn: "Images/Button/PowerUpButton.png",
      mystBtn: "Images/Button/Powerup.png", // Use as the tile itself for Mystery
      
      // Animations
      comboGif: "Images/Animation/Animation-combo.gif",
      deathGif: "Images/Animation/Deathanimation.gif"
    };
    document.getElementById("greetLogo").src = IMG.logo;
    const ml = document.getElementById("mainLogo");
    if(ml) ml.src = IMG.logo;

    /**********************
     * Mystery reveal weights (Wurm > Cit > Mellow > Koala > Lovelie)
     **********************/
    const MYST_POOL = [
      { key:"worm",   w: 40 },
      { key:"cit",    w: 25 },
      { key:"mellow", w: 16 },  // goldene mitte (zwischen cit und koala)
      { key:"koala",  w: 12 },
      { key:"lovelie",w:  7 }   // rare
    ];

    /**********************
     * Bases
     **********************/
    const BASES = [
      { key:"fledernuss", name:"Fledernuss", img:IMG.fledernuss, tag:"normal", minLevel:10,
        palettes:{ A:["#8d6e63","#a1887f"], B:["#a1887f","#bcaaa4"] },
        ability:"Evolves to FlederHeld",
        story:"Kleine Nuss mit gro√üen Tr√§umen.",
        lines:{
          easy:["Fledernuss!","Evolution?","Flatter!"],
          normal:["Ich wachse!","Next stage!","Nuss-Power!"],
          hard:["Schnell entwickeln!","Evolution!","Go!"],
          shock:["SUPER NUSS?!","EVOLUTION!","FLATTER!"]
        }
      },
      { key:"flederheld", name:"FlederHeld", img:IMG.flederheld, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#3e2723","#5d4037"], B:["#5d4037","#795548"] },
        ability:"Evolves to SuperNuss",
        story:"Der Held der N√ºsse.",
        lines:{ easy:["Held!"], normal:["Hero!"], hard:["Super!"], shock:["HYPER!"] }
      },
      { key:"supernuss", name:"SuperNuss", img:IMG.supernuss, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#ffab00","#ffd740"], B:["#ff6f00","#ff8f00"] },
        ability:"Explodes!",
        story:"Die ultimative Nuss.",
        lines:{ easy:["BOOM!"], normal:["SUPER!"], hard:["MEGA!"], shock:["ULTRA!"] }
      },
      { key:"sweety", name:"Sweety", img:IMG.sweety, tag:"normal",
        palettes:{ A:["#f8bbd0","#f48fb1"], B:["#f48fb1","#ec407a"] },
        ability:"Glitzer-Queen: cleanes Match 3+.",
        story:"Sweety liebt Kettenreaktionen ‚Äì je mehr es bounct, desto besser.",
        lines:{
          easy:["Zucker-Boom! ‚ú®","Glitzer time!","Noch ein Match! üíñ"],
          normal:["Sauberer Swap üòå","Combo? Ich seh‚Äôs!","Keep the vibe ‚ú®"],
          hard:["No panic ‚Äî precision.","Du bist fast da.","Tight! üòà"],
          shock:["ZUCKERSCHOCK!","Mehr Chaos!","Ich will Ketten! üî•"]
        }
      },
      { key:"sleepy", name:"Sleepy", img:IMG.sleepy, tag:"normal",
        palettes:{ A:["#e3f2fd","#bbdefb"], B:["#bbdefb","#90caf9"] },
        ability:"2√ó Sleepy + 1√ó Mondlie ‚Üí Shuffle 4√ó4 ‚ú®",
        story:"Wirkt m√ºde‚Ä¶ aber sein Shuffle ist brutal effektiv.",
        lines:{
          easy:["Zzz‚Ä¶ aber ok üò¥","Sanfter Swap‚Ä¶","Wach f√ºr Combo!"],
          normal:["Nicht einschlafen.","Smooth & bouncy.","Weiter‚Ä¶ ‚ú®"],
          hard:["Timing ist alles.","Kein Tilt.","Mach‚Äôs clean."],
          shock:["ICH BIN WACH!","Shuffle oder RIP.","Mehr! üòà"]
        }
      },
      { key:"normal", name:"Normal", img:IMG.normal, tag:"normal",
        palettes:{ A:["#f3e5f5","#e1bee7"], B:["#ce93d8","#ba68c8"] },
        ability:"Klassiker: stabiler Tile f√ºr sichere Lines.",
        story:"Normal ist der Anker ‚Äì wenn‚Äôs brennt, rettet er dein Board.",
        lines:{
          easy:["Easy going.","Alles chill.","Noch eins!"],
          normal:["Stabil.","Rund.","Passt."],
          hard:["Disziplin.","Konsequent.","Kein Fehler."],
          shock:["Ich bleib ruhig.","Pr√§zise.","Durchziehen."]
        }
      },
      { key:"cry", name:"Cry", img:IMG.cry, tag:"normal",
        palettes:{ A:["#e0f2f1","#b2dfdb"], B:["#80cbc4","#4db6ac"] },
        ability:"Emo-Boost: f√ºhlt jede Chain-Reaction.",
        story:"Cry weint‚Ä¶ aber nur weil‚Äôs so sch√∂n glitzert.",
        lines:{
          easy:["üò≠‚ú® so sch√∂n","Bitte noch ein Match","Ich f√ºhl das!"],
          normal:["Combo macht happy.","Nicht aufgeben.","Weiter!"],
          hard:["Tough love.","Du packst das.","Sauber bleiben."],
          shock:["AAAA üò≠","Nur noch Kette!","Chaos is love."]
        }
      },
      { key:"happy", name:"Happy Cookie", img:IMG.happy, tag:"normal",
        palettes:{ A:["#fff3e0","#ffe0b2"], B:["#ffcc80","#ffb74d"] },
        ability:"Therapy Time (2√ó Grumpy + 1√ó Happy) ‚Üí +3 Moves, Grumpy‚ÜíHappy.",
        story:"Happy macht selbst Grumpy weich. üç™‚ú®",
        lines:{
          easy:["Smile! üç™","Alles wird gut!","S√º√ü & stark!"],
          normal:["Therapy incoming.","Du schaffst das.","Nice chain!"],
          hard:["Atmen. Fokus.","Guter Move.","Keep going."],
          shock:["HAPPY RAGE üòà","Wir gewinnen!","Mehr Moves!!"]
        }
      },
      { key:"grumpy", name:"Grumpy Cookie", img:IMG.grumpy, tag:"normal",
        palettes:{ A:["#ffebee","#ffcdd2"], B:["#ef9a9a","#e57373"] },
        ability:"Therapy Time (2√ó Grumpy + 1√ó Happy).",
        story:"Grumpy sagt 'nein'‚Ä¶ aber liebt +Moves heimlich.",
        lines:{
          easy:["Hmpf.","Mach schneller.","Ok‚Ä¶"],
          normal:["Weniger Fehler.","Konzentrier dich.","Weiter."],
          hard:["Sauber oder raus.","Nicht tilten.","Knapp!"],
          shock:["Zuckerschock?!","Du bist verr√ºckt.","‚Ä¶gef√§llt mir."]
        }
      },
      { key:"mond", name:"Mondlie", img:IMG.mond, tag:"normal",
        palettes:{ A:["#ede7f6","#d1c4e9"], B:["#b39ddb","#9575cd"] },
        ability:"2√ó Sleepy + 1√ó Mondlie ‚Üí Shuffle 4√ó4 ‚ú®",
        story:"Mondlie ist selten ruhig‚Ä¶ sein Shuffle ist Nachtmagie.",
        lines:{
          easy:["üåô leise‚Ä¶","Moon vibes.","Shuffle? üò¥"],
          normal:["Nacht-Combo.","Elegant.","Weiter."],
          hard:["Kein Risiko.","Nur Timing.","Mond-Plan."],
          shock:["NACHTCHAOS üòà","Alles mischen!","Mehr!"]
        }
      },
      { key:"donut", name:"Donutlie", img:IMG.donut, tag:"normal",
        palettes:{ A:["#fce4ec","#f8bbd0"], B:["#f48fb1","#f06292"] },
        ability:"2√ó Donut + Sweety ‚Üí Sprinkle Beam ‚Ä¢ 2√ó Donut + Happy ‚Üí Sugar Rush.",
        story:"Wenn Donut kommt, wird‚Äôs zuckrig gef√§hrlich. üç©",
        lines:{
          easy:["Sprinkles! ‚ú®","Mehr Donuts!","S√º√ües Chaos!"],
          normal:["Beam ready.","Zucker-Schub!","Let‚Äôs go!"],
          hard:["Timing!","Nicht verschwenden.","Power!"],
          shock:["OVERLOAD!","LASER üç©","MEHR!!!"]
        }
      },
      { key:"joyce", name:"Joyce Podenko", img:IMG.joyce, tag:"normal",
        palettes:{ A:["#efebe9","#d7ccc8"], B:["#bcaaa4","#a1887f"] },
        ability:"2√ó Joyce + 1√ó Smokey (oder umgekehrt) ‚Üí Buddy Burst.",
        story:"Joyce ist loyal ‚Äì wenn Smokey da ist, z√ºndet‚Äôs richtig.",
        lines:{
          easy:["Wuff! üêæ","Guter Swap!","Ich helf!"],
          normal:["Buddy time!","Ich bin dabei!","Nice!"],
          hard:["Wir schaffen‚Äôs.","Bleib dran.","Clean!"],
          shock:["WUFF ZUCKER!","Vollgas!","No fear!"]
        }
      },
      { key:"smokey", name:"Smokey", img:IMG.smokey, tag:"normal",
        palettes:{ A:["#f5f5f5","#e0e0e0"], B:["#bdbdbd","#9e9e9e"] },
        ability:"2√ó Smokey + 1√ó Joyce (oder umgekehrt) ‚Üí Buddy Burst.",
        story:"Smokey ist Boss-Katze ‚Äì und Boss-Katzen r√§umen auf.",
        lines:{
          easy:["Miau.","Ok.","Weiter."],
          normal:["Nicht schlecht.","Hmm.","Passt."],
          hard:["Ich bewerte dich.","Konsequent.","Sauber."],
          shock:["miau‚Ä¶ RESPEKT.","Heftig.","No mercy."]
        }
      },
      { key:"simba", name:"Simba", img:IMG.simba, tag:"normal", minLevel:4,
        palettes:{ A:["#fff8e1","#ffecb3"], B:["#ffe0b2","#ffcc80"] },
        ability:"Best Buddies: 2√ó Smokey + 1√ó Simba (oder umgekehrt) ‚Üí Buddy Wave ‚ú®",
        story:"Simba ist mutig und liebt Smokey ‚Äì zusammen sind sie unaufhaltbar.",
        lines:{
          easy:["Roar! ü¶Å","Best Buddies!","Wir schaffen‚Äôs!"],
          normal:["Starker Move!","Buddy Power!","Nice!"],
          hard:["Fokus.","Clean.","Weiter so."],
          shock:["ROAR SCHOCK!","Buddy Chaos!","No Mercy!"]
        }
      }
    ];

    const SPECIALS = {
      worm:   { key:"worm",   name:"Sourworm", img:IMG.worm, tag:"powerup" },
      cit:    { key:"cit",    name:"Citrussy", img:IMG.citrussy, tag:"powerup" },
      koala:  { key:"koala",  name:"Koala", img:IMG.koala, tag:"powerup" },
      mellow: { key:"mellow", name:"Mellow", img:IMG.mellow, tag:"obstacle" },
      lovelie:{ key:"lovelie",name:"Lovelie", img:IMG.lovelie, tag:"bonus" },
      myst:   { key:"myst",   name:"???", img:null, tag:"powerup" }
    };

    /**********************
     * Variant unlock
     **********************/
    let unlocked = {};
    function resetUnlocked(){
      unlocked = {};
      for(const b of BASES) unlocked[b.key] = new Set(["A"]);
    }
    function maybeUnlockVariant(){
      if(level < 5) return;
      if(level % 5 !== 0) return;
      const candidates = BASES.filter(b => !unlocked[b.key].has("B"));
      if(!candidates.length) return;
      const pick = candidates[Math.floor(Math.random()*candidates.length)];
      unlocked[pick.key].add("B");
      toast(`Neue Variante üé®`, `${pick.name} hat jetzt auch Farbe B ‚ú®`, 3200);
    }

    /**********************
     * State
     **********************/
    let rows=10, cols=10;
    let grid = [];
    let tileEls = new Map();
    let busy = false;
    // big mellow mapping
    const bigMellows = new Map();
    // id -> {id, r, c, hp, type}


    let lastZillaType = null; // used to alternate KoalaZilla/MellowZilla
    let bossFight = null; // { active:true, type:'mellowzilla'|'koalazilla', hp:number, spawnLevel:number, deadlineLevel:number }
    let zillaPlanned = null;
    let zillaAttackCounter = 0;
    let pointer = {down:false, id:null, startX:0, startY:0};
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let target = 4000;
    let moves = 30;
    let mellowFreeMoves = 10;
    let lastPlayerMove = null;
    let combo = 1;

    let lastSwap = null;

    // Auto-post guard (prevents multiple auto-posts for the same game over)
    let autoPostDone = false;

    // cached sizing
    let CELL = 54;
    let GAP = 8;
    let PAD = 14;

    function isGridReady(){
      return Array.isArray(grid) && rows>0 && cols>0 && grid.length >= rows;
    }

    function currentPad(){
      return (document.body.classList.contains("fs") || document.body.classList.contains("maximized")) ? 10 : PAD;
    }

    /**********************
     * UI refs
     **********************/
    const ui = {
      level: document.getElementById("uiLevel"),
      goal:  document.getElementById("uiGoal"),
      score: document.getElementById("uiScore"),
      moves: document.getElementById("uiMoves"),
      combo: document.getElementById("uiCombo"),
      bar:   document.getElementById("uiBar"),
      pct:   document.getElementById("uiPct"),
      board: document.getElementById("board"),
      fx:    document.getElementById("fxLayer"),
      menu:  document.getElementById("luvMenu"),
      tips:  document.getElementById("quickTips"),
      hudLevel: document.getElementById("hudLevel"),
      hudScore: document.getElementById("hudScore"),
      hudMoves: document.getElementById("hudMoves"),
      hudCombo: document.getElementById("hudCombo"),
      hudBar:   document.getElementById("hudBar"),
      hudPct:   document.getElementById("hudPct"),
    };

    /**********************
     * Helpers
     **********************/
    // duplicate clamp removed (function clamp is defined earlier)
    const posKey=(r,c)=>`${r},${c}`;
    function toast(title, subtitle="", ms=2600){
      document.documentElement.style.setProperty("--toastMs", ms+"ms");
      const wrap = document.getElementById("toast");
      const t = document.createElement("div");
      t.className="toast";
      t.innerHTML = `${title}${subtitle?`<small>${subtitle}</small>`:""}`;
      wrap.appendChild(t);
      setTimeout(()=>t.remove(), ms);
    }

    function typeId(baseKey, variant){ return `${baseKey}:${variant}`; }
    function parseTypeId(id){
      if(!id) return {baseKey:"", variant:"P"};
      if(!id.includes(":")) return {baseKey:id, variant:"P"};
      const [baseKey, variant] = id.split(":");
      return {baseKey, variant};
    }
    const matchKey = (tile)=>{
      const p = parseTypeId(tile?.type);
      return `${p.baseKey}:${p.variant||"A"}`;
    };

    /**********************
     * Combo unlock tracking (simple cookie-based log)
     **********************/
    const COMBOS = {
      moonshuffle: { title:"Sleepy √ó Mond Shuffle", desc:"2√ó Sleepy + 1√ó Mond ‚Üí Shuffle 4√ó4" },
      therapy: { title:"Grumpy Therapy", desc:"3√ó Grumpy + 1√ó Happy ‚Üí +3 Moves & Calm" },
      sprinkle: { title:"Donut Sprinkle", desc:"3√ó Donut + 1√ó Sweety ‚Üí Sprinkle Beam" },
      sugar: { title:"Donut Sugar Rush", desc:"3√ó Donut + 1√ó Happy ‚Üí Sugar Rush" },
      buddies: { title:"Buddy Burst", desc:"Joyce/Smokey/Simba + Buddies ‚Üí Wave" },
      powercombo: { title:"Power Combo", desc:"Any powerup + powerup fusion" },
      simba_mix: { title:"Simba Variant Mix", desc:"3√ó Simba A + 1√ó Simba B ‚Üí clear Simbas" }
    };
    function loadComboCookie(){
      try{
        const raw = getCookie("luvvies_combos");
        if(!raw) return new Set();
        return new Set(JSON.parse(raw));
      }catch(e){ return new Set(); }
    }
    let combosUnlocked = loadComboCookie();
    function saveCombos(){
      try{ setCookie("luvvies_combos", JSON.stringify([...combosUnlocked]), 3650); }catch(e){}
    }
    function renderCombos(){
      const box = document.getElementById("comboList");
      if(!box) return;
      const keys = Object.keys(COMBOS);
      const unlocked = keys.filter(k=>combosUnlocked.has(k));
      const lockedCount = keys.length - unlocked.length;
      const lines = [
        unlocked.length ? `Freigeschaltet: ${unlocked.map(k=>COMBOS[k].title).join(", ")}` : "Freigeschaltet: ‚Äî",
        lockedCount > 0 ? `Versteckt: ${lockedCount} Kombos (??? probieren!)` : "Alle Kombos gefunden!"
      ];
      box.innerHTML = lines.map(l=>`<div class="tiny">${l}</div>`).join("");
    }
    function unlockCombo(key){
      if(!COMBOS[key]) return;
      if(combosUnlocked.has(key)) return;
      combosUnlocked.add(key);
      saveCombos();
      toast("Neue Kombo!", COMBOS[key].title, 2600);
      renderCombos();
    }
    function getBase(baseKey){ return BASES.find(b=>b.key===baseKey) || null; }
    function getSpecial(baseKey){ return SPECIALS[baseKey] || null; }
    function inBounds(r,c){ return r>=0 && c>=0 && r<rows && c<cols; }

    function isPowerupKey(k){ return k==="worm" || k==="cit" || k==="koala"; }

    function isPlaceholder(t){ return t && t.type==="mellow_part"; }
    function isBlocker(t){
      if(!t) return false;
      const bk = parseTypeId(t.type).baseKey;
      // Small mellow is NO LONGER a blocker (so it falls/swaps)
      if(bk==="mellowlord" || bk==="mellowzilla" || bk==="koalazilla") return true;
      if(isPlaceholder(t)) return true;
      return false;
    }

    function isSwappable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(baseKey==="myst") return false; // ??? nur klicken
      return true;
    }
    function isMatchable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(getSpecial(baseKey)) return false;
      return true;
    }

    function calcTarget(lv){
      return Math.round(diff.baseTarget * (1 + (lv-1)*diff.targetGrow));
    }
    function calcMoves(lv){
      const m = diff.baseMoves + (lv-1)*diff.movesPerLevel;
      // Cap max moves to avoid accumulating too many (e.g. 70 moves at lvl 39 is too much)
      // Cap at 25 extra moves max (so base + 25)
      const cap = diff.baseMoves + 25;
      return Math.min(m, cap);
    }
    function scorePerTile(){ return Math.round(60 * diff.scoreMult); }

    function clearHints(){
      for(const el of tileEls.values()) el.classList.remove("hint");
    }

    /**********************
     * FX helpers
     **********************/
    function tileCenter(r,c){
      // Use getBoundingClientRect to map board cell to FX layer space
      // Find a tile at this pos, or calculate where it would be
      // If tile exists, use it. If not, use slot calc.
      // But calculating slot position relative to boardWrap is tricky if board is centered.
      // Best way: Use the 'board' element rect.
      const boardRect = ui.board.getBoundingClientRect();
      const fxRect = ui.fx.getBoundingClientRect();

      const localX = PAD + c*(CELL+GAP) + CELL/2;
      const localY = PAD + r*(CELL+GAP) + CELL/2;

      // Board Pos relative to FX layer
      const boardX = boardRect.left - fxRect.left;
      const boardY = boardRect.top - fxRect.top;

      return { x: boardX + localX, y: boardY + localY };
    }
    // GIF-only FX mode (performance): disable HTML particle spam for combos
    const FX_GIF_ONLY = true;


    function makeStar(x,y, big=false){
      if(FX_GIF_ONLY) return;

      const s = document.createElement("div");
      s.className="star";
      s.style.left = x+"px";
      s.style.top  = y+"px";

      // Random size for "unique peng"
      const size = big ? (20 + Math.random()*12) : (10 + Math.random()*8);
      s.style.width = size+"px";
      s.style.height= size+"px";

      // Fully random pastel color
      const h = Math.floor(Math.random()*360);
      const sat = 70 + Math.random()*30;
      const light = 70 + Math.random()*20;

      s.style.background = `radial-gradient(circle at 30% 30%, hsl(${h}, ${sat}%, ${light+10}%), hsl(${h}, ${sat}%, ${light-10}%))`;
      // Random rotation
      s.style.transform = `translate(-50%, -50%) rotate(${Math.random()*360}deg)`;

      ui.fx.appendChild(s);
      setTimeout(()=>s.remove(), 900);
    }
    function ringFx(x,y){
      if(FX_GIF_ONLY) return;

      const r=document.createElement("div");
      r.className="ring";
      r.style.left=x+"px"; r.style.top=y+"px";
      ui.fx.appendChild(r);
      setTimeout(()=>r.remove(), 760);
    }
    function burstFx(x,y, count=12){
      if(FX_GIF_ONLY) return;

      ringFx(x,y);
      for(let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const dist = 10 + Math.random()*40;
        makeStar(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist, Math.random()<0.4);
      }
    }

    function showComboAnim(score, r, c){
       // Pool overlays so we can show the GIF on multiple disappearing tiles at once
       if(!ui._comboPool){
         ui._comboPool = [];
         ui._comboPoolIdx = 0;
       }

       // create a few upfront, grow if needed
       const MIN_POOL = 18;
       while(ui._comboPool.length < MIN_POOL){
         const fx = document.createElement("div");
         fx.className = "comboFx";
         const txtEl = document.createElement("div");
         txtEl.className = "comboScore";
         fx.appendChild(txtEl);
         ui.fx.appendChild(fx);
         ui._comboPool.push({ fx, txtEl, timer: 0 });
       }

       const entry = ui._comboPool[ui._comboPoolIdx++ % ui._comboPool.length];
       const fx = entry.fx;
       const txtEl = entry.txtEl;

       // Sizing: scale with CELL, but clamp
       const size = Math.max(64, Math.min(220, Math.floor(CELL * 1.12)));
       fx.style.width = size + "px";
       fx.style.height = size + "px";

       // Score text scaling: never larger than the GIF
       if(score != null){
         txtEl.textContent = "+" + score;
         txtEl.style.display = "block";
         const s = Math.min(1.0, size / 160);
         txtEl.style.transform = `translate(-50%, -50%) scale(${s})`;
       }else{
         txtEl.style.display = "none";
       }

       // GIF background (cached per element)
       const gifUrl = IMG.comboGif || "Images/Animation/Animation-combo.gif";
       if(fx.dataset.gif !== gifUrl){
         fx.style.backgroundImage = "url('" + gifUrl + "')";
         fx.dataset.gif = gifUrl;
       }

       const {x,y} = tileCenter(r,c);
       fx.style.left = x + "px";
       fx.style.top  = y + "px";

       fx.classList.add("show");

       clearTimeout(entry.timer);
       entry.timer = setTimeout(()=>{
         fx.classList.remove("show");
       }, 950);
    }



    function showDeathAnim(r, c){
       if(!ui._deathFx){
         const fx = document.createElement("div");
         fx.className = "deathFx";
         ui.fx.appendChild(fx);
         ui._deathFx = fx;
         ui._deathFxTimer = 0;
       }
       const fx = ui._deathFx;

       const size = Math.round(Math.min(220, Math.max(120, CELL * 1.85)));
       fx.style.width  = size + "px";
       fx.style.height = size + "px";

       const gifUrl = IMG.deathGif + "?t=" + Date.now();
       fx.style.backgroundImage = "url('" + gifUrl + "')";

       const {x,y} = tileCenter(r,c);
       fx.style.left = x + "px";
       fx.style.top  = y + "px";

       fx.classList.add("show");
       clearTimeout(ui._deathFxTimer);
       ui._deathFxTimer = setTimeout(()=>{
         fx.classList.remove("show");
       }, 1100);
    }


    /**********************
     * Responsive sizing
     **********************/
    function computeCell(){
      const wrap = document.getElementById("boardWrap");
      const rect = wrap.getBoundingClientRect();
      const wrapW = wrap.clientWidth;

      const isFs = document.body.classList.contains("fs");
      const isMax = document.body.classList.contains("maximized");

      // Margins/Padding
      const pad = currentPad();
      const padW = (isFs||isMax) ? 12 : 20;
      // Vertical padding: allow HUD room but maximize board real estate; smaller boards get slightly less padding
      const padHBase = (isFs) ? 110 : (isMax ? 80 : 40);
      const padH = Math.max(40, padHBase - Math.max(0, (10 - rows) * 4));

      // Remaining height: viewport minus current top + small footer reserve
      const footerReserve = isFs ? 16 : 32; // taskbar/margin
      const availH = Math.max(260, window.innerHeight - Math.max(0, rect.top) - footerReserve);

      const usableW = Math.max(320, wrapW - padW);
      const usableH = Math.max(320, availH - padH);

      const cellW = Math.floor((usableW - (cols-1)*GAP - pad*2) / cols);
      const cellH = Math.floor((usableH - (rows-1)*GAP - pad*2) / rows);

      // Only scale downward; never upscale past the preferred base size (adapt to grid density)
      const preferred = clamp(84 - Math.max(0, rows-8)*2 - Math.max(0, cols-8)*1.5, 70, 96);
      const minCell = (window.innerWidth < 640) ? 46 : 54;
      const target = Math.min(Math.min(cellW, cellH), preferred);
      return clamp(Math.round(target), minCell, preferred);
    }

    function setTileXY(el, r, c){
      const pad = currentPad();
      const x = c*(CELL+GAP) + pad;
      const y = r*(CELL+GAP) + pad;
      el.style.setProperty("--x", x+"px");
      el.style.setProperty("--y", y+"px");
    }

    function layoutBoard(){
      CELL = computeCell();
      const pad = currentPad();
      document.documentElement.style.setProperty("--cell", CELL+"px");
      document.documentElement.style.setProperty("--gap", GAP+"px");
      document.documentElement.style.setProperty("--pad", pad+"px");
      document.documentElement.style.setProperty("--cols", cols);
      document.documentElement.style.setProperty("--rows", rows);

      const w = pad*2 + cols*CELL + (cols-1)*GAP;
      const h = pad*2 + rows*CELL + (rows-1)*GAP;
      ui.board.style.width = w+"px";
      ui.board.style.height = h+"px";

      

      // KOALA_LAYOUT_SYNC_FSBG: Fullscreen/Maximize BG exakt an Board-Gr√∂√üe anpassen
      try{
        if(ui && ui.fsBg){
          ui.fsBg.style.width = w+"px";
          ui.fsBg.style.height = h+"px";
        }
      }catch(e){}
for(const [id, el] of tileEls){
        const tile = findTileById(id);
        if(!tile) continue;
        setTileXY(el, tile.r, tile.c);
      }

      syncLbHeight();
    
      // Remove any leftover tile DOM nodes that are no longer in the grid
      pruneOrphanTileEls();
}

    let ro=null;
    let resizeTimer;
    function attachResize(){
      const handler = () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{
           layoutBoard();
           syncBgHeight();
           buildGlobalBg();
           buildFsBg();
        }, 150);
      };

      try{
        ro = new ResizeObserver(handler);
        ro.observe(document.getElementById("boardWrap"));
      }catch(e){
        window.addEventListener("resize", handler);
      }
      window.addEventListener("resize", handler);
      document.getElementById("page").addEventListener("scroll", syncBgHeight, {passive:true});
    }

    function syncBgHeight(){
      const page = document.getElementById("page");
      const h = Math.max(page.scrollHeight, window.innerHeight);
      document.getElementById("scrollBg").style.height = h + "px";
      document.getElementById("globalBg").style.height = h + "px";
    }

    /**********************
     * Tile DOM
     **********************/
    function createTileEl(tile, spawnDrop=false){
      const el = document.createElement("div");
      el.className="tile";
      el.dataset.id = tile.id;

      const {baseKey, variant} = parseTypeId(tile.type);
      el.dataset.base = baseKey;
      el.dataset.variant = variant;
      const base = getBase(baseKey);
      const spec = getSpecial(baseKey);
      const meta = base || spec;

      // palettes (neutral): Background is NOT tied to the character (less confusion, more readable)
      const pal = paletteForTile(tile);
      el.style.setProperty("--p1", pal[0]);
      el.style.setProperty("--p2", pal[1]);

      const plate = document.createElement("div");
      plate.className="plate";
      // Board tile background (jelly image only)
      const bg = tileBgFor(tile);
      if(bg){
        plate.style.setProperty("--bg-img", `url('${bg}')`);
      }


      // Powerups + ??? + Lovelie: animated background
      if(isPowerupKey(baseKey) || baseKey==="lovelie" || baseKey==="myst" || baseKey==="cit" || baseKey==="worm" || baseKey==="koala" || baseKey==="mellowzilla" || baseKey==="koalazilla"){
        el.classList.add("powerAnim");
      }

      // Big mellow size
      if(tile.big){
        el.classList.add("bigMellow");
      }

      if(baseKey === "myst"){
  const qm = document.createElement("div");
  qm.className="qmark";
  qm.textContent = "?";
  plate.appendChild(qm);
}else{
  const img = document.createElement("img");

  // Resolve image source (bases, specials, bosses)
  let src = meta?.img || "";
  if(baseKey==="mellowlord") src = IMG.mellowlord;
  
  if(baseKey==="worm") src = IMG.sourwurm[tile.wormIdx||0] || IMG.sourwurm[0];
  if(baseKey==="mellowzilla") src = IMG.mellowzilla[tile.animFrame||0] || IMG.mellowzilla[0];
  if(baseKey==="koalazilla") src = IMG.koalazilla[tile.animFrame||0] || IMG.koalazilla[0] || IMG.koala;

  img.src = src;
  img.alt = meta?.name || baseKey;

  // Fallbacks (avoid broken icons)
  img.addEventListener("error", ()=>{
    if(baseKey==="koalazilla" && img.src !== IMG.koala) img.src = IMG.koala;
  }, {once:true});

  plate.appendChild(img);

  // Variant badge so A/B are clearly visible (prevents "combo feels broken")
  if(base && variant==="B"){
    const vb = document.createElement("div");
    vb.className = "variantBadge";
    vb.textContent = "B";
    plate.appendChild(vb);
  }
}

      el.appendChild(plate);
      if(tile.big && (baseKey==="mellowlord" || baseKey==="mellowzilla" || baseKey==="koalazilla")){
        const hp = document.createElement("div");
        hp.className="hp";
        hp.textContent = tile.hp;
        el.appendChild(hp);
      }
setTileXY(el, tile.r, tile.c);

      if(spawnDrop){
        const fallDist = (tile.r + 3) * (CELL+GAP);
        plate.style.setProperty("--oy", `-${fallDist}px`);
        plate.style.setProperty("--op", "0");

        requestAnimationFrame(()=>{
          plate.style.setProperty("--oy", "0px");
          plate.style.setProperty("--op", "1");
        });

        // Use timeout instead of transitionend for reliability
        setTimeout(()=>{
          el.classList.add("land");
          const center = tileCenter(tile.r, tile.c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>el.classList.remove("land"), 560);
        }, 300);
      }

      el.addEventListener("pointerdown", onPointerDown);
        el.addEventListener("pointerup", onPointerUp);
  return el;
}

// Keep visuals in sync when a tile changes type without recreating the element
function refreshTileEl(tile){
  const el = tileEls.get(tile.id);
  if(!el) return;

  const {baseKey, variant} = parseTypeId(tile.type);
  el.dataset.base = baseKey;
  el.dataset.variant = variant;

  const base = getBase(baseKey);
  const spec = getSpecial(baseKey);
  const meta = base || spec;

  // palettes (character/complement based)
  const pal = paletteForTile(tile);
  el.style.setProperty("--p1", pal[0]);
  el.style.setProperty("--p2", pal[1]);

  // image
  const plate = el.querySelector(".plate");
  const img = el.querySelector("img");
  if(img){
    let src = meta?.img || "";
    if(baseKey==="mellowlord") src = IMG.mellowlord;
    
    if(baseKey==="worm") src = IMG.sourwurm[tile.wormIdx||0] || IMG.sourwurm[0];
    if(baseKey==="mellowzilla") src = IMG.mellowzilla[tile.animFrame||0] || IMG.mellowzilla[0];
    if(baseKey==="koalazilla") src = IMG.koalazilla[tile.animFrame||0] || IMG.koalazilla[0] || IMG.koala;

    img.src = src;
    img.alt = meta?.name || baseKey;
  }

  // variant badge
  const oldBadge = el.querySelector(".variantBadge");
  if(oldBadge) oldBadge.remove();
  if(plate && base && variant==="B"){
    const vb = document.createElement("div");
    vb.className="variantBadge";
    vb.textContent="B";
    plate.appendChild(vb);
  }
}

function updateMellowHp(tile){
      const el = tileEls.get(tile.id);
      if(!el) return;
      const hp = el.querySelector(".hp");
      if(hp) hp.textContent = tile.hp;
    }

    function findTileById(id){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t && t.id===id) return t;
        }
      }
      return null;
    }

    /**********************
     * Random tile generation
     **********************/
    // Balancing: Limit active Luvvies on small boards
    function getActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);

      // Limit count based on Difficulty/Size to ensure matches are possible
      // Easy (10x10): Max 7-8 colors?
      // Shock (8x8): Max 5-6 colors.
      let maxColors = 6;
      if(diff.key === "easy") maxColors = 7;
      if(diff.key === "normal") maxColors = 6;
      if(diff.key === "hard") maxColors = 6;
      if(diff.key === "shock") maxColors = 5; // 8x8 with too many colors is impossible

      // If pool is larger, slice it?
      // But we want consistent characters.
      // We can consistently slice based on the current level/seed, or just take the first N.
      // BASES is sorted by appearance? Fledernuss is minLevel 10.
      // We should prioritize "basic" ones + 1-2 advanced.
      if(pool.length > maxColors){
         // Always keep basics (sweety, sleepy, normal, cry, joyce, smokey)
         // Rotate the others?
         // For stability, let's just pick the first 'maxColors' valid ones
         // but Fledernuss/Simba might be cut off.
         // Better: Pick random subset per Level? No, confusing.
         // Pick subset per Game? Yes.
         // We can store 'activeSet' in a variable when game starts.
      }
      return pool;
    }

    let gameActivePool = []; // Set on newGame

    function randNormalType(){
      // Use active subset
      const pool = gameActivePool.length ? gameActivePool : BASES;
      const weights = pool.map(b=>{
        const w = (b.key==="joyce"||b.key==="smokey") ? 9 : (b.key==="donut") ? 10 : 12;
        return {b, w};
      });
      const totalW = weights.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*totalW;
      let pick = weights[0].b;
      for(const x of weights){
        r -= x.w;
        if(r<=0){ pick = x.b; break; }
      }

      const variants = Array.from(unlocked[pick.key]);
      let v="A";
      if(variants.includes("B")){
        v = (Math.random() < 0.28) ? "B" : "A";
      }
      return typeId(pick.key, v);
    }

    function makeId(){
      return (crypto?.randomUUID?.() || (Math.random().toString(16).slice(2)+Date.now().toString(16)));
    }

    function makeTile(r,c,type){
      const id = makeId();
      const t = { id, r, c, type, hp:0, big:false, animFrame:0 };
      const {baseKey} = parseTypeId(type);
      if(baseKey === "worm") t.wormIdx = Math.floor(Math.random()*3);
      return t;
    }

    function wouldCreateMatch(r,c,type){
      const k = parseTypeId(type).baseKey;
      if(c>=2){
        const a=grid[r][c-1], b=grid[r][c-2];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      if(r>=2){
        const a=grid[r-1][c], b=grid[r-2][c];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      return false;
    }

    /**********************
     * Background (no bubbles) + subtle twinkles
     **********************/
    let globalBgSize = {w:0, h:0};
    let fsBgSize = {w:0, h:0};

    function buildGlobalBg(force=false){
      syncBgHeight();
      const cont = document.getElementById("globalBg");

      const page = document.getElementById("page");
      const W = page.clientWidth;
      const H = Math.max(page.scrollHeight, window.innerHeight);
      if(!force && cont.children.length){
        if(Math.abs(W - globalBgSize.w) < 40 && Math.abs(H - globalBgSize.h) < 40) return;
      }
      globalBgSize = {w:W, h:H};
      cont.innerHTML = "";
      const bgChars = [...BASES].sort(()=>Math.random()-0.5).slice(0,8);

      bgChars.forEach((b)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        const img = document.createElement("img");
        img.src=b.img; img.alt=b.name;

        const leftZone = Math.random() < 0.5;
        const x = leftZone
          ? Math.random()*(Math.max(240, W*0.26) - 120)
          : (W - 300) - Math.random()*(Math.max(240, W*0.26) - 120);

        const y = Math.random()*(Math.max(520,H)-280);

        wrap.style.left = Math.max(0, x)+"px";
        wrap.style.top  = y+"px";
        wrap.style.animationDuration = (16 + Math.random()*10)+"s";

        wrap.appendChild(img);
        cont.appendChild(wrap);

        // subtle twinkles around them (rare)
        const tick = ()=>{
          if(Math.random() < 0.28){
            const rect = wrap.getBoundingClientRect();
            const px = rect.left + rect.width * (0.2 + Math.random()*0.6);
            const py = rect.top  + rect.height* (0.2 + Math.random()*0.6);
            const t = document.createElement("div");
            t.className="twinkle";
            t.style.left = px + "px";
            t.style.top  = (py + window.scrollY) + "px";
            cont.appendChild(t);
            setTimeout(()=>t.remove(), 1300);
          }
        };
        setInterval(tick, 2200 + Math.random()*1400);
      });
    }

    function buildFsBg(force=false){
      const fs = document.getElementById("fsBg");
      if(!document.body.classList.contains("fs") && !document.body.classList.contains("maximized")) return;
      const W = fs.clientWidth || window.innerWidth;
      const H = fs.clientHeight || window.innerHeight;
      if(!force && fs.children.length){
        if(Math.abs(W - fsBgSize.w) < 40 && Math.abs(H - fsBgSize.h) < 40) return;
      }
      fsBgSize = {w:W, h:H};
      fs.innerHTML = "";
      const pick = [...BASES].sort(()=>Math.random()-0.5).slice(0,7);
      pick.forEach((b)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        wrap.style.opacity = ".78";
        wrap.style.width = "min(260px, 42vw)";
        const img = document.createElement("img");
        img.src=b.img; img.alt=b.name;

        const leftZone = Math.random() < 0.5;
        const x = leftZone ? Math.random()*(W*0.28) : (W-280) - Math.random()*(W*0.28);
        const y = Math.random()*(H-240);
        wrap.style.left = Math.max(0,x)+"px";
        wrap.style.top  = Math.max(0,y)+"px";
        wrap.style.animationDuration = (16 + Math.random()*10)+"s";

        wrap.appendChild(img);
        fs.appendChild(wrap);
      });
    }

    /**********************
     * Board init
     **********************/
    function initBoard(){
      rows = diff.rows;
      cols = diff.cols;

      ui.tips.innerHTML = `
        ‚Ä¢ 4er-Match ‚áí <b>Sourworm</b> (Reihe/Spalte)<br>
        ‚Ä¢ 5er-Match ‚áí <b>Citrussy</b> (Stern Radius 3)<br>
        ‚Ä¢ T/L-Match ‚áí <b>Koala</b> (Magie)<br>
        ‚Ä¢ <b>2√ó Sleepy + 1√ó Mondlie</b> ‚áí Shuffle 4√ó4 ‚ú®<br>
        ‚Ä¢ <b>2√ó Joyce + 1√ó Smokey</b> ‚áí Buddy Burst<br>
        ‚Ä¢ <b>2√ó Smokey + 1√ó Simba</b> ‚áí Best Buddy Wave<br>
        ‚Ä¢ <b>Falscher Swap</b> ‚áí ‚àí3 Moves<br>
        ‚Ä¢ <b>Keine Z√ºge</b> ‚áí Auto-Shuffle, ‚àí1 Move
      `;

      grid = Array.from({length:rows}, (_,r)=>Array.from({length:cols}, (_,c)=>null));
      tileEls.clear();
      ui.board.innerHTML="";
      ui.fx.innerHTML="";
      bigMellows.clear();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let t;
          let tries=0;
          do{
            t = randNormalType();
            tries++;
          }while(wouldCreateMatch(r,c,t) && tries<40);

          const tile = makeTile(r,c,t);
          grid[r][c]=tile;
        }
      }

      spawnMellow();
      spawnMellowZilla();
      maybeSpawnLovelie();
      layoutBoard();

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const tile = grid[r][c];
          const el = createTileEl(tile, false);
          tileEls.set(tile.id, el);
          ui.board.appendChild(el);
        }
      }

      buildGlobalBg();
      buildFsBg();

      setTimeout(()=>resolveAll(true), 50);
    }

    /**********************
     * Mellow spawn: ab Level 3, dann alle 4 Level (3,7,11...) / immer 3 HP
     **********************/
    function shouldSpawnMellowThisLevel(){
      if(level < 3) return false;
      return level === 3 || ((level - 3) % 4 === 0);
    }

    function spawnMellow(){
      if(!shouldSpawnMellowThisLevel()) return;
      const count = clamp(1 + Math.floor(level/4), 1, Math.floor(rows*cols/10));
      for(let i=0;i<count;i++){
        for(let tries=0;tries<260;tries++){
          const r=Math.floor(Math.random()*rows);
          const c=Math.floor(Math.random()*cols);
          const cur=grid[r][c];
          if(!cur) continue;
          if(isBlocker(cur)) continue;

          const bk = parseTypeId(cur.type).baseKey;
          if(getSpecial(bk)) continue;

          const m = makeTile(r,c,typeId("mellow","P"));
          m.hp = 0; // Small mellow has no HP (invincible)
          const oldEl = tileEls.get(cur.id);
          if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }

          grid[r][c]=m;
          const el = createTileEl(m, false);
          el.classList.add("spawnGlow");
          tileEls.set(m.id, el);
          ui.board.appendChild(el);
          const center = tileCenter(r,c);
          burstFx(center.x, center.y, 10);
          break;
        }
      }
    }

    function maybeSpawnLovelie(){
      if(Math.random() > diff.lovelieChance) return;
      for(let tries=0;tries<220;tries++){
        const r=Math.floor(Math.random()*rows);
        const c=Math.floor(Math.random()*cols);
        const cur=grid[r][c];
        if(!cur) continue;
        if(isBlocker(cur)) continue;
        const bk = parseTypeId(cur.type).baseKey;
        if(getSpecial(bk)) continue;

        const lov = makeTile(r,c,typeId("lovelie","P"));
        const oldEl = tileEls.get(cur.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }
        grid[r][c]=lov;

        const el = createTileEl(lov, false);
        el.classList.add("spawnGlow");
        tileEls.set(lov.id, el);
        ui.board.appendChild(el);
        toast("Lovelie erscheint! üíñ","Ultra selten ‚ú®", 3200);
        break;
      }
    }

    /**********************
     * Mystery reveal (??? click -> random)
     **********************/
    function pickMyst(){
      const total = MYST_POOL.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*total;
      for(const x of MYST_POOL){
        r -= x.w;
        if(r<=0) return x.key;
      }
      return "worm";
    }

    function revealMyst(tile){
      if(busy) return;
      busy = true;
      const el = tileEls.get(tile.id);
      if(el) el.classList.add("puff");

      const {x,y} = tileCenter(tile.r, tile.c);
      burstFx(x,y, 14);

      setTimeout(()=>{
        const pick = pickMyst();

        // replace old tile
        const oldEl = tileEls.get(tile.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(tile.id); }

        let newType = typeId("worm","P");
        if(pick==="cit") newType = typeId("cit","P");
        if(pick==="koala") newType = typeId("koala","P");
        if(pick==="lovelie") newType = typeId("lovelie","P");
        if(pick==="mellow") newType = typeId("mellow","P");

        const t2 = makeTile(tile.r, tile.c, newType);
        if(pick==="mellow") t2.hp = 3;

        grid[tile.r][tile.c] = t2;

        const el2 = createTileEl(t2, false);
        el2.classList.add("spawnGlow");
        tileEls.set(t2.id, el2);
        ui.board.appendChild(el2);

        toast("??? Reveal ‚ú®", pick==="worm" ? "Sourworm!" :
                            pick==="cit" ? "Citrussy!" :
                            pick==="mellow" ? "Mellow Block!" :
                            pick==="koala" ? "Koala!" : "Lovelie üíñ", 2800);
        busy = false;
        updateUI();
      }, 360);
    }

    function collectBonus(tile){
       if(busy) return;
       busy=true;
       toast("Bonus! üíñ", "Lovelie collected!", 2000);
       clearCells([{r:tile.r, c:tile.c}]);
       totalScore += 5000;
       updateUI();
       setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 300);
    }

    /**********************
     * Pointer & Drag System (1:1 Drag Fix)
     **********************/
    let dragStart = {x:0, y:0};
    let currentDrag = null;
    let busyStart = 0; // Watchdog timestamp

    function onPointerDown(e){
      e.preventDefault(); // avoid text/image dragging or board grabbing
      // Watchdog: If busy for too long (>2.5s) without active resolution, force unlock
      if(busy){
         if(!busyStart) busyStart = Date.now();
         if(Date.now() - busyStart > 2500){
             console.warn("Busy state stuck, auto-recovering...");
             busy = false;
             busyStart = 0;
             document.querySelectorAll('.tile.dragging').forEach(el=>el.classList.remove('dragging'));
             toast("Auto-Fix üõ†Ô∏è", "Input block gel√∂st.", 1500);
         } else {
             return;
         }
      }
      busyStart = Date.now();

      const tEl = e.currentTarget;
      const id = tEl.dataset.id;
      const tile = findTileById(id);
      if(!tile) return;

      if(currentDrag) return;

      clearHints();
      tEl.setPointerCapture(e.pointerId);

      const rect = tEl.getBoundingClientRect();
      const boardRect = ui.board.getBoundingClientRect();

      // We calculate current position based on grid logic to ensure we start from "true" position
      // Visual drag uses CSS translate.
      // 1:1 Dragging means: Mouse Delta = Tile Delta.

      // Store initial mouse pos
      dragStart = {
        startX: e.clientX,
        startY: e.clientY,
        // Store initial CSS transform values
        initialLeft: tile.c * (CELL+GAP) + PAD,
        initialTop:  tile.r * (CELL+GAP) + PAD,
      };

      currentDrag = {
        id: id,
        el: tEl,
        r: tile.r,
        c: tile.c,
        moved: false
      };

      tEl.classList.add("dragging");
    }

    function onPointerMove(e){
      if(!currentDrag) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      if(!currentDrag.moved && Math.hypot(dx,dy) > 6) currentDrag.moved = true;

      if(currentDrag.moved){
         // Lock drag to primary axis and clamp to half a cell so tiles never fully overlap
         const primary = Math.abs(dx) >= Math.abs(dy) ? "x" : "y";
         const maxShift = (CELL + GAP) * 0.48;
         let shiftX = 0, shiftY = 0;
         if(primary === "x"){
            shiftX = Math.max(-maxShift, Math.min(maxShift, dx));
         } else {
            shiftY = Math.max(-maxShift, Math.min(maxShift, dy));
         }

         const newX = dragStart.initialLeft + shiftX;
         const newY = dragStart.initialTop + shiftY;

         currentDrag.el.style.setProperty('--x', newX+"px");
         currentDrag.el.style.setProperty('--y', newY+"px");
      }
    }

    function onPointerUp(e){
      if(!currentDrag) return;
      const {id, el, r, c, moved} = currentDrag;
      const tile = findTileById(id);
      currentDrag = null;
      el.classList.remove("dragging");
      el.releasePointerCapture(e.pointerId);

      // Revert visual to grid slot immediately (animation happens if swap valid)
      setTileXY(el, r, c);

      if(!moved){
         if(tile && tile.type.startsWith("myst")) revealMyst(tile);
         if(tile && parseTypeId(tile.type).baseKey === "lovelie") collectBonus(tile);
         return;
      }

      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      // Determine drag direction based on movement
      // Use threshold relative to cell size for better feel?
      // User requested 1:1 follows.
      // Simple threshold 20px
      if(Math.hypot(dx,dy) < 15) return;

      // Direction
      let dirStr = "";
      if(Math.abs(dx) > Math.abs(dy)) dirStr = dx>0 ? "R" : "L";
      else dirStr = dy>0 ? "D" : "U";

      const dr = (dirStr==="D")?1:(dirStr==="U")?-1:0;
      const dc = (dirStr==="R")?1:(dirStr==="L")?-1:0;

      const r2 = r + dr;
      const c2 = c + dc;

      if(!inBounds(r2,c2)) return;

      // Determine Lock/Direction Logic
      const t1 = tile;
      const t2 = grid[r2][c2];

      if(!t1 || !t2) return;
      if(isBlocker(t1) || isBlocker(t2)) return;

      const k1 = parseTypeId(t1.type).baseKey;
      const k2 = parseTypeId(t2.type).baseKey;
      const p1 = isPowerupKey(k1);
      const p2 = isPowerupKey(k2);

      // Special: Lovelie + Lovelie -> Harmony
      if(k1==="lovelie" && k2==="lovelie"){
         trySwap(r, c, r2, c2);
         return;
      }

      // Special: Powerup + SuperNuss -> Super Combo
      const sn1 = k1==="supernuss";
      const sn2 = k2==="supernuss";
      if((p1 && sn2) || (p2 && sn1)){
         trySwap(r, c, r2, c2);
         return;
      }

      // Bonus: Lovelie interaction logic
      // Priority 1: If mixing with Powerup -> Swap/Combo
      if((k1==="lovelie" && p2) || (k2==="lovelie" && p1)){
         trySwap(r, c, r2, c2);
         return;
      }
      // Priority 2: Just clicking/swapping with normal -> Collect Bonus
      if(k1 === "lovelie"){ collectBonus(t1); return; }
      if(k2 === "lovelie"){ collectBonus(t2); return; }

      // Case 1: Powerup + Powerup -> FORCE SWAP (Combo)
      if(p1 && p2){
         trySwap(r, c, r2, c2);
         return;
      }

      // Case 2: Dragging FROM Powerup (Powerup + Normal) -> LOCK & ACTIVATE
      if(p1 && !p2){
       try{
         // Activate Powerup t1 in direction (dr,dc)
         toast("Powerup Activate! üí•", "Direction: "+dirStr, 1500);
         busy = true; // Lock input immediately

         if(k1 === "koala"){
            koalaMagicOn(k2);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "worm"){
            if(dr !== 0) clearCol(c);
            else clearRow(r);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "cit"){
             citBlast(r,c,3);
             clearCells([{r:t1.r,c:t1.c}]);
             spendMoves(1);
             setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
             return;
         }
         busy = false; // Reset if fallthrough
       }catch(e){
         console.error(e);
         busy=false; // Safety reset
       }
         return;
      }

      // Case 3: Dragging Normal -> Powerup
      if(!p1 && p2){
         // "Nie Powerups verschieben" -> Blocked.
         toast("Blockiert!", "Powerups sind fest verankert.", 1000);
         return;
      }

      // Case 4: Normal Swap
      trySwap(r, c, r2, c2);
    }

    ui.board.removeEventListener("pointermove", ()=>{});
    ui.board.addEventListener("pointermove", onPointerMove);
    ui.board.addEventListener("pointerup", onPointerUp);
    ui.board.addEventListener("pointercancel", onPointerUp);

    /**********************
     * Gameplay core (Swap/Resolve)
     **********************/

    function doSwap(r1,c1,r2,c2){
      const a = grid[r1][c1], b = grid[r2][c2];
      grid[r1][c1]=b; grid[r2][c2]=a;
      a.r=r2; a.c=c2;
      b.r=r1; b.c=c1;

      const elA = tileEls.get(a.id);
      const elB = tileEls.get(b.id);
      if(elA) setTileXY(elA,a.r,a.c);
      if(elB) setTileXY(elB,b.r,b.c);
    }

    function spendMoves(n){
      moves = Math.max(0, moves - n);
      combo = 0; // Reset combo on each paid/consumed move
      if(moves===0){
        setTimeout(()=>gameOver(), 350);
      }
    }

    function quadMatchKind(t1,t2,t3,t4){
      if(!t1||!t2||!t3||!t4) return null;
      if(isBlocker(t1)||isBlocker(t2)||isBlocker(t3)||isBlocker(t4)) return null;

      const p1=parseTypeId(t1.type), p2=parseTypeId(t2.type), p3=parseTypeId(t3.type), p4=parseTypeId(t4.type);
      const keys=[p1.baseKey,p2.baseKey,p3.baseKey,p4.baseKey];
      const count=(k)=>keys.filter(x=>x===k).length;

      // 3+1 Logic (Ghost combo fix)
      if(count("sleepy")===3 && count("mond")===1){ unlockCombo("moonshuffle"); return "moonshuffle"; }
      if(count("grumpy")===3 && count("happy")===1){ unlockCombo("therapy"); return "therapy"; }
      if(count("donut")===3 && count("sweety")===1){ unlockCombo("sprinkle"); return "sprinkle"; }
      if(count("donut")===3 && count("happy")===1){ unlockCombo("sugar"); return "sugar"; }

      // Buddies: 3 of either + 1 of other
      if(count("smokey")===3 && count("joyce")===1) return "buddies";
      if(count("joyce")===3 && count("smokey")===1) return "buddies";

      if(count("smokey")===3 && count("simba")===1) return "bestbuddies";
      if(count("simba")===3 && count("smokey")===1) return "bestbuddies";

      return null;
    }

    function findSpecialQuads(){
      if(!isGridReady()) return [];
      const found=[];
      // Horizontal Quads
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols-3;c++){
          const t1=grid[r][c], t2=grid[r][c+1], t3=grid[r][c+2], t4=grid[r][c+3];
          const kind = quadMatchKind(t1,t2,t3,t4);
          if(kind) found.push({kind, cells:[{r,c},{r,c:c+1},{r,c:c+2},{r,c:c+3}]});
        }
      }
      // Vertical Quads
      for(let c=0;c<cols;c++){
        for(let r=0;r<rows-3;r++){
          const t1=grid[r][c], t2=grid[r+1][c], t3=grid[r+2][c], t4=grid[r+3][c];
          const kind = quadMatchKind(t1,t2,t3,t4);
          if(kind) found.push({kind, cells:[{r,c},{r:r+1,c},{r:r+2,c},{r:r+3,c}]});
        }
      }
      return found;
    }

    function findLineMatches(){
      if(!isGridReady()) return {clear:new Set(), spawn:new Map(), hRuns:[], vRuns:[]};
      const clear = new Set();
      const hRuns = [];
      const vRuns = [];

      for(let r=0;r<rows;r++){
        let c=0;
        while(c<cols){
          const row = grid[r];
          if(!row){ c=cols; continue; }
          const t = row[c];
          if(!isMatchable(t)){ c++; continue; }
          const k = matchKey(t);
          let start=c;
          while(c<cols && row[c] && isMatchable(row[c]) && matchKey(row[c])===k) c++;
          const len = c-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r,c:x});
              clear.add(posKey(r,x));
            }
            hRuns.push({len,cells});
          }
        }
      }

      for(let c=0;c<cols;c++){
        let r=0;
        while(r<rows){
          const row = grid[r];
          if(!row){ r++; continue; }
          const t = row[c];
          if(!isMatchable(t)){ r++; continue; }
          const k = matchKey(t);
          let start=r;
          while(r<rows && grid[r] && grid[r][c] && isMatchable(grid[r][c]) && matchKey(grid[r][c])===k) r++;
          const len = r-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r:x,c});
              clear.add(posKey(x,c));
            }
            vRuns.push({len,cells});
          }
        }
      }

      const spawn = new Map();
      const inRunH = new Map();
      const inRunV = new Map();

      for(const run of hRuns) for(const p of run.cells) inRunH.set(posKey(p.r,p.c), 1);
      for(const run of vRuns) for(const p of run.cells) inRunV.set(posKey(p.r,p.c), 1);
      for(const key of clear){
        if(inRunH.has(key) && inRunV.has(key)){
          spawn.set(key, {type:typeId("koala","P"), prio:3});
        }
      }

      function pickSpawnCell(run){
        if(lastSwap){
          const pref = posKey(lastSwap.pref.r, lastSwap.pref.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===pref)) return pref;
          const alt = posKey(lastSwap.alt.r, lastSwap.alt.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===alt)) return alt;
        }
        const mid = run.cells[Math.floor(run.cells.length/2)];
        return posKey(mid.r, mid.c);
      }

      for(const run of [...hRuns, ...vRuns]){
        const k = pickSpawnCell(run);
        if(spawn.get(k)?.prio===3) continue;
        if(run.len>=5) spawn.set(k, {type:typeId("cit","P"), prio:2});
        else if(run.len===4) spawn.set(k, {type:typeId("worm","P"), prio:1});
      }

      for(const [k] of spawn) clear.delete(k);

      return {clear, spawn, hRuns, vRuns};
    }

    function hasAnyMatchOrSpecial(){
      const mm = findLineMatches();
      if(mm.clear.size>0) return true;
      const sp = findSpecialQuads();
      return sp.length>0;
    }

    function checkPowerSwap(t1, t2){
      if(!t1 || !t2) return false;
      const p1 = parseTypeId(t1.type).baseKey;
      const p2 = parseTypeId(t2.type).baseKey;

      const isP1 = isPowerupKey(p1);
      const isP2 = isPowerupKey(p2);
      const isS1 = p1 === "supernuss";
      const isS2 = p2 === "supernuss";
      const isL1 = p1 === "lovelie";
      const isL2 = p2 === "lovelie";

      // 1. Lovelie + Lovelie
      if(isL1 && isL2) return true;

      // 2. Powerup + SuperNuss
      if((isP1 && isS2) || (isP2 && isS1)) return true;

      // 3. Any Powerup involved (Combo or Single)
      // This covers Power+Power, Power+Normal, Lovelie+Power
      if(isP1 || isP2) return true;

      // 4. SuperNuss + SuperNuss? (If logic requires, though usually Powerup+SuperNuss is the key)

      return false;
    }

    function trySwap(r1,c1,r2,c2){
      if(busy) return;
      clearHints();
      const a = grid[r1][c1];
      const b = grid[r2][c2];
      if(!a || !b) return;
      if(isBlocker(a) || isBlocker(b)) return;
      if(!isSwappable(a) || !isSwappable(b)) return;
      combo = 0; // Reset combo on any player swap
      busy = true;
      lastSwap = { pref:{r:r2,c:c2}, alt:{r:r1,c:c1} };

      doSwap(r1,c1,r2,c2);
      setTimeout(()=>{
       try{
        const A = grid[r1][c1];
        const B = grid[r2][c2];
        const aBk = parseTypeId(A.type).baseKey;
        const bBk = parseTypeId(B.type).baseKey;

        if( checkPowerSwap(A, B) ){
          spendMoves(1);
          resolvePowerSwap(A,B,{dr:r2-r1, dc:c2-c1});
          setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 220);
          return;
        }

        const ok = hasAnyMatchOrSpecial();

        // Free Swapping: No revert if no match.
      // Track last player move (for zilla targeting)
      lastPlayerMove = { r: r2, c: c2 };

      // Check if Mellow is involved (Free move up to 10x)
      if(aBk === "mellow" || bBk === "mellow"){
         if(mellowFreeMoves > 0){
           mellowFreeMoves -= 1;
         } else {
           spendMoves(1);
           }
        } else {
           spendMoves(1);
        }

        // Even if no match immediately, we resolve (maybe gravity falls? no, just check matches)
        // If ok is false, resolveAll will basically find nothing and just unlock busy.
        resolveAll(false, true);
       }catch(e){
         console.error(e);
         busy=false;
         doSwap(r1,c1,r2,c2); // undo on error
       }
      }, 185);
    }

    function hitMellowAt(r,c, dmg=1){
      const t = grid[r][c];
      if(!t) return false;

      let bigId = null;
      if(isPlaceholder(t)) bigId = t.partOf;
      else if(t.big && bigMellows.has(t.id)) bigId = t.id;

      if(bigId){
        const big = bigMellows.get(bigId);
        if(!big) return false;
        big.hp = Math.max(0, big.hp - dmg);

        // KOALA_BOSSFIGHT_SYNC_HP: Boss HP in State spiegeln
        try{
          if(bossFight && bossFight.active && (big.type==='mellowzilla' || big.type==='koalazilla')){
            bossFight.hp = big.hp;
          }
        }catch(e){}
        const anchorTile = grid[big.r][big.c];
        if(anchorTile){
          anchorTile.hp = big.hp;
          updateMellowHp(anchorTile);
        }
        if(big.hp<=0) removeBigMellow(bigId);
        return true;
      }

      const bk = parseTypeId(t.type).baseKey;
      if(bk==="mellow"){
        // Small Mellow is INVINCIBLE (absorbs hit but takes no damage)
        // It must be merged to form MellowLord to be destroyable (or cleared by special effects?)
        // User said: "mellow sollte unsterblich sein ... 2x2 zusammen packen damit er zu mellowlord wird"
        return true;
      }
      return false;
    }

    function damageMellowsAround(clearedCells){
      const dirs = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
      ];
      for(const p of clearedCells){
        for(const [dr,dc] of dirs){
          const rr=p.r+dr, cc=p.c+dc;
          if(!inBounds(rr,cc)) continue;
          hitMellowAt(rr,cc,1);
        }
      }
    }

    function jellyBumpAround(clearedCells){
      const dirs = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
      ];
      const targets = new Set();
      for(const p of clearedCells){
        for(const [dr,dc] of dirs){
          const rr = p.r + dr, cc = p.c + dc;
          if(!inBounds(rr,cc)) continue;
          const t = grid[rr][cc];
          if(!t || isBlocker(t)) continue;
          targets.add(posKey(rr,cc));
        }
      }
      for(const key of targets){
        const [r,c] = key.split(",").map(Number);
        const t = grid[r][c];
        if(!t) continue;
        const el = tileEls.get(t.id);
        if(!el) continue;
        el.classList.remove("bump");
        // reflow to restart animation
        void el.offsetWidth;
        el.classList.add("bump");
        setTimeout(()=>el.classList.remove("bump"), 520);
      }
    }

    function clearCells(cells, opts={}){
      const protectPower = !!opts.protectPower;
      const PROTECTED = new Set(["fledernuss","flederheld","supernuss"]);
      const uniq = new Set(cells.map(p=>posKey(p.r,p.c)));
      const cleared = [];

      for(const key of uniq){
        const [r,c] = key.split(",").map(Number);
        const t = grid[r][c];
        if(!t) continue;

        if(hitMellowAt(r,c,1)){
          const center = tileCenter(r,c);
          makeStar(center.x, center.y, false);
          continue;
        }
        if(isPlaceholder(t)) continue;

        if(protectPower){
          const bk = parseTypeId(t.type).baseKey;
          if(PROTECTED.has(bk)) continue;
        }

        const el = tileEls.get(t.id);
        if(el){
          el.classList.add("pop");
          const center = tileCenter(r,c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
        }
        grid[r][c]=null;
        cleared.push({r,c});
      }

      damageMellowsAround(cleared);
      jellyBumpAround(cleared);

      const add = Math.round(cleared.length * scorePerTile() * 1.10);
      totalScore += add;
      levelScore += add;
    }

    function clearRow(r){
      const cells=[];
      for(let c=0;c<cols;c++) cells.push({r,c});
      clearCells(cells, {protectPower:true});
      totalScore += 200; levelScore += 200;
    }
    function clearCol(c){
      const cells=[];
      for(let r=0;r<rows;r++) cells.push({r,c});
      clearCells(cells, {protectPower:true});
      totalScore += 200; levelScore += 200;
    }
    function citBlast(r,c, radius=3){
      const cells=[];
      // Diagonal band (3-wide) across the whole board
      // Main diagonals: (r-c) = const and (r+c) = const
      const diff = r - c;
      const sum = r + c;

      for(let rr=0; rr<rows; rr++){
        for(let cc=0; cc<cols; cc++){
           // Check bandwidth 3 (center + 1 each side)
           if(Math.abs((rr-cc) - diff) <= 1 || Math.abs((rr+cc) - sum) <= 1){
             cells.push({r:rr, c:cc});
           }
        }
      }
      clearCells(cells, {protectPower:true});
      totalScore += 260; levelScore += 260;
    }
    function clearWholeBoard(){
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk==="myst") continue;
        cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
      totalScore += 800; levelScore += 800;
    }
    function wormWave6(r1,c1,r2,c2){
      const mid = Math.round((c1+c2)/2);
      let start = mid-2;
      let end = mid+3;
      if(start<0){ end += -start; start=0; }
      if(end>cols){ start -= (end-cols); end=cols; start=Math.max(0,start); }

      const cells=[];
      for(let r=0;r<rows;r++){
        for(let c=start;c<end;c++) cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
      totalScore += 500; levelScore += 500;
    }
    function koalaMagicOn(targetBaseKey){
      const base = getBase(targetBaseKey);
      toast("üê® Koala-Magie!", "Alles von "+(base?.name||targetBaseKey)+" weg!", 3200);
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk===targetBaseKey) cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
    }

    function resolvePowerSwap(A,B,dir){
      const aBk = parseTypeId(A.type).baseKey;
      const bBk = parseTypeId(B.type).baseKey;

      // === 1. Lovelie + Lovelie ===
      if(aBk==="lovelie" && bBk==="lovelie"){
         lovelieHarmony(A,B);
         return;
      }

      // === 2. SuperNuss + Powerup ===
      // Check if one is Powerup and other is SuperNuss
      if(isPowerupKey(aBk) && bBk==="supernuss"){
         superNussCombo(A, B); return;
      }
      if(isPowerupKey(bBk) && aBk==="supernuss"){
         superNussCombo(B, A); return;
      }

      // === 3. Lovelie + Powerup ===
      if(aBk==="lovelie" && isPowerupKey(bBk)){
         activateLovelieCombo(B, A); return;
      }
      if(bBk==="lovelie" && isPowerupKey(aBk)){
         activateLovelieCombo(A, B); return;
      }

      // === 4. Powerup + Powerup ===

      // Koala + Worm
      if((aBk==="koala" && bBk==="worm") || (aBk==="worm" && bBk==="koala")){
        toast("üê®ü™± KOALA √ó WORM!", "MEGA CROSS BLAST! üí•", 3500);
        const rMid = Math.round((A.r + B.r)/2);
        const cMid = Math.round((A.c + B.c)/2);
        const cells = [];
        for(let r=rMid-1; r<=rMid+1; r++){
            if(r<0 || r>=rows) continue;
            for(let c=0; c<cols; c++) cells.push({r,c});
        }
        for(let c=cMid-1; c<=cMid+1; c++){
            if(c<0 || c>=cols) continue;
            for(let r=0; r<rows; r++) cells.push({r,c});
        }
        clearCells(cells, {protectPower:true});
        return;
      }

      // Koala + Citrussy
      if((aBk==="koala" && bBk==="cit") || (aBk==="cit" && bBk==="koala")){
        toast("üê®üçã KOALA √ó Citrussy!", "DOUBLE BOARD CLEAN √ó2 üí•üí•", 3800);
        clearWholeBoard();
        setTimeout(()=>{
         try{
          dropDown();
          mergeMellows();
          setTimeout(()=>{
           try{
            clearWholeBoard();
            const bonus = Math.round(2200 * diff.scoreMult);
            totalScore += bonus;
            levelScore += bonus;
            setTimeout(()=>{
              try{ dropDown(); mergeMellows(); resolveAll(false, true); }
              catch(e){ console.error(e); busy=false; }
            }, 240);
           }catch(e){ console.error(e); busy=false; }
          }, 260);
         }catch(e){ console.error(e); busy=false; }
        }, 260);
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      // Worm + Worm
      if(aBk==="worm" && bBk==="worm"){
        toast("ü™±ü™± WEAVER WEB!", "Checkerboard Wipe! üèÅ", 3200);
        checkerboardWipe(A,B);
        return;
      }

      // Cit + Cit
      if(aBk==="cit" && bBk==="cit"){
        toast("üçãüçã DOUBLE CIT!", "Big Bang! üí•", 3200);
        citBlast(A.r,A.c,6); // Bigger radius
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      // Koala + Koala
      if(aBk==="koala" && bBk==="koala"){
        toast("üê®üê® DOUBLE KOALA!", "Magic Wipe! ‚ú®", 3200);
        clearWholeBoard();
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}]);
        return;
      }

      // Worm + Cit
      if((aBk==="worm" && bBk==="cit") || (aBk==="cit" && bBk==="worm")){
         toast("ü™±üçã WORM √ó CIT!", "Star Rows! üí•", 3400);
         // Clear 3 Rows + 3 Cols
         const rMid = Math.round((A.r + B.r)/2);
         const cMid = Math.round((A.c + B.c)/2);
         // 3 Rows
         const cells = [];
         for(let r=rMid-1; r<=rMid+1; r++){
            if(r>=0 && r<rows) for(let c=0; c<cols; c++) cells.push({r,c});
         }
         // 3 Cols
         for(let c=cMid-1; c<=cMid+1; c++){
            if(c>=0 && c<cols) for(let r=0; r<rows; r++) cells.push({r,c});
         }
         clearCells(cells, {protectPower:true});
         return;
      }

      // === 5. Single Powerup Activation ===

      if(aBk==="koala" && !getSpecial(bBk)){
        koalaMagicOn(bBk);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
        return;
      }
      if(bBk==="koala" && !getSpecial(aBk)){
        koalaMagicOn(aBk);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      if(aBk==="worm"){
        if(dir.dr !== 0) clearCol(A.c);
        else clearRow(A.r);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
      }
      if(bBk==="worm"){
        if(dir.dr !== 0) clearCol(B.c);
        else clearRow(B.r);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
      }

      if(aBk==="cit"){
        citBlast(A.r,A.c,3);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
      }
      if(bBk==="cit"){
        citBlast(B.r,B.c,3);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
      }
    }

    function lovelieHarmony(A,B){
       toast("üíñüíñ PURE LOVE!", "Board Clean + Gifts! üéÅ", 4000);
       clearWholeBoard();
       // Spawn 3 Powerups randomly
       setTimeout(()=>{
          for(let i=0;i<3;i++){
             const r=Math.floor(Math.random()*rows);
             const c=Math.floor(Math.random()*cols);
             const types = ["worm:P", "cit:P", "koala:P"];
             const tType = types[Math.floor(Math.random()*types.length)];

             // Directly overwrite logic for spawn (simplified)
             // We can just rely on normal dropDown, but we want to Force spawns.
             // We can just set a flag or modify drop logic?
             // Simplest: Wait for dropDown then replace 3 random tiles?
             // Or just let normal drop happen and add points.
             // Let's add massive points.
             totalScore += 10000;
          }
          // Actually spawning specific powerups is hard because the board is empty and will be refilled by dropDown.
          // Let's just give +10 Moves.
          moves += 10;
          toast("Lovelie Bonus!", "+10 Moves! üéÅ", 3000);
          updateUI();
       }, 300);
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}], {protectPower:true});
    }

    function checkerboardWipe(A, B){
       const cells = [];
       // Pattern: (r+c)%2 same as A? Or just a fixed checkerboard.
       // Fixed checkerboard is cooler. (r+c)%2 === 0
       for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
             if( (r+c)%2 === 0 ) cells.push({r,c});
          }
       }
       clearCells(cells, {protectPower:true});
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}], {protectPower:true});
    }

    function superNussCombo(powerup, supernuss){
       const pk = parseTypeId(powerup.type).baseKey;

       if(pk==="worm"){
          toast("ü™±üå∞ GRAND CROSS!", "Rows+Cols+Diagonals! üí•", 3200);
          // Rows + Cols + Diagonals from center
          const r=supernuss.r, c=supernuss.c;
          clearRow(r); clearCol(c);
          const cells=[];
          // Diagonals
          for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
             if(inBounds(r+d, c+d)) cells.push({r:r+d,c:c+d});
             if(inBounds(r+d, c-d)) cells.push({r:r+d,c:c-d});
          }
          clearCells(cells, {protectPower:true});
       }
       else if(pk==="cit"){
          toast("üçãüå∞ GALAXY RING!", "Double Blast! ü™ê", 3200);
          // Radius 2 + Radius 4 rings
          citBlast(supernuss.r, supernuss.c, 3); // Center blast
          const cells=[];
          const r=supernuss.r, c=supernuss.c;
          // Radius 5 Ring
          for(let rr=0;rr<rows;rr++){
             for(let cc=0;cc<cols;cc++){
                const dist = Math.hypot(rr-r, cc-c);
                if(dist >= 4.5 && dist <= 5.5) cells.push({r:rr, c:cc});
             }
          }
          clearCells(cells, {protectPower:true});
       }
       else if(pk==="koala"){
           toast("üê®üå∞ GOLDEN ARMY!", "Evolution & Detonation! üí•", 4000);
           // Pick a random color present on board
           // Or neighbor color?
           // Random color.
           const target = BASES[Math.floor(Math.random()*BASES.length)];
           const tKey = target.key;

           // Visual transform + Clear
           const cells = [];
           for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
              const t=grid[r][c];
              if(t && parseTypeId(t.type).baseKey === tKey) cells.push({r,c});
           }

           // Clear them with delay to simulate explosion
           clearCells(cells, {protectPower:true});
       }

       clearCells([{r:powerup.r,c:powerup.c}, {r:supernuss.r,c:supernuss.c}], {protectPower:true});
    }

    function activateLovelieCombo(powerupTile, lovelieTile){
       const pk = parseTypeId(powerupTile.type).baseKey;
       toast("LOVELIE POWER! üíñ", pk.toUpperCase()+" WAVE!", 3000);

       // Massive effect based on powerup
       if(pk === "worm"){
          // Turn 5 random tiles into worms and activate them?
          // Or just clear 5 random rows?
          // Let's clear 5 random rows.
          const rowsToClear = new Set();
          while(rowsToClear.size < 5) rowsToClear.add(Math.floor(Math.random()*rows));
          rowsToClear.forEach(r => clearRow(r));
       } else if(pk === "cit"){
          // 5 random Cit blasts
          for(let i=0;i<5;i++){
             citBlast(Math.floor(Math.random()*rows), Math.floor(Math.random()*cols), 3);
          }
       } else if(pk === "koala"){
          // Clear board + extra points
          clearWholeBoard();
          totalScore += 5000;
       }

       clearCells([{r:powerupTile.r, c:powerupTile.c}, {r:lovelieTile.r, c:lovelieTile.c}], {protectPower:true});
    }

    function resolveAll(initial=false, isPlayerSwap=false){
      busy = true; // Safety lock

      // Safety: Auto-reset busy if something hangs deep in recursion
      setTimeout(()=>{
         if(busy && !document.querySelector(".tile.dragging")) busy = false;
      }, 5000);

      let isFirstStep = true;
      // Boss AI Step (only if isPlayerSwap to count turns properly?)
      // User says "Attacke 2 Z√ºge vorher rot an".
      // We can check it at the start of resolution chain.
      if(isPlayerSwap){
        const zilla = findMellowZilla();
        if(zilla){
          zilla.turn = (zilla.turn || 0) + 1;
          const phase = zilla.turn % 4; // 1,2,3,0
          
          // Update visual frame (0,1,2,3 where 3 is attack)
          // phase 1-> frame 0
          // phase 2-> frame 1
          // phase 3-> frame 2
          // phase 0-> frame 3 (Attack)
          
          let frame = 0;
          if(phase === 2) frame = 1;
          if(phase === 3) frame = 2;
          if(phase === 0) frame = 3;
          
          zilla.animFrame = frame;
          refreshTileEl(zilla);

          const zName = (zilla.type==="koalazilla") ? "KoalaZilla" : "MellowZilla";
          const chooseTarget = ()=>{
            const baseR = lastPlayerMove ? lastPlayerMove.r : Math.floor(Math.random()*(rows-1));
            const baseC = lastPlayerMove ? lastPlayerMove.c : Math.floor(Math.random()*(cols-1));
            const rr = clamp(baseR-1, 0, rows-3);
            const cc = clamp(baseC-1, 0, cols-3);
            return {r: rr, c: cc};
          };

          if(phase === 2 || phase === 3){ // Warn
             const el = tileEls.get(zilla.id);
             if(el){
               el.style.boxShadow = "0 0 20px red"; // Subtle red glow
             }
             if(!zillaPlanned) zillaPlanned = chooseTarget();
             if(phase===3 && zillaPlanned) showAttackPreview(zillaPlanned.r, zillaPlanned.c);
             toast(`${zName} l√§dt auf...`, "Attacke bald!", 1500);
          } else if(phase === 0 && zilla.turn > 0){ // Attack
             toast(`${zName} ATTACKE!`, "3x3 Wipe! üí•", 2600);
             const target = zillaPlanned || chooseTarget();
             clearAttackPreview();
             zillaPlanned = null;

             // Wipe
             const rr = target.r;
             const cc = target.c;
             const cells = [];
             for(let r=rr; r<rr+3; r++){
               for(let c=cc; c<cc+3; c++) cells.push({r,c});
             }
             clearCells(cells);

             // Reset visual
             const el = tileEls.get(zilla.id);
             if(el) el.style.boxShadow="none";
             
             zillaAttackCounter++;
             if(zillaAttackCounter % 3 === 0){
               dropDown();
               mergeMellows();
               ensureMovesOrShuffle();
             }
          } else {
             // Idle (phase 1)
             const el = tileEls.get(zilla.id);
             if(el) el.style.boxShadow="none";
             clearAttackPreview();
             zillaPlanned = null;
          }
        }
      }

      const step = ()=>{
       try {
        const specials = findSpecialQuads();
        const mm = findLineMatches();

        if(mm.clear.size===0 && specials.length===0){
          // Sicherstellen, dass das Board nach Level-Ups weiter spielbar bleibt
          ensureMovesOrShuffle();
          busy=false;
          layoutBoard(); // Force sync visual positions to fix drag bugs
          updateUI();
          return;
        }

        combo = clamp(combo+1, 1, 999);

        let acceptedSpecials = specials;
        // User requested: Special combos only on player swap to prevent loops
        // Only accept specials on the VERY FIRST step of a player swap.
        // Cascades (isFirstStep=false) should not trigger specials.
        if(!isPlayerSwap || !isFirstStep) acceptedSpecials = [];

        // EXIT if acceptedSpecials is empty AND mm.clear is empty
        // This prevents infinite loop if 'specials' are found (so loop continues)
        // but 'acceptedSpecials' is empty (so nothing is cleared),
        // and 'mm.clear' is empty.
        if(acceptedSpecials.length === 0 && mm.clear.size === 0){
           busy=false;
           layoutBoard(); // Force sync
           updateUI();
           ensureMovesOrShuffle();
           return;
        }

      if(acceptedSpecials.length){
        for(const sp of acceptedSpecials){
          const center = sp.cells[Math.floor(sp.cells.length/2)];
          const ctr = tileCenter(center.r, center.c);
            burstFx(ctr.x, ctr.y, 14);

            if(sp.kind==="moonshuffle"){
              toast("üåôüò¥ Mond-Shuffle!", "4√ó4 Bereich ‚ú®", 3200);
              clearCells(sp.cells);
              shuffleArea4x4(center.r, center.c);
              continue;
            }

            if(sp.kind==="therapy"){
              toast("ü©π Therapy Time!", "+3 Moves ‚ú®", 3200);
              moves += 3;
              // Tripel entfernen, damit es NICHT erneut triggert
              clearCells(sp.cells);

              // Alle Grumpy -> Happy (Therapie Effekt)
              for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                  const t=grid[r][c];
                  if(!t) continue;
                  const p=parseTypeId(t.type);
                  if(p.baseKey==="grumpy"){
                    t.type = typeId("happy", p.variant);
                    refreshTileEl(t);
                  }
                }
              }
              continue;
            }

            if(sp.kind==="sprinkle"){
              toast("üç©‚ú® Sprinkle Beam!", "Beam Clear!", 3200);
              clearCells(sp.cells);
              const rr=center.r, cc=center.c;
              const beam = [];
              for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
                if(inBounds(rr, cc+d)) beam.push({r:rr,c:cc+d});
                if(inBounds(rr+d, cc)) beam.push({r:rr+d,c:cc});
                if(inBounds(rr+d, cc+d)) beam.push({r:rr+d,c:cc+d});
                if(inBounds(rr+d, cc-d)) beam.push({r:rr+d,c:cc-d});
              }
              clearCells(beam);
              continue;
            }

            if(sp.kind==="sugar"){
              toast("üç¨ Sugar Rush!", "+5 Moves & Clears!", 3400);
              moves += 5;
              clearCells(sp.cells);
              const picks = [];
              for(let i=0;i<14;i++){
                const r=Math.floor(Math.random()*rows);
                const c=Math.floor(Math.random()*cols);
                picks.push({r,c});
              }
              clearCells(picks);
              continue;
            }

            if(sp.kind==="buddies"){
              toast("üê±üê∂ Buddy Burst!", "Boom!", 3200);
              const area=[];
              for(const p of sp.cells){
                for(let dr=-1; dr<=1; dr++){
                  for(let dc=-1; dc<=1; dc++){
                    const rr=p.r+dr, cc=p.c+dc;
                    if(inBounds(rr,cc)) area.push({r:rr,c:cc});
                  }
                }
              }
              clearCells(sp.cells);
              clearCells(area);
              continue;
            }

            if(sp.kind==="bestbuddies"){
              toast("ü¶Åüê± BEST BUDDIES!", "Buddy Wave ‚ú®", 3400);
              clearCells(sp.cells);

              // Row+Col vom Center + extra Punkte
              clearRow(center.r);
              clearCol(center.c);
              totalScore += Math.round(1200*diff.scoreMult);
              levelScore += Math.round(1200*diff.scoreMult);
              continue;
            }
          }

          setTimeout(()=>{
            dropDown();
            mergeMellows();
            setTimeout(step, 450); // Increased delay to prevent ghost combos
          }, 240);
          checkLevelUp();
          updateUI();
          return;
        }

        // Check for Fledernuss runs in mm.hRuns/vRuns
        const allRuns = [...(mm.hRuns||[]), ...(mm.vRuns||[])];
        for(const run of allRuns){
          const first = run.cells[0];
          const t = grid[first.r][first.c];
          if(t){
            const bk = parseTypeId(t.type).baseKey;
            if(bk==="fledernuss"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"flederheld:A"});
               // prevent clearing the spawn spot? Logic below handles it:
               // "if(old) remove... grid[r][c]=t"
            } else if(bk==="flederheld"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"supernuss:A"});
            } else if(bk==="supernuss"){
               // Explosion
               const mid = run.cells[Math.floor(run.cells.length/2)];
               toast("SUPER NUSS!", "BOOM!", 2000);
               burstFx(tileCenter(mid.r, mid.c).x, tileCenter(mid.r, mid.c).y, 20);
               // Add extra clear radius 2
               const blast = [];
               for(let rr=mid.r-2; rr<=mid.r+2; rr++){
                 for(let cc=mid.c-2; cc<=mid.c+2; cc++){
                   if(inBounds(rr,cc)) blast.push({r:rr,c:cc});
                 }
               }
               clearCells(blast); // Immediate clear
            }
          }
        }

        const toClear = new Set(mm.clear);
        // Remove spawns from clear set
        for(const [k] of mm.spawn) toClear.delete(k);

        const scoreAdd = toClear.size * scorePerTile() * (1 + (combo-1)*0.12);
        totalScore += Math.round(scoreAdd);
        levelScore += Math.round(scoreAdd);

        if(toClear.size > 0){
           // show combo GIF on every cleared tile (text only once on the center tile when combo>1)
           const cells = Array.from(toClear).map(k=>{
             const [rr,cc] = k.split(",").map(Number);
             return {r:rr, c:cc};
           });

           // pick a "center" tile for the score text
           let avgR = 0, avgC = 0;
           for(const p of cells){ avgR += p.r; avgC += p.c; }
           avgR /= cells.length; avgC /= cells.length;

           let center = cells[0];
           let bestD = 1e9;
           for(const p of cells){
             const d = (p.r-avgR)*(p.r-avgR) + (p.c-avgC)*(p.c-avgC);
             if(d < bestD){ bestD = d; center = p; }
           }

           const scoreTxt = (combo > 1) ? Math.round(scoreAdd) : null;

           for(const p of cells){
             const showTxt = scoreTxt != null && p === center;
             showComboAnim(showTxt ? scoreTxt : null, p.r, p.c);
           }
        }
const clearedCells = [];

        for(const key of toClear){
          const [r,c] = key.split(",").map(Number);
          const t = grid[r][c];
          if(!t) continue;

          if(hitMellowAt(r,c,1)) continue;

          const el = tileEls.get(t.id);
          if(el){
            el.classList.add("pop");
            const ctr = tileCenter(r,c);
            makeStar(ctr.x, ctr.y, true);
            burstFx(ctr.x, ctr.y, 8); // Extra glitter
            setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
          }
          grid[r][c]=null;
          clearedCells.push({r,c});
        }

        damageMellowsAround(clearedCells);

        // Fledernuss Evolution Logic
        // Check if any match was Fledernuss chain
        const alreadyEvolved = new Set();

        for(const [key, s] of mm.spawn){
           // Normal spawn logic (Cit, Worm, Koala)
           const [r,c]=key.split(",").map(Number);
           const old = grid[r][c];
           if(old){
             const oldEl = tileEls.get(old.id);
             if(oldEl) oldEl.remove();
             tileEls.delete(old.id);
           }
           const t = makeTile(r,c,s.type);
           grid[r][c]=t;
           const el = createTileEl(t, false);
           el.classList.add("spawnGlow");
           tileEls.set(t.id, el);
           ui.board.appendChild(el);
           const ctr = tileCenter(r,c);
           makeStar(ctr.x, ctr.y, true);
        }

        // Custom Evolution handling
        // For each cleared cell, check if it was part of a Fledernuss match
        // But mm.clear doesn't tell us the type.
        // We iterate matches in mm.
        // findLineMatches returned 'hRuns' and 'vRuns' internally but only returned clear/spawn sets.
        // We need to intercept the match types.

        // Let's re-scan the cleared cells to see what they were? No they are null now.
        // We should have intercepted before clearing.
        // Refactor resolveAll slightly? Or just look at the 'toClear' set before we nulled them.
        // 'clearedCells' contains the coords. But we need types.
        // 'grid' is already nulled.
        // Wait, the block above:
        // const t = grid[r][c]; ... grid[r][c]=null;
        // inside that loop we have access to 't'.

        // I will add the logic inside the clearing loop.
        /*
          const old = grid[r][c];
          if(old){
            const oldEl = tileEls.get(old.id);
            if(oldEl) oldEl.remove();
            tileEls.delete(old.id);
          }

          const t = makeTile(r,c,s.type);
          grid[r][c]=t;
          const el = createTileEl(t, false);
          el.classList.add("spawnGlow");
          tileEls.set(t.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          makeStar(ctr.x, ctr.y, true);
        */

        setTimeout(()=>{
          dropDown();
          mergeMellows();
          isFirstStep = false;
          // Add timeout limit for safety?
          setTimeout(step, 420); // Increased delay to prevent ghost combos
        }, 240);
        checkLevelUp();
        updateUI();
       } catch(e) {
         console.error("Game Logic Error:", e);
         busy = false;
       }
      };

      // Safety: If step crashes or hangs, reset busy after 5s?
      // But step() is recursive.
      // We can just rely on step() logic.
      try{
        step();
      }catch(e){
        console.error(e);
        busy=false;
      }
    }

    function shuffleArea4x4(centerR, centerC){
      const top = clamp(centerR-1, 0, rows-4);
      const left= clamp(centerC-1, 0, cols-4);

      const coords=[];
      const tiles=[];
      for(let r=top;r<top+4;r++){
        for(let c=left;c<left+4;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk=parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }

      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }

      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function dropDown(){
      for(let c=0;c<cols;c++){
        let r = rows-1;
        while(r>=0){
          while(r>=0 && isBlocker(grid[r][c])) r--;
          if(r<0) break;

          const segEnd = r;
          let segStart = segEnd;
          while(segStart>=0 && !isBlocker(grid[segStart][c])) segStart--;

          let write = segEnd;
          for(let rr=segEnd; rr>=segStart+1; rr--){
            const t = grid[rr][c];
            if(t){
              if(write !== rr){
                grid[write][c]=t;
                grid[rr][c]=null;
                t.r=write; t.c=c;
                const el = tileEls.get(t.id);
                if(el) setTileXY(el, t.r, t.c);
              }
              write--;
            }
          }

          for(let rr=write; rr>=segStart+1; rr--){
            let tType = randNormalType();
            if(level >= 2 && Math.random() < diff.mystChance){
              tType = "myst:P";
            }
            const t = makeTile(rr,c,tType);
            grid[rr][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }

          r = segStart;
        }
      }

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(grid[r][c]===null){
            const t = makeTile(r,c,randNormalType());
            grid[r][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }
        }
      }

      if(Math.random() < diff.lovelieChance*0.45){
        maybeSpawnLovelie();
      }

      // After gravity settles, auto-resolve if matches are still present (failsafe for stuck boards)
      setTimeout(()=>{
        if(busy) return;
        const pending = findLineMatches();
        const specials = findSpecialQuads();
        if((pending?.clear?.size||0) > 0 || (specials?.length||0) > 0){
          resolveAll(false, false);
        }
      }, 40);
    }

    function mergeMellows(){
      for(let r=0;r<rows-1;r++){
        for(let c=0;c<cols-1;c++){
          const a = grid[r][c];
          const b = grid[r][c+1];
          const d = grid[r+1][c];
          const e = grid[r+1][c+1];
          if(!a||!b||!d||!e) continue;

          if(isPlaceholder(a)||isPlaceholder(b)||isPlaceholder(d)||isPlaceholder(e)) continue;

          const ak = parseTypeId(a.type).baseKey;
          const bk = parseTypeId(b.type).baseKey;
          const dk = parseTypeId(d.type).baseKey;
          const ek = parseTypeId(e.type).baseKey;

          if(ak!=="mellow" || bk!=="mellow" || dk!=="mellow" || ek!=="mellow") continue;
          if(a.big || b.big || d.big || e.big) continue;

          const hpSum = (a.hp||0) + (b.hp||0) + (d.hp||0) + (e.hp||0);
          const bigHp = 15; // Fixed HP for MellowLord

          [a,b,d,e].forEach(t=>{
            const el = tileEls.get(t.id);
            if(el){ el.remove(); tileEls.delete(t.id); }
          });
          const bigId = makeId();
          // MellowLord uses special type
          const bigTile = { id: bigId, r, c, type: "mellowlord:P", hp: bigHp, big:true };
          bigMellows.set(bigId, {id:bigId, r, c, hp:bigHp, type:"mellowlord"});

          grid[r][c] = bigTile;
          grid[r][c+1] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c+1] = { type:"mellow_part", partOf: bigId };

          const el = createTileEl(bigTile, false);
          el.classList.add("spawnGlow");
          tileEls.set(bigTile.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          burstFx(ctr.x + (CELL+GAP)/2, ctr.y + (CELL+GAP)/2, 25);
          // Peng Peng Glitter
          for(let i=0;i<5;i++){
             setTimeout(()=>makeStar(ctr.x + (Math.random()*60-30), ctr.y + (Math.random()*60-30), true), i*100);
          }
          toast("Mellowlord! üòà","4 Mellows verschmelzen!", 2800);
          setTileXY(el, r, c);
        }
      }
      checkMellowlordFusion();
    }

    function findMellowZilla(){
      for(const [id, m] of bigMellows){
        if(m.type === "mellowzilla" || m.type === "koalazilla") return m;
      }
      return null;
    }

    function clearAttackPreview(){
      const fx = document.getElementById("fxLayer");
      if(!fx) return;
      fx.querySelectorAll(".attackWarn").forEach(el=>el.remove());
    }
    function showAttackPreview(rr, cc){
      const fx = document.getElementById("fxLayer");
      if(!fx) return;
      clearAttackPreview();
      const size = CELL;
      for(let r=rr; r<rr+3; r++){
        for(let c=cc; c<cc+3; c++){
          if(!inBounds(r,c)) continue;
          const warn = document.createElement("div");
          warn.className = "attackWarn";
          warn.style.left = (PAD + c*(CELL+GAP)) + "px";
          warn.style.top  = (PAD + r*(CELL+GAP)) + "px";
          warn.style.width = size + "px";
          warn.style.height = size + "px";
          fx.appendChild(warn);
        }
      }
    }

    function placeZillaAt(centerR, centerC, zType="mellowzilla", hp=100, setBoss=true){
      const bigId = makeId();
      const zilla = { id: bigId, r: centerR, c: centerC, type: `${zType}:P`, hp: hp, big:true, zilla:true };

      for(let r=centerR; r<centerR+3; r++){
        for(let c=centerC; c<centerC+3; c++){
           if(inBounds(r,c)){
             const t = grid[r][c];
             if(t){
               const el = tileEls.get(t.id);
               if(el) el.remove();
               tileEls.delete(t.id);
             }
             grid[r][c] = { type:"mellow_part", partOf: bigId };
           }
        }
      }

      // Anchor
      grid[centerR][centerC] = zilla;
      bigMellows.set(bigId, {id:bigId, r:centerR, c:centerC, hp:hp, type:zType});

      const el = createTileEl(zilla, false);
      el.classList.add("spawnGlow");
      // Scale for 3x3
      el.style.width = `calc(var(--cell) * 3 + var(--gap) * 2)`;
      el.style.height = `calc(var(--cell) * 3 + var(--gap) * 2)`;

      tileEls.set(zilla.id, el);
      ui.board.appendChild(el);
      setTileXY(el, centerR, centerC);

      if(setBoss){
        bossFight = { active:true, type:zType, hp:hp, spawnLevel: level, deadlineLevel: level + 5 };
        zillaAttackCounter = 0;
        zillaPlanned = null;
      }
      toast(zType==="mellowzilla" ? "MELLOW ZILLA!! ü¶ñ" : "KOALA ZILLA!! üê®ü¶ñ", "Boss Fight!", 4000);
      return zilla;
    }

    function spawnMellowZilla(){
      if(level < 20) return;
      if(level % 20 !== 0) return;

      // Random alternate: KoalaZilla <-> MellowZilla (avoid same twice in a row)
      let zType = (Math.random() < 0.5) ? "mellowzilla" : "koalazilla";
      if(lastZillaType && zType === lastZillaType){
        zType = (zType === "mellowzilla") ? "koalazilla" : "mellowzilla";
      }
      lastZillaType = zType;

      const cr = Math.floor(rows/2)-1;
      const cc = Math.floor(cols/2)-1;
      placeZillaAt(cr, cc, zType, 100, true);
    }

    function shiftMellowZilla(zilla){
      // Shift center by 2 blocks? Or move Zilla?
      // User: "Mitte verschieben um 2 Bl√∂cke"
      // Let's assume shuffling the center or moving Zilla.
      // Moving Zilla is hard if board is full.
      // Let's shuffle the board AROUND Zilla.
      shuffleAll();
      toast("Zilla Roar!", "Alles geshuffelt!", 2000);
    }

    function removeBigMellow(bigId){
      const big = bigMellows.get(bigId);
      if(!big) return;
      bigMellows.delete(bigId);

      const anchor = grid[big.r][big.c];
      if(anchor && anchor.id){
        const el = tileEls.get(anchor.id);
        if(el){
          // Show Death Animation
          if(big.type.includes("mellowzilla") || big.type.includes("koalazilla") || big.type.includes("mellowlord")){
             showDeathAnim(big.r + (big.type.includes("zilla") ? 1.5 : 1), big.c + (big.type.includes("zilla") ? 1.5 : 1));
          }
          el.classList.add("pop");
          setTimeout(()=>{ el.remove(); tileEls.delete(anchor.id); }, 420);
        }
      }

      // Boss Check for points
      if(big.type.includes("mellowzilla") || big.type.includes("koalazilla")){

        // KOALA_BOSSFIGHT_CLEAR: Boss besiegt -> Timer stoppen
        try{ if(bossFight && bossFight.active){ bossFight.active=false; bossFight=null; } }catch(e){}
        clearAttackPreview();
        const bonus = 20000;
        totalScore += bonus;
        levelScore += bonus;
        if(big.type === "mellowzilla"){
          toast("MELLOW ZILLA BESIEGT! üèÜ", "+20.000 PUNKTE!", 4000);
        } else {
          toast("KOALA ZILLA BESIEGT! üèÜ", "+20.000 PUNKTE!", 4000);
        }
      } else {
        toast("Mellow gel√∂st! ‚ú®","Nice!", 2600);
      }

      const size = (big.type==="mellowzilla" || big.type==="koalazilla") ? 3 : 2;
      for(let rLoop=big.r; rLoop<big.r+size; rLoop++){
        for(let cLoop=big.c; cLoop<big.c+size; cLoop++){
          if(!inBounds(rLoop,cLoop)) continue;
          const t = grid[rLoop][cLoop];
          if(t && isPlaceholder(t) && t.partOf===bigId) grid[rLoop][cLoop]=null;
          if(t && t.id===bigId) grid[rLoop][cLoop]=null;
        }
      }
    }

    function checkMellowlordFusion(){
      const anchorMap = new Map();
      for(const [id, m] of bigMellows){
        if(m.type==="mellowlord") anchorMap.set(posKey(m.r,m.c), id);
      }
      const processed = new Set();
      for(const key of anchorMap.keys()){
        if(processed.has(key)) continue;
        const [r,c] = key.split(",").map(Number);
        const needed = [
          posKey(r,c),
          posKey(r,c+2),
          posKey(r+2,c),
          posKey(r+2,c+2)
        ];
        if(needed.every(k=>anchorMap.has(k))){
          needed.forEach(k=>processed.add(k));
          // remove old mellowlords
          const ids = needed.map(k=>anchorMap.get(k));
          ids.forEach(id=>{
            const info = bigMellows.get(id);
            if(!info) return;
            for(let rr=info.r; rr<info.r+2; rr++){
              for(let cc=info.c; cc<info.c+2; cc++){
                const t=grid[rr][cc];
                if(t && t.id===id){
                  const el = tileEls.get(t.id);
                  if(el){ el.remove(); tileEls.delete(t.id); }
                }
                grid[rr][cc]=null;
              }
            }
            bigMellows.delete(id);
          });
          const centerR = r+1, centerC = c+1;
          placeZillaAt(centerR, centerC, "mellowzilla", 80, true);
          toast("MellowZilla entsteht!","4 Mellowlords fusionieren!", 3600);
        }
      }
    }

    function hasMove(){
      if(!isGridReady()) return false;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          // Free move logic: if t is mellow, it's always movable
          const isMellow = parseTypeId(t.type).baseKey === "mellow";

          const dirs=[[1,0],[0,1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            if(isMellow) return true;
            const uIsMellow = parseTypeId(u.type).baseKey === "mellow";
            if(uIsMellow) return true;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok) return true;
          }
        }
      }
      return false;
    }

    function shuffleAll(){
      const coords=[];
      const tiles=[];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk = parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }
      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }
      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function ensurePlayableBoard(maxShuffles=6, autoResolve=true){
      if(!isGridReady()) return true; // defer shuffling until board exists
      try{ if(typeof pruneOrphanTileEls === "function") pruneOrphanTileEls(); }catch(e){}
      let tries = 0;
      while(tries < maxShuffles){
        if(hasAnyMatchOrSpecial()){
          if(autoResolve && !busy) resolveAll(false, false);
          return true; // immediate clearable match/special
        }
        if(hasMove()) return true;              // at least one possible swap-to-match
        shuffleAll();
        tries++;
      }
      return false;
    }

    function ensureMovesOrShuffle(){
      if(ensurePlayableBoard()) return;
      // Fallback: still stuck? force one last shuffle and try resolving
      shuffleAll();
      layoutBoard();
      setTimeout(()=>resolveAll(false, false), 60);
    }

    // Idle watchdog: if matches exist while not busy, auto-resolve to prevent stuck boards
    setInterval(()=>{
      if(busy) return;
      if(hasAnyMatchOrSpecial()){
        resolveAll(false, false);
      }
    }, 520);

    function hint(){
      
      // KOALA_HINT_COST_MOVE: Hint kostet 1 Move
      if(typeof moves !== 'undefined'){
        if(moves<=0){ try{ toast('Keine Moves mehr!','',1800); }catch(e){} return; }
        try{ spendMoves(1); }catch(e){}
        try{ updateUI(); }catch(e){}
      }
clearHints();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok){
              const el1=tileEls.get(t.id);
              const el2=tileEls.get(u.id);
              if(el1) el1.classList.add("hint");
              if(el2) el2.classList.add("hint");
              toast("Hint ‚ú®","Probier die zwei!", 3000);
              return;
            }
          }
        }
      }
      toast("Keine direkten Matches üòµ","Du kannst trotzdem frei swappen (Setup-Move).", 3200);
      // Recovery: resync layout to avoid rare input deadlocks / stray tiles
      try{ busy=false; }catch(e){}
      try{ layoutBoard(); pruneOrphanTileEls(); updateUI(); }catch(e){}
      clearHints();
    }

    async function toggleFullscreen(){
      const root = document.getElementById("playArea");
      try{
        if(document.fullscreenElement){
          await document.exitFullscreen();
        }else{
          await root.requestFullscreen();
        }
      }catch(e){}
    }
    document.addEventListener("fullscreenchange", ()=>{
      if(document.fullscreenElement){
        document.body.classList.add("fs");
        buildFsBg();
      }else{
        document.body.classList.remove("fs");
        document.body.classList.remove("maximized");
        document.getElementById("fsBg").innerHTML="";
      }
      layoutBoard();
    });

    function updateUI(){
      ui.level.textContent = level;
      ui.goal.textContent = fmt(target);
      ui.score.textContent = fmt(totalScore);
      ui.moves.textContent = moves;
      ui.combo.textContent = "x"+combo;

      const pct = clamp(Math.round((levelScore/target)*100), 0, 100);
      ui.bar.style.width = pct+"%";
      ui.pct.textContent = pct+"%";

      ui.hudLevel.textContent = "Level "+level;
      ui.hudScore.textContent = "Score "+fmt(totalScore);
      ui.hudMoves.textContent = "Moves "+moves;
      ui.hudCombo.textContent = "Combo x"+combo;
      ui.hudBar.style.width = pct+"%";
      ui.hudPct.textContent = pct+"%";
    
      // Maximize HUD mirror
      const ml = document.getElementById("maxLvl");
      const ms = document.getElementById("maxScore");
      const mm = document.getElementById("maxMoves");
      const mc = document.getElementById("maxCombo");
      if(ml) ml.textContent = level;
      if(ms) ms.textContent = fmt(totalScore);
      if(mm) mm.textContent = moves;
      if(mc) mc.textContent = "x"+combo;
    }

    function checkLevelUp(){
      if(levelScore >= target){
        level++;

        // KOALA_BOSS_DEADLINE_CHECK: Option 2 -> Wenn Boss noch lebt und Deadline √ºberschritten -> Game Over
        try{
          if(bossFight && bossFight.active && bossFight.hp > 0 && level > bossFight.deadlineLevel){
            toast('Boss entkommen üò±', 'Du hattest bis Level '+bossFight.deadlineLevel+' Zeit!', 4200);
            moves = 0;
            updateUI();
            setTimeout(()=>gameOver(), 400);
            return;
          }
        }catch(e){}
        levelScore = 0;
        maybeUnlockVariant();
        refreshActivePool(); // Recalculate allowed colors

        target = calcTarget(level);
        moves = calcMoves(level);

        toast("üéâ Ziel erreicht!","Next Level: "+level, 3200);
        spawnMellow();
        spawnMellowZilla(); // Check if Boss level
        maybeSpawnLovelie();
      }
    }

    function gameOver(){
      // Show dedicated Game Over Modal
      document.getElementById("goScore").textContent = fmt(totalScore);

      const saved = getCookie("luvvies_name");
      document.getElementById("goName").value = saved || document.getElementById("lbName").value || document.getElementById("greetName").value || "";

      document.getElementById("gameOverBack").style.display = "flex";

      // Auto-fill lbName if changed
      document.getElementById("lbName").value = document.getElementById("goName").value;

      // Auto-post (optional)
      try{
        const auto = document.getElementById("lbAuto")?.checked;
        const nm = (document.getElementById("lbName").value || "").trim();
        if(auto && nm && !autoPostDone){
          autoPostDone = true;
          setTimeout(()=>postScore(), 180);
        }
      }catch(e){}
    }

    // Game Over Buttons
    document.getElementById("goNew").addEventListener("click", ()=>{
      document.getElementById("gameOverBack").style.display = "none";
      newGame(false);
    });
    document.getElementById("goPost").addEventListener("click", async ()=>{
       // Sync name
       const n = document.getElementById("goName").value;
       document.getElementById("lbName").value = n;
       await postScore();
       document.getElementById("gameOverBack").style.display = "none";
       newGame(false);
    });

    function newGame(fromDiffChange=false){
      busy=false;
      autoPostDone=false;
      level=1;
      totalScore=0;
      levelScore=0;
      combo=1;
      mellowFreeMoves = 10;
      resetUnlocked();
      target = calcTarget(level);
      moves = calcMoves(level);
      lastSwap=null;

      // Determine active pool for this game (based on difficulty)
      // Recalculate if level goes up?
      // If we limit colors, new characters won't appear.
      // Maybe we shouldn't limit statically.
      // But 8x8 with 10 colors is unplayable.
      // Strategy: On initBoard, we set the pool.
      // But BASES changes with Level (minLevel).
      // We will handle pool logic dynamically but cap the count.
      // Actually, simplest is: select Max N types from available.
      // Which ones?
      // Always basics + current "featured" ones?
      // Let's implement `refreshActivePool()` called on Level Up.
      refreshActivePool();

      initBoard();
      buildMenu();
      updateUI();
      refreshLeaderboard();
      if(!fromDiffChange){
        toast("Neues Spiel ‚ú®", diff.name+" ‚Ä¢ "+diff.rows+"√ó"+diff.cols, 2600);
      }
      syncLbHeight();
    }

    /**********************
     * Menu + Steckbrief
     **********************/
    function buildMenu(){
      ui.menu.innerHTML="";
      const menuGrid = document.getElementById("menuLuvGrid");
      if(menuGrid) menuGrid.innerHTML="";

      const all = [...BASES,
        {key:"myst",name:"???",img:null,tag:"powerup",ability:"Klicken ‚Üí random Reveal (Puff!)",story:"Mystery ist Gl√ºck + Rarity.",lines:{easy:["???","Puff ‚ú®","Gl√ºck!"],normal:["Reveal time.","Puff.","Random!"],hard:["Risk it.","Puff.","Roll!"],shock:["ALL IN üòà","Puff!","GAMBLE!"]}},
        {key:"worm",name:"Sourworm",img:IMG.worm,tag:"powerup",ability:"Reihe/Spalte (je nach Drag)",story:"Sauer, aber r√§umt sauber.",lines:{easy:["Chomp!","Weg damit!","Sauer!"],normal:["Line clear.","Crunch.","Nice."],hard:["Pr√§zise.","Perfekt.","Clean."],shock:["WELLE!","CRUNCH!","RIP Reihe!"]}},
        {key:"cit",name:"Citrussy",img:IMG.citrussy,tag:"powerup",ability:"Stern Radius 3 (8 Richtungen)",story:"Zitrus-Boom in alle Richtungen.",lines:{easy:["CIT!","Spritz!","Boom!"],normal:["Cross clear.","Zing!","Nice."],hard:["Setz‚Äôs gut.","Perfekt.","Value!"],shock:["ZITRUS-NUKE!","BOOM!","MEHR!"]}},
        {key:"koala",name:"Koala",img:IMG.koala,tag:"powerup",ability:"Koala+Sorte clear",story:"Boss-Magie: eine Sorte komplett weg.",lines:{easy:["Boss!","Magie!","Clean!"],normal:["Koala time.","Alles weg.","Nice."],hard:["Richtig w√§hlen.","Perfekt.","Carry."],shock:["BOSS MODE üòà","Wipe!","SWEET!"]}},
        {key:"mellow",name:"Mellow",img:IMG.mellow,tag:"obstacle",ability:"Block (3 HP) ‚Äì Clears daneben ziehen HP ab",story:"Klebt fest‚Ä¶ bis du ihn knackbar machst.",lines:{easy:["Kleb üòà","HP runter!","Block!"],normal:["Nicht ignorieren.","Knacken!","Weg!"],hard:["Gef√§hrlich.","Planen.","Ziel!"],shock:["BLOCK HELL üòà","RIP Moves","KNACKEN!"]}},
        {key:"lovelie",name:"Lovelie",img:IMG.lovelie,tag:"bonus",ability:"Ultra selten (Bonus)",story:"Wenn Lovelie kommt, lohnt‚Äôs sich.",lines:{easy:["OMG üíñ","So selten!","Bonus!"],normal:["Lovelie!","Lucky!","Nice."],hard:["Rare!","Take it.","Value!"],shock:["ULTRA RARE üíñ","LETS GO!","HYPE!"]}},
      ];

      const createCard = (b) => {
        const card=document.createElement("div");
        card.className="luvCard";
        // Give each Luvvie card a subtle unique background (helps recognition in the list)
        const base = getBase(b.key);
        const pal = (base && base.palettes && (base.palettes.A || base.palettes.B)) ? (base.palettes.A || base.palettes.B) : ["#ffffff","#f2f3ff"];
        card.classList.add("hasPal");
        card.style.setProperty("--c1", pal[0]);
        card.style.setProperty("--c2", pal[1]);
        const imgHtml = b.img ?
          `<img src="${b.img}" alt="${b.name}">` : `<div style="width:78px;height:78px;border-radius:18px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ff4fb9,#7ad8ff);color:#fff;font-weight:1000;font-size:32px;box-shadow:0 12px 20px rgba(0,0,0,.12);">?</div>`;
        card.innerHTML = `
          ${imgHtml}
          <div>
            <b>${b.name}</b>
            <small>${b.tag || "normal"}</small>
          </div>
        `;
        card.addEventListener("click", ()=>openInfo(b));
        return card;
      };

      for(const b of all){
        ui.menu.appendChild(createCard(b));
        if(menuGrid) menuGrid.appendChild(createCard(b));
      }
      syncLbHeight();
    }

    function openInfo(b){
      document.getElementById("infoImg").src = b.img || "";
      document.getElementById("infoImg").style.display = b.img ? "block" : "none";
      document.getElementById("infoName").textContent = b.name;
      document.getElementById("infoTag").textContent = (b.tag || "normal") + " ‚Ä¢ Varianten: A/B (ab Level 5)";
      document.getElementById("infoAbility").textContent = b.ability || "‚Äî";
      document.getElementById("infoStory").textContent = b.story || "‚Äî";

      const ul = document.getElementById("infoLines");
      ul.innerHTML="";
      const lines = (b.lines?.[diff.key] || b.lines?.easy || []).slice(0,3);
      for(const line of lines){
        const li=document.createElement("li");
        li.textContent=line;
        ul.appendChild(li);
      }
      document.getElementById("infoBack").style.display="flex";
    }

    /**********************
     * Leaderboard
     **********************/
    function cleanName(s){
      let out = s.replace(/[^a-zA-Z0-9\s√§√∂√º√Ñ√ñ√ú√ü!._-]/g, "");
      // Expanded Bad words filter
      const bad = [
        "hitler", "nazi", "arsch", "wichser", "hurensohn", "idiot", "dummbatz", "fuck", "bitch", "whore", "cunt", "nigger", "faggot", "fotze", "missgeburt", "bastard", "penis", "vagina", "sex", "anal"
      ];
      const lower = out.toLowerCase();
      // Whitelist
      if(lower.includes("koalaaufpillen")) return out;

      for(const b of bad){
        if(lower.includes(b)) return "***";
      }
      return out;
    }

    function getUuid(){
      let u = getCookie("luvvies_uuid");
      if(!u){
        try{ u = crypto.randomUUID(); }
        catch(e){ u = String(Date.now()) + "-" + Math.random().toString(16).slice(2); }
        setCookie("luvvies_uuid", u, 36500); // 100 years
      }
      return u;
    }

    // Current season = calendar quarter (resets every ~3 months)
    function currentSeasonStart(){
      // Returns { isoTs, dateStr, label }
      const now = new Date();
      const y = now.getUTCFullYear();
      const q = Math.floor(now.getUTCMonth() / 3);   // 0..3
      const m = q * 3;                               // 0,3,6,9
      const d = new Date(Date.UTC(y, m, 1, 0, 0, 0)); // quarter start
      const isoTs = d.toISOString();                 // for created_at filters
      const dateStr = isoTs.slice(0,10);             // YYYY-MM-DD for season_start (optional)
      const label = `Q${q+1} ${y}`;
      return { isoTs, dateStr, label };
    }

    async function postScore(){
      if(!sb){ toast("Leaderboard offline","(Supabase nicht erreichbar)", 3200); return; }

      let name = (document.getElementById("lbName").value || document.getElementById("goName").value || document.getElementById("greetName").value || "Anonymous").trim().slice(0,24);
      name = cleanName(name);

      // Save name + keep stable UUID (identity)
      setCookie("luvvies_name", name, 36500);
      const uuid = getUuid();
      localStorage.setItem("luvvies_last_name", name);

      // Season: current calendar quarter (‚âà 3 months)
      const season = currentSeasonStart();
      const seasonStartIso = season.isoTs;

      const payload = {
        player_name: name,
        score: totalScore,
        level: level,
        difficulty: diff.key,
        version:"luvvies-crush",
        user_id: uuid
      };

      try{
        // Find existing best for this UUID + difficulty inside current season window
        let best = null;
        try{
          const { data, error } = await sb
            .from(SCORE_TABLE)
            .select("id,score,created_at")
            .eq("user_id", uuid)
            .eq("difficulty", diff.key)
            .gte("created_at", seasonStartIso)
            .order("score", { ascending:false })
            .limit(1);

          if(error) throw error;
          best = (data && data[0]) ? data[0] : null;
        }catch(selErr){
          // Fallback if table has no "id" column: select without id
          const msg = String(selErr?.message || selErr);
          if(msg.toLowerCase().includes("column") && msg.toLowerCase().includes("id")){
            const { data, error } = await sb
              .from(SCORE_TABLE)
              .select("score,created_at")
              .eq("user_id", uuid)
              .eq("difficulty", diff.key)
              .gte("created_at", seasonStartIso)
              .order("score", { ascending:false })
              .limit(1);
            if(error) throw error;
            best = (data && data[0]) ? data[0] : null;
          } else {
            throw selErr;
          }
        }

        // If not better, don't spam inserts
        if(best && Number(payload.score) <= Number(best.score||0)){
          toast("Schon gespeichert ‚úÖ", `Bestscore (${diffLabel(diff.key)}): ${fmt(best.score)}`, 3200);
          await refreshLeaderboard();
          return;
        }

        // Update if possible; otherwise insert
        if(best && best.id){
          const { error } = await sb.from(SCORE_TABLE).update(payload).eq("id", best.id);
          if(error) throw error;
          toast("Bestscore aktualisiert ‚úÖ", name+" ‚Ä¢ "+fmt(totalScore), 3200);
        } else if(best && !best.id){
          // Without an id, update the newest season rows for this uuid+diff (keeps single identity, even if duplicates exist)
          const { error } = await sb
            .from(SCORE_TABLE)
            .update(payload)
            .eq("user_id", uuid)
            .eq("difficulty", diff.key)
            .gte("created_at", seasonStartIso);
          if(error) throw error;
          toast("Bestscore aktualisiert ‚úÖ", name+" ‚Ä¢ "+fmt(totalScore), 3200);
        } else {
          const { error } = await sb.from(SCORE_TABLE).insert(payload);
          if(error) throw error;
          toast("Score gepostet ‚úÖ", name+" ‚Ä¢ "+fmt(totalScore), 3200);
        }

        await refreshLeaderboard();
      }catch(e){
        toast("Post fehlgeschlagen ‚ùå", String(e.message||e), 3400);
      }
    }

    function demoLeaderboardRows(diffKey){
      const now = new Date().toISOString();
      return [
        { player_name:"CandyQueen", score:184200, level:14, difficulty:diffKey, created_at:now, user_id:"demo-1" },
        { player_name:"KoalaChamp", score:152880, level:13, difficulty:diffKey, created_at:now, user_id:"demo-2" },
        { player_name:"LuvMaster", score:120440, level:12, difficulty:diffKey, created_at:now, user_id:"demo-3" },
        { player_name:"BubbleBuddy", score:84400, level:10, difficulty:diffKey, created_at:now, user_id:"demo-4" },
        { player_name:"Sourworm", score:64200, level:9, difficulty:diffKey, created_at:now, user_id:"demo-5" }
      ];
    }

    function renderLeaderboardRows(rows, note){
      const list = document.getElementById("lbList");
      list.innerHTML = "";
      // Ensure we always have visible podium rows
      const padded = [...rows];
      const demo = demoLeaderboardRows(rows[0]?.difficulty || diff.key);
      while(padded.length < 3 && demo.length){
        padded.push(demo[padded.length % demo.length]);
      }

      padded.forEach((x,i)=>{
        const item = document.createElement("div");
        item.className="lbItem";
        item.style.animationDelay = (i * 0.05) + "s";
        if(i===0) item.classList.add("rank1");
        if(i===1) item.classList.add("rank2");
        if(i===2) item.classList.add("rank3");

        const rankNum = i+1;
        const d = new Date(x.created_at || Date.now());
        const stamp = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.${d.getFullYear()} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
        item.innerHTML = `
          <div class="left">
            <b>${rankNum}. ${escapeHtml(x.player_name||"Anonymous")}</b>
            <small>Lvl ${x.level||1} ‚Ä¢ ${diffLabel(x.difficulty||"easy")} ‚Ä¢ ${stamp}</small>
          </div>
          <div class="score">${fmt(x.score||0)}</div>
        `;
        list.appendChild(item);
      });
      if(note){
        const info = document.createElement("div");
        info.className = "tiny";
        info.style.marginTop = "6px";
        info.textContent = note;
        list.appendChild(info);
      }
    }

    async function refreshLeaderboard(){
      const list = document.getElementById("lbList");
      const sel = document.getElementById("lbDiffSelect");
      // Prefer leaderboard tabs (lbDiff radios), fallback to hidden select, fallback to current game diff
      let dKey = document.querySelector('input[name="lbDiff"]:checked')?.value || (sel ? sel.value : diff.key);

      const season = currentSeasonStart();

      const title = document.getElementById("lbTitle");
      if(title) title.textContent = "Leaderboard ‚Ä¢ " + season.label;

      if(!sb){
        renderLeaderboardRows(demoLeaderboardRows(dKey), "Leaderboard aktuell nicht verf√ºgbar ‚Äì zeige Demo-Eintr√§ge.");
        return;
      }
      try{
        // Filter by selected difficulty
        const { data, error } = await sb
          .from(SCORE_TABLE)
          .select("player_name,score,level,difficulty,created_at,user_id")
          .eq('difficulty', dKey)
          .gte('created_at', season.isoTs)
          .order("score", { ascending:false })
          .limit(80);
        if(error) throw error;

        // Filter unique by UUID
        const unique = [];
        const seen = new Set();
        for(const row of (data||[])){
           const key = row.user_id || row.player_uuid || (row.player_name||"").toLowerCase();
           if(seen.has(key)) continue;
           seen.add(key);
           unique.push(row);
           if(unique.length >= 25) break;
        }

        if(!data || data.length===0 || unique.length===0){
          renderLeaderboardRows(demoLeaderboardRows(dKey), "Noch keine Scores ‚Äì Demo-Eintr√§ge aktiviert. Poste deinen ersten Run!");
        } else {
          renderLeaderboardRows(unique, "");
        }
      }catch(e){
        const msg = String(e?.message || e || "Unbekannter Fehler");
        console.error("Leaderboard error:", e);
        renderLeaderboardRows(demoLeaderboardRows(dKey), "Leaderboard Fehler: "+escapeHtml(msg)+" (zeige Demo)");
      }
      syncLbHeight();
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    /**********************
     * Make Leaderboard same height as luvvies panel
     **********************/
    function syncLbHeight(){
      // Disabled
    }

    /**********************
     * Intro/Greet events
     **********************/
    function showGreetingIfNeeded(){
      // Show greeting about every 3 hours per device/UUID (instead of once per day)
      // This reduces "daily popups" while still keeping the welcome screen alive.
      try{ getUuid(); }catch(e){}
      const k = "luvvies_greet_ts";
      const last = Number(localStorage.getItem(k) || getCookie(k) || 0);
      const now = Date.now();
      const interval = 3 * 60 * 60 * 1000; // 3h
      if(!last || (now - last) > interval){
        document.getElementById("greetBack").style.display="flex";
      }
    }
    function closeGreeting(updateTs=true){
      if(updateTs){
        const k = "luvvies_greet_ts";
        const now = Date.now();
        localStorage.setItem(k, String(now));
        setCookie(k, String(now), 36500); // keep long-term
      }
      document.getElementById("greetBack").style.display="none";
    }

    document.getElementById("greetPlay").addEventListener("click", ()=>{
      closeGreeting(true);
      toast("Let‚Äôs go! ‚ú®","Viel Spa√ü!", 2600);
    });
    document.getElementById("greetGuide").addEventListener("click", ()=>{
      closeGreeting(true);
      document.getElementById("introBack").style.display="flex";
    });

    document.getElementById("introClose").addEventListener("click", ()=>document.getElementById("introBack").style.display="none");
    document.getElementById("infoClose").addEventListener("click", ()=>document.getElementById("infoBack").style.display="none");

    /**********************
     * Buttons & Menu
     **********************/
    // Old listeners removed (btnNew, btnHint etc replaced by menu versions)

    // Main Menu Trigger
    const btnHintTop = document.getElementById("btnHintTop");
    if(btnHintTop) btnHintTop.addEventListener("click", hint);

    document.getElementById("btnMenu").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "flex";
    });
    document.getElementById("menuClose").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
    });

    // Menu Actions
    document.getElementById("menuNew").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       newGame(false);
    });
    document.getElementById("menuHint").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       hint();
    });
    const mhq = document.getElementById("menuHintQuick");
    if(mhq) mhq.addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       hint();
    });

    // Fullscreen button removed (handled by top bar Maximize)
    document.getElementById("menuIntro").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       document.getElementById("introBack").style.display = "flex";
    });

    document.getElementById("btnPost").addEventListener("click", postScore);
    document.getElementById("btnRefresh").addEventListener("click", refreshLeaderboard);

    const lbSel = document.getElementById("lbDiffSelect");
    if(lbSel) lbSel.addEventListener("change", refreshLeaderboard);

    // Leaderboard tabs (buttons like the top difficulty pills)
    function setLbDiff(key, doRefresh=true){
      const lbSel2 = document.getElementById("lbDiffSelect");
      if(lbSel2) lbSel2.value = key;

      const radios = document.querySelectorAll('input[name="lbDiff"]');
      radios.forEach(r => r.checked = (r.value === key));

      if(doRefresh) refreshLeaderboard();
    }

    const lbTabs = document.getElementById("lbTabs");
    if(lbTabs){
      lbTabs.addEventListener("change", ()=>{
        const v = document.querySelector('input[name="lbDiff"]:checked')?.value || (document.getElementById("lbDiffSelect")?.value) || diff.key;
        setLbDiff(v, true);
      });
    }


    // Dark Mode
    const btnTheme = document.getElementById("btnTheme");
    function syncTheme(){
      const isDark = document.body.classList.contains("dark");
      btnTheme.textContent = isDark ? "‚òÄÔ∏è" : "üåô";
      localStorage.setItem("luvvies_dark", isDark ? "1" : "0");
    }
    if(localStorage.getItem("luvvies_dark")==="1"){
      document.body.classList.add("dark");
      syncTheme();
    }
    btnTheme.addEventListener("click", ()=>{
      document.body.classList.toggle("dark");
      syncTheme();
    });

    // Maximize Button (fullscreen + draggable HUD)
      const btnMax = document.getElementById("btnMax");
      if(btnMax){
         btnMax.addEventListener("click", async ()=>{
            const shouldMax = !document.body.classList.contains("maximized");
            const root = document.getElementById("playArea") || document.documentElement;
            if(shouldMax){
              document.body.classList.add("maximized");
              layoutBoard();
              updateUI();
              try{
                if(!document.fullscreenElement){
                  await root.requestFullscreen();
                }
              }catch(e){}
            } else {
              document.body.classList.remove("maximized");
              layoutBoard();
              updateUI();
              try{
                if(document.fullscreenElement){
                  await document.exitFullscreen();
                }
              }catch(e){}
            }
         });
      }

    
    // Maximize HUD controls
    const btnUnmax = document.getElementById("btnUnmax");
    if(btnUnmax) btnUnmax.addEventListener("click", async ()=>{
       document.body.classList.remove("maximized");
       layoutBoard();
       updateUI();
       try{
         if(document.fullscreenElement){
           await document.exitFullscreen();
         }
       }catch(e){}
    });
    const maxHint = document.getElementById("maxHint");
    if(maxHint) maxHint.addEventListener("click", hint);

    // KOALA_DRAG_HUD: HUD (fsHud / maxHud) verschiebbar machen (damit es nicht im Weg ist)
    function makeHudDraggable(el, key){
      if(!el) return;
      const handle = el; // ganze Leiste draggable
      handle.style.cursor = "move";

      // Restore position
      try{
        const saved = localStorage.getItem(key);
        if(saved){
          const p = JSON.parse(saved);
          if(p && p.left && p.top){
            el.style.position = "fixed";
            el.style.left = p.left;
            el.style.top = p.top;
            el.style.transform = "none";
          }
        }
      }catch(e){}

      let dragging=false, sx=0, sy=0, ox=0, oy=0;
      handle.addEventListener("pointerdown", (e)=>{
        if(e.button!==0) return;

        // Nicht draggen wenn Buttons / Inputs geklickt werden
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
        if(tag==="button" || tag==="input" || tag==="select" || tag==="textarea") return;

        dragging=true;
        try{ handle.setPointerCapture(e.pointerId); }catch(_e){}
        const r = el.getBoundingClientRect();
        sx=e.clientX; sy=e.clientY;
        ox=r.left; oy=r.top;

        el.style.position="fixed";
        el.style.left = r.left+"px";
        el.style.top  = r.top+"px";
        el.style.transform="none";
      });
      handle.addEventListener("pointermove", (e)=>{
        if(!dragging) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        el.style.left = (ox+dx)+"px";
        el.style.top  = (oy+dy)+"px";
      });
      handle.addEventListener("pointerup", (e)=>{
        if(!dragging) return;
        dragging=false;
        try{ handle.releasePointerCapture(e.pointerId); }catch(_e){}
        try{
          localStorage.setItem(key, JSON.stringify({left: el.style.left, top: el.style.top}));
        }catch(_e){}
      });
    }

    // aktivieren (script l√§uft nach DOM)
    try{ makeHudDraggable(document.getElementById("fsHud"), "luvHudPos_fs"); }catch(e){}
    try{ makeHudDraggable(document.getElementById("maxHud"), "luvHudPos_max"); }catch(e){}

// FX Slider (Dimmer Overlay)
    function updateFx(v){
      // v: 0-100. Opacity: 0 -> 0.7
      const op = (v / 100) * 0.7;
      const ov = document.getElementById("darkOverlay");
      if(ov) ov.style.opacity = op;

      // Reset filter on body if switching back from old method
      document.body.style.filter = "none";

      // Sync sliders
      if(document.getElementById("fxSlider")) document.getElementById("fxSlider").value = v;
      if(document.getElementById("fsMenuFx")) document.getElementById("fsMenuFx").value = v;
    }

    const fxSlider = document.getElementById("fxSlider");
    fxSlider.addEventListener("input", (e)=>updateFx(e.target.value));

    const fsMenuFx = document.getElementById("fsMenuFx");
    if(fsMenuFx) fsMenuFx.addEventListener("input", (e)=>updateFx(e.target.value));

    document.getElementById("diffPills").addEventListener("change", ()=>{
      const v = document.querySelector('input[name="diff"]:checked').value;
      diff = DIFFS[v];

      // Sync leaderboard filter
      const lbSel = document.getElementById("lbDiffSelect");
      if(lbSel) lbSel.value = v;
      try{ if(typeof setLbDiff==="function") setLbDiff(v, false); }catch(e){}
      try{ refreshLeaderboard(); }catch(e){}

      newGame(true);
      buildGlobalBg();
      buildFsBg();
    });
    document.getElementById("fsHint").addEventListener("click", hint);
    // Menu Btn
    const btnMenu = document.getElementById("fsMenuBtn");
    if(btnMenu) btnMenu.addEventListener("click", ()=>{
       // Populate tips
       const t = document.getElementById("quickTips");
       if(t) document.getElementById("fsMenuTips").innerHTML = t.innerHTML;
       document.getElementById("fsMenuBack").style.display="flex";
    });

    const menuClose = document.getElementById("fsMenuClose");
    if(menuClose) menuClose.addEventListener("click", ()=>document.getElementById("fsMenuBack").style.display="none");

    const menuIntro = document.getElementById("fsMenuIntro");
    if(menuIntro) menuIntro.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    const menuLuv = document.getElementById("fsMenuLuv");
    if(menuLuv) menuLuv.addEventListener("click", ()=>{
       toast("Luvvies Men√º", "Bitte Spiel beenden f√ºr Details", 2000);
    });

    // Dark mode in FS Menu
    const fsTheme = document.getElementById("fsMenuTheme");
    if(fsTheme) fsTheme.addEventListener("click", ()=>{
      document.body.classList.toggle("dark");
      syncTheme();
      // Sync icon
      fsTheme.textContent = document.body.classList.contains("dark") ? "‚òÄÔ∏è" : "üåô";
    });

    // Old FS listeners (kept for safety if buttons exist)
    const fsIntroBtn = document.getElementById("fsIntro");
    if(fsIntroBtn) fsIntroBtn.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    document.getElementById("fsExit").addEventListener("click", async ()=>{
      if(document.fullscreenElement) await document.exitFullscreen();
    });

    /**********************
     * Boot
     **********************/
    attachResize();
    syncBgHeight();
    function refreshActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);

      const pairs = [
        ["sleepy", "mond"],
        ["joyce", "smokey"],
        ["simba", "smokey"],
        ["grumpy", "happy"],
        ["donut", "sweety"]
      ];

      let max = 6;
      if(diff.key === "easy") max = 7;
      if(diff.key === "normal") max = 6;
      if(diff.key === "hard") max = 6;
      if(diff.key === "shock") max = 5;

      const selected = new Set();
      const add = (k) => {
         if(selected.has(k)) return;
         if(selected.size >= max) return;
         selected.add(k);
      };

      // Shuffle pool
      const shuffled = [...pool].sort(()=>Math.random()-0.5);

      for(const b of shuffled){
         if(selected.size >= max) break;

         const myPairs = pairs.filter(p => p.includes(b.key));
         if(myPairs.length > 0){
            // Has partner
            const partnerKey = myPairs[0].find(k => k !== b.key);
            // Check if partner exists in pool (level req)
            if(!pool.find(x=>x.key===partnerKey)){
               add(b.key); // Partner not available (level too low), add alone
               continue;
            }

            // Check space
            if(!selected.has(partnerKey) && selected.size >= max - 1){
               // Not enough space for pair
               continue;
            }
            add(b.key);
            add(partnerKey);
         } else {
            add(b.key);
         }
      }

      // Fallback fill
      if(selected.size < 4){
         for(const b of pool){
            if(selected.size >= max) break;
            add(b.key);
         }
      }

      gameActivePool = BASES.filter(b => selected.has(b.key));
    }

    resetUnlocked();
    newGame(true);
    showGreetingIfNeeded();
  </script>
</body>
</html>
