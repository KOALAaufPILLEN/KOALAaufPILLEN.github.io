<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Luvvies Crush - Rogue</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Twitch Dark Mode Palette */
      --bg-dark: #0e0e10;
      --bg-panel: #18181b;
      --bg-hover: #26262c;
      --accent: #9146ff; /* Twitch Purple */
      --accent-hover: #a970ff;
      --text-main: #efeff1;
      --text-muted: #adadb8;

      --cell: 11vmin; /* Dynamic for 7x9 */
      --rows: 9;
      --cols: 7;
    }

    body {
      margin: 0;
      background: var(--bg-dark);
      color: var(--text-main);
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    #page {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* --- Top UI --- */
    .top-ui {
      width: 100%;
      height: 60px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-panel);
      padding: 0 10px;
      box-sizing: border-box;
      border-bottom: 2px solid #000;
      z-index: 100;
    }

    .res-pill {
      background: #000;
      padding: 4px 10px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #333;
    }

    /* --- Board Area --- */
    #boardWrap {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      width: 100%;
      /* background-image set by JS for Biomes */
      background-size: cover;
      background-position: center;
      transition: background 0.5s ease;
    }

    #board {
      display: grid;
      grid-template-rows: repeat(var(--rows), var(--cell));
      grid-template-columns: repeat(var(--cols), var(--cell));
      gap: 2px;
      position: relative;
    }

    /* --- Tiles --- */
    .tile {
      width: var(--cell);
      height: var(--cell);
      position: absolute;
      transition: transform 0.2s, opacity 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .plate {
      width: 92%;
      height: 92%;
      background-size: cover;
      border-radius: 12%;
      box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    }

    /* --- Bottom UI (Mobile Nav) --- */
    #townNav {
      height: 70px;
      width: 100%;
      background: var(--bg-panel);
      display: flex;
      justify-content: space-around;
      align-items: center;
      border-top: 2px solid #000;
      z-index: 200;
    }

    .navBtn {
      flex: 1;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .navBtn.active {
      color: var(--accent);
      background: var(--bg-hover);
    }
    .navBtn i { font-size: 20px; margin-bottom: 4px; }

    /* --- Views (Town, Shop, etc.) --- */
    .view-layer {
      position: absolute;
      top: 60px; /* Below top-ui */
      bottom: 70px; /* Above nav */
      width: 100%;
      background: var(--bg-dark);
      display: none; /* Toggled by JS */
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }

    /* --- HP Stacks UI --- */
    .hp-stack-container {
      display: flex;
      gap: 2px;
      margin-top: 4px;
    }
    .hp-stack {
      height: 6px;
      flex: 1;
      background: #333;
      border-radius: 2px;
    }
    .hp-stack.filled { background: #e91e63; }
    .hp-stack.filled.shield { background: #2196f3; }

    /* --- Equipment Slots --- */
    .equip-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    .equip-slot {
      aspect-ratio: 1;
      background: var(--bg-hover);
      border: 2px solid #333;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      position: relative;
    }
    .equip-slot.filled { border-color: var(--accent); }

    /* --- Talent Tree --- */
    .talent-node {
      width: 60px;
      height: 60px;
      background: var(--bg-hover);
      border-radius: 50%;
      border: 3px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 10px;
      cursor: pointer;
    }
    .talent-node.active { border-color: var(--accent); background: #2a1a40; }

    /* --- Dialogs/Modals --- */
    #modalOverlay {
      position: fixed; top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      display: none;
      justify-content: center;
      align-items: center;
    }
    .modal {
      background: var(--bg-panel);
      width: 90%;
      max-width: 400px;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid #444;
      text-align: center;
    }

    /* Biome Effects Overlay */
    #biomeOverlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none;
        z-index: 5;
        mix-blend-mode: overlay;
        opacity: 0.3;
    }

  </style>
</head>
<body>

  <!-- Top Bar -->
  <div class="top-ui">
    <div class="res-pill">‚ù§Ô∏è <span id="uiHp">100</span></div>
    <div class="res-pill">üí∞ <span id="uiGold">0</span></div>
    <div class="res-pill" style="flex-direction:column; align-items:flex-start; min-width:120px;">
        <div style="display:flex; justify-content:space-between; width:100%;">
            <span>üíÄ <span id="uiEnemy">Rat</span></span>
            <small id="uiStackCount" style="color:#ff4081; font-weight:900;"></small>
        </div>
        <div id="uiEnemyBars" class="hp-stack-container" style="width:100%; height:6px; margin-top:2px;"></div>
    </div>
  </div>

  <!-- Main Game Page (The Board) -->
  <div id="page" style="display:none;">
    <div id="boardWrap">
        <div id="biomeOverlay"></div>
        <div id="board"></div>
        <div id="fxLayer" style="position:absolute;pointer-events:none;width:100%;height:100%;"></div>
    </div>
  </div>

  <!-- Town / Meta Views -->
  <div id="townView" class="view-layer" style="display:flex;">
    <h2 style="text-align:center;">Luvvies Camp</h2>

    <!-- Difficulty Selector -->
    <div style="background:var(--bg-panel); padding:10px; border-radius:8px; margin-bottom:15px;">
        <h3>Schwierigkeit</h3>
        <div id="townDiffPills" style="display:flex; gap:10px; overflow-x:auto; padding-bottom:10px;">
            <!-- JS Injected -->
        </div>
    </div>

    <!-- Quick Actions -->
    <button onclick="rogueEngine.startNewRun()" style="background:var(--accent); color:#fff; border:none; padding:15px; width:100%; font-size:18px; font-weight:900; border-radius:8px; cursor:pointer;">
        ABENTEUER STARTEN
    </button>
  </div>

  <div id="heroView" class="view-layer">
    <h2>Held & Ausr√ºstung</h2>
    <div class="equip-grid" id="equipSlots">
        <!-- JS Injected -->
    </div>
    <div id="statsPanel" style="background:var(--bg-panel); padding:15px; border-radius:8px;">
        <!-- Stats -->
    </div>
  </div>

  <div id="talentView" class="view-layer">
    <h2>Talente</h2>
    <div style="text-align:center; margin-bottom:10px;">Punkte: <span id="talentPts">0</span></div>
    <div id="talentTree" style="display:flex; flex-wrap:wrap; justify-content:center;">
        <!-- JS Injected -->
    </div>
  </div>

  <div id="shopView" class="view-layer">
    <h2>Laden</h2>
    <div id="shopItems">Coming Soon</div>
  </div>

  <div id="mapView" class="view-layer" style="align-items:center;">
    <h2 style="position:sticky; top:0; background:var(--bg-dark); width:100%; text-align:center; padding:10px; z-index:10;">Weltkarte</h2>
    <div id="mapNodes" style="display:flex; flex-direction:column-reverse; gap:30px; padding:20px; align-items:center; width:100%;">
        <!-- JS Injected -->
    </div>
  </div>

  <!-- Bottom Nav -->
  <div id="townNav">
    <div class="navBtn active" data-tab="town" onclick="switchTab('town')">
        <i>üè∞</i><span>Camp</span>
    </div>
    <div class="navBtn" data-tab="hero" onclick="switchTab('hero')">
        <i>üõ°Ô∏è</i><span>Held</span>
    </div>
    <div class="navBtn" data-tab="talents" onclick="switchTab('talents')">
        <i>‚ú®</i><span>Talente</span>
    </div>
    <div class="navBtn" data-tab="shop" onclick="switchTab('shop')">
        <i>üõí</i><span>Laden</span>
    </div>
  </div>

  <!-- Modals -->
  <div id="modalOverlay">
    <div class="modal" id="modalContent"></div>
  </div>

  <!-- Engine Script -->
  <script src="rogue.js"></script>

  <!-- Game Logic (Match 3) Adapter -->
  <script>
    // --- UI Helpers ---
    function switchTab(tab){
        document.querySelectorAll('.view-layer').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.navBtn').forEach(el => el.classList.remove('active'));

        const target = document.getElementById(tab+'View');
        if(target) target.style.display = 'flex';

        const btn = document.querySelector(`.navBtn[data-tab="${tab}"]`);
        if(btn) btn.classList.add('active');

        // If switching to game, hide nav? No, keeping nav for "Give Up" or "Menu" might be good.
        // But for now, if 'game' is active, we hide town views.
    }

    // --- CORE ROGUE ENGINE ADAPTER ---

    // Constants & Globals
    let grid = [];
    let tileEls = new Map();
    let rows = 9;
    let cols = 7;
    let isBusy = false;

    // Images (Referencing local assets)
    const IMG = {
        sweety: "Images/Luvvies/Sweety.png",
        sleepy: "Images/Luvvies/Sleepy.png",
        normal: "Images/Luvvies/Normalo.png",
        cry: "Images/Luvvies/Cry.png",
        happy: "Images/Luvvies/HappyCookie.png",
        grumpy: "Images/Luvvies/Grumpycookie.png",
        mond: "Images/Luvvies/Mondlie.png",
        donut: "Images/Luvvies/Donutlie.png",
        joyce: "Images/Luvvies/joyce.png",
        smokey: "Images/Luvvies/Smokey.png",
        simba: "Images/Luvvies/Simba.png",
        koala: "Images/Luvvies/KOALA.png",
        cit: "Images/Luvvies/CItrussie.png",
        worm: "Images/Luvvies/Sourwurm-1.png",
        lovelie: "Images/Luvvies/lovvelie.png",
        mellow: "Images/Luvvies/mellow.png",
        powerBtn: "Images/Button/PowerUpButton.png",
        btnDefault: "Images/Button/Variant-A1.png"
    };

    // Bases Config
    const BASES = [
        { key: "sweety", color: "#ff8a80" },
        { key: "sleepy", color: "#80d8ff" },
        { key: "normal", color: "#ccff90" },
        { key: "cry", color: "#ea80fc" },
        { key: "happy", color: "#ffd180" }
    ];

    // Helper: Wait
    const wait = (ms) => new Promise(r => setTimeout(r, ms));

    // --- GAME INIT ---
    function initGame(isNew) {
        const board = document.getElementById("board");
        board.innerHTML = "";
        tileEls.clear();

        rows = window.rows || 9;
        cols = window.cols || 7;

        // CSS Vars
        const bWrap = document.getElementById("boardWrap");
        if(bWrap){
            bWrap.style.setProperty('--rows', rows);
            bWrap.style.setProperty('--cols', cols);
        }

        // Apply Biome Visuals
        if(window.CURRENT_BIOME) {
            const biome = rogueEngine.biomes.find(b => b.id === window.CURRENT_BIOME);
            if(biome) {
                bWrap.style.backgroundImage = `url('${biome.bg}')`;
                const overlay = document.getElementById("biomeOverlay");
                if(overlay){
                    overlay.style.filter = biome.filter;
                    overlay.style.opacity = biome.opacity;
                }
            }
        }

        // Init Grid (No Matches Initially)
        grid = Array.from({length:rows}, ()=>Array(cols).fill(null));

        // Pool logic based on Tier? For now standard set
        const pool = ["sweety", "sleepy", "normal", "cry", "happy", "joyce", "smokey"];

        for(let r=0; r<rows; r++){
            for(let c=0; c<cols; c++){
                let type;
                let tries = 0;
                do {
                    type = pool[Math.floor(Math.random()*pool.length)];
                    tries++;
                } while(wouldMatch(r, c, type) && tries < 50);

                spawnTile(r, c, type);
            }
        }

        updateTopBar();
    }

    function makeId(){ return Math.random().toString(36).substr(2,9); }

    function spawnTile(r, c, type) {
        const id = makeId();
        const tile = { id, r, c, type, el:null };
        grid[r][c] = tile;
        createTileEl(tile);
        return tile;
    }

    function createTileEl(tile) {
        const d = document.createElement("div");
        d.className = "tile";
        d.dataset.id = tile.id;

        // Set position via CSS vars for transforms
        setTilePos(d, tile.r, tile.c);

        // Visual Plate
        const plate = document.createElement("div");
        plate.className = "plate";

        // Image
        const img = document.createElement("img");
        img.style.width = "85%";
        img.style.height = "85%";
        img.style.objectFit = "contain";
        img.style.pointerEvents = "none";

        // Resolve Image
        const key = tile.type.split(":")[0];
        if(IMG[key]) img.src = IMG[key];
        else img.src = IMG.normal; // Fallback

        // BG Tint
        const base = BASES.find(b=>b.key===key);
        if(base) plate.style.background = `radial-gradient(circle at 30% 30%, #fff, ${base.color})`;
        else plate.style.background = "radial-gradient(circle at 30% 30%, #fff, #eee)";

        // Powerups
        if(key === "worm" || key === "cit" || key === "koala") {
            plate.style.backgroundImage = `url('${IMG.powerBtn}')`;
            plate.style.backgroundSize = "contain";
            plate.style.backgroundColor = "transparent";
            plate.style.boxShadow = "none";
        }

        plate.appendChild(img);
        d.appendChild(plate);

        // Input Handlers
        d.onmousedown = (e) => onPointerDown(e, tile);
        d.ontouchstart = (e) => onPointerDown(e, tile);

        document.getElementById("board").appendChild(d);
        tileEls.set(tile.id, d);
        tile.el = d; // link
        return d;
    }

    function setTilePos(el, r, c) {
        // calc(r * var(--cell))
        const cssR = `calc(${r} * var(--cell))`;
        const cssC = `calc(${c} * var(--cell))`;
        el.style.transform = `translate(${cssC}, ${cssR})`;
        // Also set explicit left/top for backup or drag calcs if needed
        el.style.left = "0";
        el.style.top = "0";
    }

    function wouldMatch(r, c, type) {
        const k = type.split(":")[0];
        // Check Left
        if(c>=2) {
            const t1 = grid[r][c-1], t2 = grid[r][c-2];
            if(t1 && t2 && t1.type.startsWith(k) && t2.type.startsWith(k)) return true;
        }
        // Check Up
        if(r>=2) {
            const t1 = grid[r-1][c], t2 = grid[r-2][c];
            if(t1 && t2 && t1.type.startsWith(k) && t2.type.startsWith(k)) return true;
        }
        return false;
    }

    // --- INPUT HANDLING ---
    let dragStart = null;
    let selectedTile = null;

    function onPointerDown(e, tile) {
        if(isBusy) return;
        e.preventDefault();

        if(!selectedTile) {
            // Select
            selectedTile = tile;
            tile.el.classList.add("dragging"); // Visual feedback
        } else {
            // Attempt Swap
            const dist = Math.abs(selectedTile.r - tile.r) + Math.abs(selectedTile.c - tile.c);
            if(dist === 1) {
                // Adjacent -> Swap
                const t1 = selectedTile;
                selectedTile = null;
                t1.el.classList.remove("dragging");
                attemptSwap(t1, tile);
            } else {
                // Deselect / Reselect
                selectedTile.el.classList.remove("dragging");
                if(selectedTile === tile) {
                    selectedTile = null; // Toggle off
                } else {
                    selectedTile = tile; // Switch selection
                    tile.el.classList.add("dragging");
                }
            }
        }
    }

    async function attemptSwap(t1, t2) {
        if(isBusy) return;
        isBusy = true;

        // 1. Visual Swap
        await swapTiles(t1, t2);

        // 2. Check Matches
        const matches = findMatches();

        // 3. Logic
        if(matches.length > 0) {
            // Valid Swap -> Process Matches
            // ROGUE LOGIC: Hero Attack
            await processMatches(matches);
            // Enemy Turn?
        } else {
            // Invalid -> Swap Back
            await swapTiles(t1, t2); // Undo
        }

        isBusy = false;
        updateTopBar();
    }

    async function swapTiles(t1, t2) {
        // Update Grid
        const r1=t1.r, c1=t1.c;
        const r2=t2.r, c2=t2.c;

        grid[r1][c1] = t2;
        grid[r2][c2] = t1;

        t1.r=r2; t1.c=c2;
        t2.r=r1; t2.c=c1;

        // Animate
        setTilePos(t1.el, t1.r, t1.c);
        setTilePos(t2.el, t2.r, t2.c);

        await wait(250);
    }

    function findMatches() {
        const matched = new Set();

        // Horizontal
        for(let r=0; r<rows; r++){
            for(let c=0; c<cols-2; c++){
                const t1=grid[r][c], t2=grid[r][c+1], t3=grid[r][c+2];
                if(t1 && t2 && t3){
                    const k = t1.type.split(":")[0];
                    if(t2.type.startsWith(k) && t3.type.startsWith(k)){
                        matched.add(t1); matched.add(t2); matched.add(t3);
                    }
                }
            }
        }

        // Vertical
        for(let c=0; c<cols; c++){
            for(let r=0; r<rows-2; r++){
                const t1=grid[r][c], t2=grid[r+1][c], t3=grid[r+2][c];
                if(t1 && t2 && t3){
                    const k = t1.type.split(":")[0];
                    if(t2.type.startsWith(k) && t3.type.startsWith(k)){
                        matched.add(t1); matched.add(t2); matched.add(t3);
                    }
                }
            }
        }

        return Array.from(matched);
    }

    async function processMatches(matches) {
        // ROGUE: Calculate Damage
        const dmg = matches.length * (rogueEngine.state.talents.might * 2 + 5);
        damageEnemy(dmg);

        // Remove Tiles
        matches.forEach(t => {
            if(t.el) t.el.remove();
            grid[t.r][t.c] = null;
            tileEls.delete(t.id);
            // Visual FX
            spawnFx(t.r, t.c, "‚ú®");
        });

        await wait(200);

        // Drop & Refill
        await dropAndFill();

        // Recursion?
        const newMatches = findMatches();
        if(newMatches.length > 0) {
            await wait(200);
            await processMatches(newMatches);
        } else {
            // End of Turn -> Enemy Attacks
            if(window.CURRENT_ENEMY && window.CURRENT_ENEMY.hp > 0) {
                 await enemyAttack();
            }
        }
    }

    async function dropAndFill() {
        // Gravity
        for(let c=0; c<cols; c++){
            let write = rows-1;
            for(let r=rows-1; r>=0; r--){
                if(grid[r][c]) {
                    if(write !== r) {
                        const t = grid[r][c];
                        grid[r][c] = null;
                        grid[write][c] = t;
                        t.r = write;
                        setTilePos(t.el, t.r, t.c); // Slide down
                    }
                    write--;
                }
            }
            // Fill top
            for(let r=write; r>=0; r--){
                const type = ["sweety", "sleepy", "normal", "cry", "happy", "joyce", "smokey"][Math.floor(Math.random()*7)];
                spawnTile(r, c, type);
                // Animate entry?
            }
        }
        await wait(250);
    }

    // --- ROGUE MECHANICS ---

    function damageEnemy(amount) {
        if(!window.CURRENT_ENEMY) return;
        window.CURRENT_ENEMY.hp -= amount;
        if(window.CURRENT_ENEMY.hp <= 0) {
            window.CURRENT_ENEMY.hp = 0;
            updateTopBar();
            // Victory!
            setTimeout(victory, 500);
        }
        updateTopBar();
    }

    async function enemyAttack() {
        if(!window.CURRENT_ENEMY) return;
        // Simple damage
        // ROGUE: Defense calculation?
        const dmg = Math.floor(window.CURRENT_ENEMY.maxHp * 0.05); // 5% max HP damage
        rogueEngine.state.hp -= dmg;
        if(rogueEngine.state.hp <= 0) {
            rogueEngine.state.hp = 0;
            updateTopBar();
            setTimeout(defeat, 500);
        }
        spawnFx(4, 3, "üíî -" + dmg);
        updateTopBar();
    }

    function updateTopBar() {
        const s = rogueEngine.state;
        // Update HP
        document.getElementById("uiHp").innerText = Math.round(s.hp);
        document.getElementById("uiGold").innerText = s.gold;

        // Update Enemy Bar (Stack Logic)
        if(window.CURRENT_ENEMY) {
            const e = window.CURRENT_ENEMY;
            document.getElementById("uiEnemy").innerText = `${e.name} (${e.hp})`;

            // Multi-stack Logic
            // Each stack is 1000 HP.
            // If HP is 2500 -> 2 Full Stacks + 500/1000 of 3rd.
            const stackSize = 1000;
            const totalStacks = Math.ceil(e.maxHp / stackSize);
            const currentStacks = Math.ceil(e.hp / stackSize);
            const currentRemainder = e.hp % stackSize || stackSize; // 1000 if 0

            const container = document.getElementById("uiEnemyBars");
            container.innerHTML = "";

            // Limit visible stacks to keep UI clean (max 5 bars)
            const maxVisible = 5;
            const renderCount = Math.min(currentStacks, maxVisible);

            if(currentStacks > maxVisible) {
                document.getElementById("uiStackCount").innerText = `x${currentStacks}`;
            } else {
                document.getElementById("uiStackCount").innerText = "";
            }

            for(let i=0; i<renderCount; i++) {
                const bar = document.createElement("div");
                bar.className = "hp-stack filled";

                // The last bar (visually on right) is the "active" one being depleted?
                // Actually usually in games: Leftmost is bottom stack, Rightmost is top stack.
                // Or Top stack is overlaid.
                // Let's do: Render multiple bars side-by-side.
                // The right-most is the current one.

                if(i === renderCount - 1) {
                    // This is the current active stack
                    const pct = (currentRemainder / stackSize) * 100;
                    bar.style.width = pct + "%";
                    bar.style.flex = "none"; // Don't grow, use fixed width % of parent's slot?
                    // CSS grid/flex is tricky for partial bars.
                    // Better approach:
                    // Render N divs. All full except the last one.

                    // Actually, flex:1 fills space equally.
                    // To show partial, we need a gradient or inner bar.
                    bar.style.background = `linear-gradient(90deg, #e91e63 ${pct}%, #333 ${pct}%)`;
                }

                container.appendChild(bar);
            }
        }
    }

    function spawnFx(r, c, text) {
        const fx = document.createElement("div");
        fx.innerText = text;
        fx.style.position = "absolute";
        fx.style.left = `calc(${c} * var(--cell) + 20px)`;
        fx.style.top = `calc(${r} * var(--cell) + 10px)`;
        fx.style.color = "#fff";
        fx.style.fontWeight = "bold";
        fx.style.fontSize = "24px";
        fx.style.textShadow = "0 2px 4px #000";
        fx.style.zIndex = "100";
        fx.style.animation = "floatUp 1s ease-out forwards";

        // Add animation keyframe dynamically if needed, or assume global CSS
        fx.animate([
            { transform: 'translateY(0)', opacity: 1 },
            { transform: 'translateY(-50px)', opacity: 0 }
        ], { duration: 800 });

        document.getElementById("fxLayer").appendChild(fx);
        setTimeout(()=>fx.remove(), 800);
    }

    function victory() {
        alert("Victory! Reward: 10 Gold");
        rogueEngine.state.gold += 10;
        rogueEngine.saveGame();
        // Return to map
        document.getElementById("townNav").style.display = "flex"; // Show nav again
        rogueEngine.showMap();
    }

    function defeat() {
        alert("Defeat... Run Reset.");
        rogueEngine.init(); // Reset to title/town
    }

    // Exposed to Rogue Engine
    window.newGame = initGame;

    // Boot
    window.onload = () => {
        // Prevent double init
        if(!window.hasInit) {
             window.hasInit = true;
             rogueEngine.init();
        }
    };

  </script>
</body>
</html>
