<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link rel="icon" type="image/png" href="Luvvies/Luvvies-Logonew.png" />
  <link rel="apple-touch-icon" href="Luvvies/Luvvies-Logonew.png" />
  <title>Luvvies Crush</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    @font-face{
      font-family: "Super Meatball";
      src: url("Super Meatball.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    :root{
      --bg1:#f7f2ff;
      --bg2:#eaf6ff;
      --card:#ffffffd9;
      --card2:#ffffffef;
      --stroke:rgba(17,13,26,.10);
      --shadow: 0 18px 60px rgba(20,10,60,.12);
      --txt:#1d1334;

      --cols: 10;
      --rows: 10;
      --cell: 54px;
      --gap: 2px;
      --pad: 14px;
      --boardRadius: 26px;
      --board-texture: none;
      --board-texture-size: calc(var(--cell) + var(--gap)) calc(var(--cell) + var(--gap));
      --board-texture-opacity: .32;
      --board-texture-filter: blur(0.2px);
      --board-texture-blend: soft-light;
      --biome-page-bg: linear-gradient(160deg, #1b1530, #0f0b1a);
      --biome-scroll-bg:
        radial-gradient(circle at 20% 20%, rgba(90,120,170,.18), transparent 50%),
        radial-gradient(circle at 85% 30%, rgba(70,90,140,.16), transparent 52%),
        radial-gradient(circle at 50% 75%, rgba(40,60,110,.14), transparent 54%),
        linear-gradient(140deg, rgba(20,25,45,.45), rgba(10,12,22,.65));
      --biome-scroll-opacity: .35;
      --biome-board-bg:
        radial-gradient(circle at 20% 20%, rgba(70,70,110,.75), rgba(40,35,60,.45)),
        radial-gradient(circle at 80% 70%, rgba(70,90,160,.22), transparent 55%),
        linear-gradient(180deg, rgba(35,30,55,.75), rgba(18,16,30,.55));
      --biome-ink: #e7e3f7;
      --biome-accent: #7ad8ff;
      --biome-fog: rgba(20,20,40,.55);
      --kawaii-font: "Segoe Print", "Trebuchet MS", "Segoe UI", sans-serif;
      --rogue-font: "Super Meatball", var(--kawaii-font);

      --toastMs: 2600ms;
      --tileDefault: url('Images/optimized-150/Button/Variant-A1.png');
      --candiesImg: url('Images/optimized-150/Button/candies.png');
      --btnCandy: url('Images/optimized-150/Button/candies.png');
      --powerBtn: url('Images/optimized-150/Button/PowerUpButton.png');
      --mystBtn: url('Images/optimized-150/Button/Powerup.png');
      --app-height: 100vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body.dark{
      --bg1:#141020;
      --bg2:#1f1830;
      --card:#252035d9;
      --card2:#2d2640ef;
      --stroke:rgba(255,255,255,.08);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --txt:#f2f0ff;
    }
    body.dark .diffPills{
      background: rgba(30,25,45,.78);
      border:1px solid rgba(255,255,255,.08);
    }
    body.dark .diffPills label{ color:#cfc5e5; }
    body.dark .luvCard, body.dark .lbItem, body.dark .toast{
      background: rgba(40,35,60,.82);
      border:1px solid rgba(255,255,255,.08);
      color: var(--txt);
    }
    body.dark .lbRow input{
      background: rgba(40,35,60,.92);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }
    body.dark .modal{
      background: rgba(30,26,45,.96);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
    }

    body{
      margin:0;
      font-family: var(--kawaii-font);
      color:var(--txt);
      overflow:hidden;
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      position:relative;
      transition: background 0.3s ease, color 0.3s ease;
    }

    /* Scroll container (scrollbar hidden) */
    #page{
      height:var(--app-height, 100vh);
      overflow:auto;
      position:relative;
      z-index:0;
    }
    #page{ scrollbar-width:none; }
    #page::-webkit-scrollbar{ width:0; height:0; }

    /* Scrollender Background Layer */
    #scrollBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      min-height: 120vh;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,105,180,.14), transparent 48%),
        radial-gradient(circle at 85% 25%, rgba(122,216,255,.20), transparent 52%),
        radial-gradient(circle at 55% 75%, rgba(255,209,90,.16), transparent 50%),
        linear-gradient(120deg,
          rgba(255,79,185,.18),
          rgba(255,209,90,.14),
          rgba(122,216,255,.18),
          rgba(139,92,246,.14),
          rgba(255,79,185,.18)
        );
      background-size: auto, auto, auto, 300% 300%;
      filter: blur(18px);
      opacity:.55;
      animation: bgMove 18s ease-in-out infinite;
    }
    body.rogue{
      font-family: var(--rogue-font);
      background: var(--biome-page-bg);
      color: var(--biome-ink);
    }
    body.rogue #scrollBg{
      background: var(--biome-scroll-bg);
      opacity: var(--biome-scroll-opacity, .35);
      filter: blur(20px) saturate(1.05);
    }
    @keyframes bgMove{
      0%{ background-position: 0% 50% }
      50%{ background-position: 100% 50% }
      100%{ background-position: 0% 50% }
    }

    #globalBg{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      overflow:hidden;
    }

    #darkOverlay{
      position:fixed;
      inset:0;
      z-index:100000;
      background:#000;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.2s ease;
    }

    /* Background luvvies: langsamer + fade, immer hinter allem */
    .bgLuv{
      position:absolute;
      width: clamp(150px, 17vw, 300px);
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.10));
      opacity:.72;
      animation: floaty 18s ease-in-out infinite;
      z-index:0;
      pointer-events:none;
    }
    .bgLuv img{ image-rendering: auto; }
    .bgBubble{
      position:absolute;
      left: 50%;
      top: -6px;
      transform: translate(-50%, -100%);
      background: rgba(255,255,255,.92);
      color: #2a1849;
      font-weight: 900;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(17,13,26,.12);
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      max-width: 220px;
      text-align:center;
      animation: bubblePop 5.2s ease both;
      pointer-events:none;
    }
    .bgBubble::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-6px;
      transform:translateX(-50%);
      width:12px;
      height:12px;
      background: inherit;
      border-left:1px solid rgba(17,13,26,.12);
      border-bottom:1px solid rgba(17,13,26,.12);
      transform: translateX(-50%) rotate(45deg);
    }
    @keyframes bubblePop{
      0%{opacity:0; transform:translate(-50%,-90%) scale(.9)}
      15%{opacity:1; transform:translate(-50%,-100%) scale(1)}
      85%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-110%) scale(.98)}
    }
    .bgLuv img{ width:100%; height:auto; display:block; }
    @keyframes floaty{
      0%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
      50%{ transform: translate(10px,-16px) rotate(1.2deg); opacity:.82; }
      100%{ transform: translate(0,0) rotate(-1deg); opacity:.64; }
    }

    /* Subtle twinkles (statt bubbles) */
    .twinkle{
      position:absolute;
      width: 10px; height: 10px;
      left:0; top:0;
      transform: translate(-50%,-50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.15));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: tw 1200ms ease-out forwards;
      filter: drop-shadow(0 0 18px rgba(255,79,185,.18));
    }
    @keyframes tw{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(0deg)}
      20%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-65%) scale(1.15) rotate(140deg)}
    }

    #app{
      width:min(1100px, 96vw);
      margin: 18px auto 28px;
      position:relative;
      z-index:5; /* Vordergrund */
    }
    @media (max-width: 980px), (pointer: coarse){
      #app{
        width: 100vw;
        margin: 8px 0 18px;
        padding: 0 8px;
      }
      .playArea{
        padding: 6px;
        border-radius: 18px;
      }
      #boardWrap{
        padding: 4px;
      }
    }

    .topRow{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      position:relative;
      z-index:6;
    }

    #infoBack{ z-index: 100000; } /* Ensure Bio is above Menu */
    /* Hide menus in fullscreen */
    body.fs .topRow,
    body.fs .progressRow,
    body.fs .stats,
    body.fs .below,
    body.fs #luvPanel,
    body.fs #rightPanel,
    body.fs #maxHud{
      display: none !important;
    }
    body.fs #boardWrap{
      padding-top: 18px;
      padding-bottom: 96px;
    }

    .diffWrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .diffWrap .label{font-weight:900;opacity:.9;margin-right:4px}
    .diffPills{
      display:flex;
      gap:8px; padding:6px;
      border-radius:999px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(17,13,26,.08);
    }
    .diffPills input{display:none}
    .diffPills label{
      cursor:pointer;
      user-select:none;
      padding:10px 14px; border-radius:999px;
      font-weight:900; font-size:14px;
      color:#2b1b4f;
      transition: transform .12s ease, background .2s ease;
    }
    .diffPills input:checked + label{
      background: linear-gradient(135deg, #ff4fb9, #7ad8ff);
      background-size:200% 100%;
      animation: pillGlow 2.2s ease-in-out infinite;
      color:#fff;
      box-shadow: 0 10px 22px rgba(255,79,185,.22);
      transform: translateY(-1px);
    }
    @keyframes pillGlow{
      0%{ background-position:0% 50% }
      50%{ background-position:100% 50% }
      100%{ background-position:0% 50% }
    }

    /* Jelly Button (Custom Image) */
    .Btn{
      position: relative;
      height: 48px;
      padding: 0 20px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #ff78c8, #ff4fb9);
      color: white;
      box-shadow: 0 8px 16px rgba(0,0,0,.16);
      text-shadow: 0 2px 4px rgba(0,0,0,.25);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap:8px;
      font-weight:1000;
      letter-spacing:.1px;
      transition: transform .12s ease, filter .12s ease;
      white-space:nowrap;
      filter: saturate(1.1);
    }
    .Btn::before, .Btn::after { display:none; }
    .Btn:hover { animation: jello-horizontal 0.9s both; }
    .Btn:active{ transform: scale(.98); }
    @keyframes jello-horizontal {
      0% { transform: scale3d(1, 1, 1); }
      30% { transform: scale3d(1.20, 0.80, 1); }
      40% { transform: scale3d(0.80, 1.20, 1); }
      50% { transform: scale3d(1.12, 0.88, 1); }
      65% { transform: scale3d(0.96, 1.04, 1); }
      75% { transform: scale3d(1.04, 0.96, 1); }
      100% { transform: scale3d(1, 1, 1); }
    }
    .Btn.secondary{
      background: linear-gradient(135deg, #ff4fb9, #ff9adf);
      box-shadow: 0px 10px 10px rgba(255,200,235,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.15),
                  0px -10px 10px rgba(255,60,180,.55) inset;
    }
    .Btn.ghost{
      background: rgba(255,255,255,.8);
      color:#2a1849;
      box-shadow: 0px 10px 10px rgba(240,240,255,.9) inset,
                  0px 7px 18px rgba(5, 5, 5, 0.10),
                  0px -10px 10px rgba(220,220,255,.55) inset;
    }
    #btnMenu, #fsMenuBtn{
      background: linear-gradient(135deg, #ff4fb9, #ff78c8);
      box-shadow: 0 10px 22px rgba(255,79,185,.22);
    }
    #btnHintTop, #menuHint, #menuHintQuick, #fsHint, #maxHint{
      background: linear-gradient(90deg,#ff4fb9,#ffcf5a,#7ad8ff,#ff4fb9);
      background-size: 300% 100%;
      animation: hintFade 3.2s ease-in-out infinite;
    }
    @keyframes hintFade{
      0%{background-position:0% 50%}
      50%{background-position:100% 50%}
      100%{background-position:0% 50%}
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      z-index:6;
    }

    .stats{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
      position:relative;
      z-index:6;
    }
    .stat{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      min-height: 62px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .stat .k{font-weight:900; font-size:12px; opacity:.7}
    .stat .v{font-weight:1000; font-size:20px; margin-top:2px}

    .progressRow{
      margin-top: 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(20,10,60,.07);
      display:flex;
      align-items:center;
      gap:10px;
      position:relative;
      z-index:6;
    }
    .progressRow b{font-size:14px}
    .rogueEnemy{
      display:none;
      margin-top: 10px;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 18px;
      background: rgba(20,18,30,.7);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 14px 30px rgba(0,0,0,.3);
    }
    body.rogue .rogueEnemy{ display:flex; }
    .enemyPortrait{
      width:64px;
      height:64px;
      border-radius: 16px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .enemyPortrait img{
      width: 88%;
      height: 88%;
      object-fit: contain;
      filter: drop-shadow(0 10px 16px rgba(0,0,0,.25));
    }
    .enemyTitle{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 1000;
      letter-spacing: .02em;
    }
    .enemyTier{
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(255,255,255,.14);
      text-transform: uppercase;
      letter-spacing: .08em;
    }
    .enemyTier[data-tier="elite"]{
      background: rgba(122,216,255,.22);
      border: 1px solid rgba(122,216,255,.35);
    }
    .enemyTier[data-tier="boss"]{
      background: rgba(255,120,120,.24);
      border: 1px solid rgba(255,120,120,.4);
    }
    .enemyDesc{
      font-size: 12px;
      opacity: .85;
      margin-top: 2px;
    }
    .enemyTags{
      display:flex;
      gap:6px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    .enemyTag{
      font-size: 10px;
      font-weight: 900;
      padding: 3px 6px;
      border-radius: 999px;
      background: rgba(255,255,255,.1);
      border: 1px solid rgba(255,255,255,.12);
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    .bar{
      flex:1;
      height: 14px;
      border-radius:999px;
      background: rgba(140,120,200,.18);
      overflow:hidden;
      border:1px solid rgba(60,20,120,.10);
      position:relative;
    }
    .bar > i{
      display:block;
      height:100%;
      width:var(--pct, 0%);
      border-radius:999px;
      background: linear-gradient(90deg,
        #ff4fb9,
        #ffcf5a,
        #7ad8ff,
        #8b5cf6,
        #ff4fb9
      );
      background-size: 300% 100%;
      animation: barHueSmooth 6s ease-in-out infinite;
      animation-delay: var(--rainbow-sync, 0s);
      box-shadow: 0 0 18px rgba(255,79,185,.22);
      transition: width .25s ease, height .25s ease;
    }
    body.rogue .bar > i{
      background: linear-gradient(90deg,
        color-mix(in srgb, var(--biome-accent) 80%, #ffd86b),
        color-mix(in srgb, var(--biome-accent) 65%, #84f3d0),
        color-mix(in srgb, var(--biome-accent) 85%, #8bb2ff)
      );
      box-shadow: 0 0 16px rgba(120,180,255,.25);
    }
    @keyframes barHue{
      0%{background-position:0% 50%}
      100%{background-position:100% 50%}
    }
    @keyframes barHueSmooth{
      0%{background-position:0% 50%}
      50%{background-position:100% 50%}
      100%{background-position:0% 50%}
    }
    .pct{font-weight:1000; min-width:46px; text-align:right}
    body.dark .progressRow b,
    body.dark .progressRow .pct{ color:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.45); }

    .playArea{
      margin-top: 12px;
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 14px;
      position:relative;
      overflow:visible;
      z-index:6; /* Vordergrund */
      transition: all 0.3s ease;
    }

    /* Maximize Mode */
    body.maximized .topRow, body.maximized .stats, body.maximized .progressRow, body.maximized .below {
       display:none !important;
    }
    body.maximized #app {
       width: 98vw; margin: 10px auto;
    }
    body.maximized .playArea {
       height: 90vh; /* force height */
       padding: 4px;
       border-radius: 12px;
    }

    #boardWrap{
      position:relative;
      width:100%;
      min-height: 64vh;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
      padding: 8px;
      touch-action: none;
    }
    @media (max-width: 900px){
      #boardWrap{
        padding-left: calc(8px + var(--safe-left));
        padding-right: calc(8px + var(--safe-right));
      }
    }
    body.maximized #boardWrap { min-height: 90vh; }

    #board{
      position:relative;
      z-index:12; /* Board immer vorne */
      transform: translate(var(--board-shift-x, 0px), var(--board-shift-y, 0px));
      padding: var(--pad);
      border-radius: var(--boardRadius);
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.86), rgba(255,255,255,.35)),
        radial-gradient(circle at 80% 70%, rgba(255,209,90,.16), transparent 55%),
        radial-gradient(circle at 30% 75%, rgba(255,79,185,.12), transparent 55%),
        radial-gradient(circle at 75% 25%, rgba(122,216,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.62), rgba(255,255,255,.36));
      border: 1px solid rgba(17,13,26,.08);
      box-shadow:
        0 18px 70px rgba(20,10,60,.10),
        0 6px 16px rgba(0,0,0,.06) inset;
      overflow:hidden;
      animation: boardFade 20s ease-in-out infinite;
      transition: filter 0.3s ease;
    }
    /* Dark Mode Board */
    body.dark #board{
      background:
        radial-gradient(circle at 20% 20%, rgba(60,50,90,.86), rgba(40,30,60,.35)),
        radial-gradient(circle at 80% 70%, rgba(100,80,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(40,35,60,.62), rgba(30,25,50,.36));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 70px rgba(0,0,0,.5), 0 6px 16px rgba(0,0,0,.3) inset;
    }
    body.rogue #board{
      background: var(--biome-board-bg);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:
        0 22px 70px rgba(0,0,0,.55),
        0 6px 16px rgba(0,0,0,.35) inset;
      animation: boardFade 18s ease-in-out infinite;
    }
    @keyframes boardFade{
      0%{ filter:hue-rotate(0deg) saturate(1) }
      50%{ filter:hue-rotate(10deg) saturate(1.04) }
      100%{ filter:hue-rotate(0deg) saturate(1) }
    }

    /* Swirl overlay (statt bubble pattern) */
    #board:before{
      content:"";
      position:absolute; inset:-20px;
      background-image:
        var(--board-texture),
        conic-gradient(from 180deg at 35% 35%,
          rgba(255,255,255,.18),
          rgba(255,255,255,0) 22%,
          rgba(255,255,255,.12) 45%,
          rgba(255,255,255,0) 65%,
          rgba(255,255,255,.18)
        );
      background-size: var(--board-texture-size, 48px 48px), auto;
      background-repeat: repeat, no-repeat;
      background-position: center, center;
      opacity: var(--board-texture-opacity, .35);
      mix-blend-mode: soft-light;
      filter: var(--board-texture-filter);
      pointer-events:none;
    }
    #board:after{
      content:"";
      position:absolute; inset:0;
      border-radius: var(--boardRadius);
      box-shadow:
        0 2px 0 rgba(255,255,255,.55) inset,
        0 -6px 12px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    #fxLayer{
      pointer-events:none;
      position:absolute;
      inset:0;
      z-index:20;
      transform: translate(var(--board-shift-x, 0px), var(--board-shift-y, 0px));
    }

    #fsBg{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%) translate(var(--board-shift-x, 0px), var(--board-shift-y, 0px));
      width: 0px;
      height: 0px;
      z-index:5; /* hinter board */
      pointer-events:none;
      overflow:hidden;
      display:none;
      border-radius: var(--boardRadius);
    }
    body.fs #fsBg{ display:block; }
    body.maximized #fsBg{ display:block; }

    /* Tiles - Optimized */
    .tile{
      position:absolute;
      width: var(--cell);
      height: var(--cell);
      left:0; top:0;
      /* GPU Acceleration: translate3d forces hardware compositing */
      transform: translate3d(var(--x), var(--y), 0);
      transition: transform 190ms cubic-bezier(.2,.9,.2,1.0);
      will-change: transform; /* Hint to browser */
      z-index:15;
    }
    .tile.bigMellow{
      width: calc(var(--cell) * 2 + var(--gap));
      height: calc(var(--cell) * 2 + var(--gap));
      z-index:25;
    }
    .tile.dragging{ transition:none !important; z-index: 50; filter: drop-shadow(0 22px 20px rgba(0,0,0,.20)); }
    .tile.locked{ pointer-events:none; }
    .tile.rooted .plate::after,
    .tile.poisoned .plate::after,
    .tile.frozen .plate::after{
      content:"";
      position:absolute;
      inset:6px;
      border-radius: 14px;
      pointer-events:none;
      opacity: .8;
      mix-blend-mode: screen;
    }
    .tile.rooted .plate::after{
      background:
        radial-gradient(circle at 20% 30%, rgba(120,80,30,.55), transparent 55%),
        radial-gradient(circle at 70% 70%, rgba(70,40,20,.5), transparent 60%),
        linear-gradient(135deg, rgba(90,60,30,.6), rgba(50,30,15,.2));
    }
    .tile.poisoned .plate::after{
      background:
        radial-gradient(circle at 30% 40%, rgba(80,255,140,.55), transparent 60%),
        radial-gradient(circle at 70% 70%, rgba(20,120,70,.6), transparent 65%),
        linear-gradient(135deg, rgba(40,180,110,.45), rgba(10,60,40,.2));
    }
    .tile.frozen .plate::after{
      background:
        radial-gradient(circle at 30% 35%, rgba(160,210,255,.75), transparent 60%),
        radial-gradient(circle at 70% 70%, rgba(120,160,255,.6), transparent 70%),
        linear-gradient(135deg, rgba(120,170,255,.6), rgba(40,80,160,.25));
    }

    body.debugTiles .tile{
      outline: 1px dashed rgba(255,255,255,.45);
    }
    body.debugTiles .plate{
      box-shadow: none !important;
    }
    body.debugTiles .tile::after{
      content: attr(data-base) ":" attr(data-variant);
      position:absolute;
      left:4px;
      bottom:4px;
      font-size:10px;
      font-weight:800;
      color:#fff;
      background: rgba(0,0,0,.45);
      padding:2px 4px;
      border-radius:6px;
      pointer-events:none;
      z-index:5;
    }

    .plate{
      width:100%; height:100%;
      border-radius: 16px;

      /* Jelly Tile Background (image only) + per-Luvvie pastel tint (background layers only) */
      background-image: var(--board-texture, none), var(--bg-img, var(--tileDefault));
      background-size: var(--board-texture-size, 48px 48px), var(--tile-bg-size, calc(100% + 10px)) var(--tile-bg-size, calc(100% + 10px));
      background-position: center, var(--tile-bg-pos, -5px -5px);
      background-repeat: repeat, no-repeat;
      background-blend-mode: var(--board-texture-blend, soft-light);

      /* tint only affects background layers (NOT the sprite image) */
      /* remove the old "card/backplate" look */
      border: none;
      box-shadow: none;

      position:relative;
      overflow:hidden;

      transform: translateY(var(--oy, 0px)) scale(1);
      opacity: var(--op, 1);
      transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease, filter 200ms ease;
    }

    /* Variant B specific styling */
    .tile[data-variant="B"] .plate{
        
        /* keep Variant B as jelly-only too (no extra border/backplate) */
        border: none;
        background-blend-mode: var(--board-texture-blend, soft-light);
  }
    .tile[data-variant="B"] .plate:before{
        background-image:
          linear-gradient(135deg,
            color-mix(in srgb, var(--p1) 58%, transparent),
            color-mix(in srgb, var(--p2) 58%, transparent)
          );
        background-size: 100% 100%;
        background-position: center;
        background-repeat: no-repeat;
    }

    .variantBadge{
        position:absolute;
        top:6px;
        right:6px;
        width:20px;
        height:20px;
        border-radius:999px;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:900;
        font-size:12px;
        letter-spacing:.02em;
        color:#1c0f33;
        background: rgba(255,255,255,.92);
        border: 1px solid rgba(17,13,26,.12);
        box-shadow: 0 10px 16px rgba(0,0,0,.16);
        pointer-events:none;
        z-index:3;
        text-shadow: 0 1px 0 rgba(255,255,255,.6);
        overflow:hidden;
        isolation:isolate;
      }
      .variantBadge::before{
        content:"";
        position:absolute;
        inset:-3px;
        border-radius:inherit;
        background: linear-gradient(90deg, #ff4fb9, #ffcf5a, #7ad8ff, #8b5cf6, #ff4fb9);
        background-size:300% 100%;
        animation: barHueSmooth 6s ease-in-out infinite;
        animation-delay: var(--rainbow-sync, 0s);
        z-index:-1;
        opacity:.95;
        filter: blur(0.6px);
      }
    /* Enhance image contrast */
    .tile img {
       filter: drop-shadow(0 10px 14px rgba(0,0,0,.18)) drop-shadow(0 0 1px rgba(255,255,255,.60)) saturate(1.18) contrast(1.05);
    }
    .tile.bigMellow .plate{ border-radius: 26px; }

    /* Tile overlay (masked to PNG shape so transparency stays clean) */
    .plate:before{
      content:"";
      position:absolute; inset:0;
      background-image:
        linear-gradient(135deg,
          color-mix(in srgb, var(--p1) 58%, transparent),
          color-mix(in srgb, var(--p2) 58%, transparent)
        ),
        var(--candiesImg);
      background-size: 100% 100%, 100% 100%;
      background-position: center, center;
      background-repeat: no-repeat, no-repeat;
      opacity: .92;
      pointer-events:none;
      -webkit-mask-image: var(--bg-img, var(--tileDefault));
      mask-image: var(--bg-img, var(--tileDefault));
      transition: transform 240ms ease, opacity 240ms ease;
      -webkit-mask-size: calc(100% + 10px) calc(100% + 10px);
      mask-size: calc(100% + 10px) calc(100% + 10px);
      -webkit-mask-position: -5px -5px;
      mask-position: -5px -5px;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
    }
    @media (max-width: 980px), (pointer: coarse){
      .plate{
        background-size: var(--board-texture-size, 48px 48px), 100% 100%;
        background-position: center, center;
      }
      .plate:before{
        -webkit-mask-size: 100% 100%;
        mask-size: 100% 100%;
        -webkit-mask-position: center;
        mask-position: center;
      }
    }
    .plate:after{ display:none !important; }
    .tile.comboBurst .plate:before{
      transform: scale(1.16);
      opacity: 1;
    }
    .tile.comboSpecial .plate{
      box-shadow:
        0 0 0 2px rgba(255,215,120,.75),
        0 0 18px rgba(255,190,120,.55);
      animation: comboPulse 420ms ease-in-out 1;
    }
    .tile.comboSpecial .plate:before{
      transform: scale(1.12);
      opacity: 1;
    }
    @keyframes comboPulse{
      0%{ transform: scale(1); }
      50%{ transform: scale(1.06); }
      100%{ transform: scale(1); }
    }

    /* Zilla attack warning */
    .attackWarn{
      position:absolute;
      background: rgba(255,0,0,.18);
      border: 2px dashed rgba(255,0,0,.65);
      border-radius: 10px;
      pointer-events:none;
      animation: attackPulse 0.8s ease-in-out infinite;
      box-shadow: 0 0 18px rgba(255,0,0,.35);
    }
    @keyframes attackPulse{
      0%{ opacity:.6; transform: scale(1); }
      50%{ opacity:1; transform: scale(1.03); }
      100%{ opacity:.6; transform: scale(1); }
    }

    /* Luvvies auf der Karte größer */
    .tile img{
      position:absolute;
      inset: 6%;
      width:88%;
      height:88%;
      object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.10));
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }
    .tile.bigMellow img{
      inset: 8%;
      width:84%;
      height:84%;
    }

    /* Question mark powerup visual */
    .qmark{
      display:none; /* Integrated in Powerup.png */
    }

    /* Animierter Power Background (für Powerups + ??? + Lovelie) */
    .powerAnim .plate{
        --tile-bg-size: calc(100% + 10px);
        --tile-bg-pos: -5px -5px;
        background-image: var(--board-texture, none), var(--bg-img, var(--tileDefault)), var(--powerBtn) !important;
        background-color: transparent !important;
        background-size: var(--board-texture-size, 48px 48px), var(--tile-bg-size) var(--tile-bg-size), 100% 100%;
        background-position: center, var(--tile-bg-pos), center;
        background-repeat: repeat, no-repeat, no-repeat;
        background-blend-mode: var(--board-texture-blend, soft-light), normal, normal !important;
        box-shadow: none;
        animation: powerPulse 1.8s ease-in-out infinite;
      }
    /* Mystery Tile specific */
    .tile[data-base="myst"] .plate {
       --tile-bg-size: calc(100% + 10px);
       --tile-bg-pos: -5px -5px;
       background-image: var(--board-texture, none), var(--bg-img, var(--tileDefault)), var(--mystBtn) !important;
       background-size: var(--board-texture-size, 48px 48px), var(--tile-bg-size) var(--tile-bg-size), 100% 100%;
       background-position: center, var(--tile-bg-pos), center;
       background-repeat: repeat, no-repeat, no-repeat;
       background-blend-mode: var(--board-texture-blend, soft-light), normal, normal !important;
    }
    @keyframes powerPulse{
      0%{ transform: translateY(var(--oy, 0px)) scale(1); }
      50%{ transform: translateY(var(--oy, 0px)) scale(1.05); }
      100%{ transform: translateY(var(--oy, 0px)) scale(1); }
    }
    /* Boss tint */
    .tile[data-base="mellowzilla"] .plate,
    .tile[data-base="koalazilla"] .plate{
      filter: hue-rotate(-12deg) saturate(1.2);
      box-shadow: 0 0 30px rgba(255,80,80,.45), 0 0 40px rgba(255,120,120,.35);
    }
    .tile[data-base="mellowzilla"] img,
    .tile[data-base="koalazilla"] img{
      inset: 0;
      width:100%;
      height:100%;
    }

    /* Puff reveal (??? -> random) */
    .tile.puff .plate{ animation: puff 520ms ease both; }
    @keyframes puff{
      0%{ transform: translateY(0) scale(1); filter: blur(0px); }
      40%{ transform: translateY(-2px) scale(1.12); filter: blur(0.2px); }
      100%{ transform: translateY(0) scale(1); filter: blur(0px); }
    }

    /* Pop */
    .pop .plate{ animation: popPlate 420ms ease-in both; }
    @keyframes popPlate{
      0%{ transform: translateY(0) scale(1); opacity:1; }
      55%{ transform: translateY(-2px) scale(1.14); opacity:1; }
      100%{ transform: translateY(8px) scale(.30); opacity:0; }
    }
    /* Jelly bump when combos resolve */
    .tile.bump .plate{ animation: jellyBump 540ms cubic-bezier(.18,.95,.2,1.05) both; }
    @keyframes jellyBump{
      0%{ transform: translateY(0) scale(1); }
      20%{ transform: translateY(-9px) scale(1.10, 0.90); }
      45%{ transform: translateY(6px) scale(0.92, 1.10); }
      70%{ transform: translateY(-4px) scale(1.05, 0.96); }
      100%{ transform: translateY(0) scale(1); }
    }

    /* Landing bounce - Jelly Style */
    .land .plate{ animation: landPlate 600ms linear both; }
    @keyframes landPlate{
      0% { transform: scale(1, 1) translateY(0); }
      30% { transform: scale(1.25, 0.75) translateY(10px); }
      40% { transform: scale(0.75, 1.25) translateY(-5px); }
      50% { transform: scale(1.15, 0.85) translateY(4px); }
      65% { transform: scale(0.95, 1.05) translateY(-2px); }
      75% { transform: scale(1.05, 0.95) translateY(1px); }
      100% { transform: scale(1, 1) translateY(0); }
    }

    /* Spawn glow */
    .spawnGlow .plate{ animation: spawnGlow 700ms ease-out both; }
    @keyframes spawnGlow{
      0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(.92); }
      55%{ filter: drop-shadow(0 0 20px rgba(255,255,255,.95)); transform: translateY(0) scale(1.05); }
      100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); transform: translateY(0) scale(1); }
    }

    /* Hint auffälliger */
    .tile.hint .plate{
      outline: 3px solid rgba(255,79,185,.85);
      box-shadow:
        0 0 0 5px rgba(122,216,255,.35),
        0 0 30px rgba(255,79,185,.28),
        0 18px 40px rgba(0,0,0,.12);
      animation: hintGlow 1.0s ease-in-out infinite;
    }
    @keyframes hintGlow{
      0%,100%{ filter: saturate(1) brightness(1); }
      50%{ filter: saturate(1.25) brightness(1.12); }
    }

    /* Mellow HP Zahl: kein Background, größer, fade */
    .hp{
      position:absolute;
      right:10px; top:8px;
      font-weight:1000;
      font-size: 18px;
      color: rgba(255,255,255,.98);
      text-shadow:
        0 10px 20px rgba(0,0,0,.18),
        0 2px 0 rgba(0,0,0,.12);
      z-index:30;
      background:none;
      border:none;
      box-shadow:none;
      padding:0;
      animation: hpFade 2.2s ease-in-out infinite;
      pointer-events:none;
    }
    .tile.bigMellow .hp{
      font-size: 22px;
      right:14px;
      top:12px;
    }
    @keyframes hpFade{
      0%,100%{ opacity:.60; transform: translateY(0); }
      50%{ opacity:1; transform: translateY(-1px); }
    }

    /* Below panels */
    .below{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:stretch;
      position:relative;
      z-index:6;
    }
    .below > .panel{height:100%}

    @media (max-width: 880px){
      .stats{grid-template-columns: repeat(2, minmax(0,1fr));}
      .below{grid-template-columns:1fr;}
      #boardWrap{min-height: 52vh;}
    }
    @media (max-width: 640px){
      .stats{grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px;}
      .stat{min-height: 52px; padding: 8px 10px;}
      .progressRow{padding: 8px 10px;}
      .playArea{padding: 10px;}
      #boardWrap{min-height: 60vh; padding: 4px;}
    }

    .panel{
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 22px;
      padding: 12px;
      box-shadow: var(--shadow);
      position:relative;
      z-index:6;
    }
    .panel h3{margin:0 0 10px;font-size:16px}

    .luvGrid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:10px}
    .luvCard{
      display:flex;gap:10px;align-items:center;
      padding:10px;border-radius:18px;
      background: rgba(255,255,255,.82);
      border:1px solid rgba(17,13,26,.08);
      box-shadow: 0 12px 26px rgba(20,10,60,.08);
      cursor:pointer;transition: transform .12s ease;
      position:relative;
    }
    .luvCard:hover{ transform: translateY(-1px); }
    .luvCard img{
      width: 78px;height: 78px;object-fit:contain;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.12));
      flex:0 0 auto;
    }
    .luvCard b{display:block}
    .luvCard small{opacity:.7;font-weight:900}
    .luvChange{
        position:absolute;
        right:8px;
        bottom:8px;
      height:26px;
      min-width:28px;
      padding:0 6px;
      border-radius:999px;
      border:1px solid rgba(17,13,26,.12);
      background: rgba(255,255,255,.9);
      font-weight:1000;
      font-size:12px;
      cursor:pointer;
      box-shadow: 0 6px 14px rgba(0,0,0,.10);
        isolation: isolate;
      }
      .variantBadge.btn{
        pointer-events:auto;
        cursor:pointer;
      }
      .luvCard .variantBadge.btn{
        right:40px;
        bottom:8px;
        top:auto;
        left:auto;
      }
    .luvChange:before{
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:inherit;
      background: linear-gradient(90deg, #ff4fb9, #ffcf5a, #7ad8ff, #8b5cf6, #ff4fb9);
      background-size:300% 100%;
      animation: barHueSmooth 6s ease-in-out infinite;
      animation-delay: var(--rainbow-sync, 0s);
      z-index:-1;
      opacity:.95;
      filter: blur(0.4px);
    }
    body.dark .luvChange{
      color:#fff;
      background: rgba(35,30,55,.88);
      border:1px solid rgba(255,255,255,.18);
    }

    #rightPanel{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 100%;
    }

    .lbRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .lbRow input{
      flex:1; min-width: 170px; height:44px;
      border-radius:14px; border:1px solid rgba(17,13,26,.12);
      padding:0 12px; font-weight:900; outline:none;
      background: rgba(255,255,255,.92);
    }

    /* Leaderboard scrollbar: aktiv, aber optisch clean */
    .lbList{
      display:flex;
      flex-direction:column; gap:8px;
      overflow:auto;
      padding-right:6px;
      flex:1;
      min-height: 260px;
      max-height: 65vh;
      border-radius: 16px;
      scrollbar-width: thin;
    }
    .lbList::-webkit-scrollbar{ width: 10px; }
    .lbList::-webkit-scrollbar-thumb{
      background: rgba(151,95,255,.35);
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.6);
    }
    .lbList::-webkit-scrollbar-track{
      background: rgba(255,255,255,.35);
      border-radius: 999px;
    }
    body.dark .lbList{
      background: rgba(20,18,32,.55);
    }
    body.dark .lbList::-webkit-scrollbar-thumb{
      background: rgba(210,190,255,.35);
      border: 3px solid rgba(32,28,46,.9);
    }
    body.dark .lbList::-webkit-scrollbar-track{
      background: rgba(32,28,46,.9);
    }

    .lbItem{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.95), rgba(245,245,255,.85));
      border:1px solid rgba(17,13,26,.06);
      border-radius:16px;
      padding:10px 10px;
      box-shadow: 0 10px 24px rgba(20,10,60,.07);
      opacity:1;
      transform:none;
      animation:none;
      position:relative;
      overflow:hidden;
    }
    .lbItem .left b{display:block}
    .lbItem .left small{opacity:.7;font-weight:900}
    .lbItem .score{
      font-weight:1000;
      color:#4a2c6f;
    }
    body.dark .lbItem{
      background: linear-gradient(135deg, rgba(40,35,60,.92), rgba(32,28,50,.88));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
    }
    body.dark .lbItem .score{
      color:#e6ddff;
    }

    /* Ranks */
    .lbItem.rank1{
      background:linear-gradient(90deg, rgba(255,215,0,.20), rgba(255,255,255,.12));
      box-shadow:0 0 12px rgba(255,215,0,.45);
      animation: podiumGlowGold 2.8s ease-in-out infinite;
      background-size: 220% 100%;
    }
    .lbItem.rank2{
      background:linear-gradient(90deg, rgba(192,192,192,.18), rgba(255,255,255,.10));
      box-shadow:0 0 10px rgba(220,220,220,.38);
      animation: podiumGlowSilver 3.2s ease-in-out infinite;
      background-size: 220% 100%;
    }
    .lbItem.rank3{
      background:linear-gradient(90deg, rgba(205,127,50,.18), rgba(255,255,255,.08));
      box-shadow:0 0 10px rgba(205,127,50,.35);
      animation: podiumGlowBronze 3.4s ease-in-out infinite;
      background-size: 220% 100%;
    }
    /* Non-podium entries: cooler lilac gradient */
    .lbItem:not(.rank1):not(.rank2):not(.rank3){
      background: linear-gradient(135deg, rgba(234, 231, 255, 0.92), rgba(220, 240, 255, 0.92));
      border:1px solid rgba(111, 80, 200, 0.18);
      box-shadow:
        0 14px 30px rgba(20,10,60,.10),
        0 0 0 1px rgba(255,255,255,.35) inset;
    }
    body.dark .lbItem.rank1{
      background:linear-gradient(90deg, rgba(255,215,0,.18), rgba(120,90,0,.20));
      box-shadow:0 0 10px rgba(255,215,0,.35);
    }
    body.dark .lbItem.rank2{
      background:linear-gradient(90deg, rgba(200,200,210,.18), rgba(70,70,90,.24));
      box-shadow:0 0 8px rgba(200,200,210,.32);
    }
    body.dark .lbItem.rank3{
      background:linear-gradient(90deg, rgba(205,127,50,.18), rgba(90,60,30,.22));
      box-shadow:0 0 8px rgba(205,127,50,.30);
    }
    body.dark .lbItem:not(.rank1):not(.rank2):not(.rank3){
      background: linear-gradient(135deg, rgba(52,46,82,0.96), rgba(46,44,70,0.92));
      border:1px solid rgba(255,255,255,.08);
      box-shadow:
        0 14px 30px rgba(0,0,0,.25),
        0 0 0 1px rgba(255,255,255,.06) inset;
    }
    @keyframes podiumGlowGold{
      0%{background-position:0% 50%; filter:brightness(1)}
      50%{background-position:100% 50%; filter:brightness(1.18)}
      100%{background-position:0% 50%; filter:brightness(1)}
    }
    @keyframes podiumGlowSilver{
      0%{background-position:0% 50%; filter:brightness(1)}
      50%{background-position:100% 50%; filter:brightness(1.12)}
      100%{background-position:0% 50%; filter:brightness(1)}
    }
    @keyframes podiumGlowBronze{
      0%{background-position:0% 50%; filter:brightness(1)}
      50%{background-position:100% 50%; filter:brightness(1.10)}
      100%{background-position:0% 50%; filter:brightness(1)}
    }

    /* Toasts -> rechts seitlich (Desktop/Fullscreen), Mobile oben */
    #toast{
      position: fixed;
      right: 16px;
      top: 110px;
      z-index: 9999;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
      max-width: min(420px, 92vw);
    }
    @media (max-width: 560px){
      #toast{
        left: 50%;
        right: auto;
        top: 10%;
        transform: translateX(-50%);
        align-items:center;
      }
    }
    .toast{
      width: 100%;
      background: rgba(255,255,255,.92);
      border:1px solid rgba(17,13,26,.12);
      border-radius: 20px;
      padding: 12px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.15);
      font-weight:1000;
      text-align:left;
      animation: toastIn var(--toastMs) ease forwards;
    }
    .toast small{display:block;font-weight:900;opacity:.75;margin-top:3px}
    @keyframes toastIn{
      0%{opacity:0; transform: translateY(-10px) scale(.96)}
      16%{opacity:1; transform: translateY(0) scale(1)}
      86%{opacity:1}
      100%{opacity:0; transform: translateY(-10px) scale(.98)}
    }

    /* Combo unlock modal (anchored near board) */
    #comboBack{
      position:fixed;
      inset:0;
      z-index: 100001;
      display:none;
      pointer-events:none;
    }
    .comboModal{
      position:fixed;
      max-width: min(420px, 92vw);
      background: rgba(255,255,255,.98);
      border:1px solid rgba(17,13,26,.12);
      border-radius: 18px;
      box-shadow: 0 18px 50px rgba(0,0,0,.18);
      padding: 14px 16px;
      pointer-events:auto;
    }
    body.dark .comboModal{
      background: rgba(32,28,46,.96);
      color:#f2f0ff;
      border:1px solid rgba(255,255,255,.08);
    }
    .comboRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      margin: 8px 0 4px;
    }
    .comboRow img{
      width: 36px;
      height: 36px;
      object-fit: contain;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.12));
    }
    .comboPlus{
      font-weight:1000;
      color:#ff4fb9;
      font-size: 18px;
    }
    #comboStory{ font-weight:900; opacity:.86; margin:6px 0 10px; }

    /* Combo list */
    #comboList{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .comboItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(17,13,26,.08);
      cursor:pointer;
      font-weight:900;
    }
    body.dark .comboItem{
      background: rgba(32,28,46,.9);
      border:1px solid rgba(255,255,255,.08);
      color:#f2f0ff;
    }
    .comboItem.locked{
      opacity:.65;
      cursor:default;
    }
    .comboIcons{
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:wrap;
    }
    .comboIcons img{
      width:26px;
      height:26px;
      object-fit:contain;
    }

    /* Modal */
    .modalBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(10,8,18,.55);
      z-index: 99998;
      padding: 18px;
    }
    .modal{
      width: min(760px, 96vw);
      max-height: min(82vh, 780px);
      overflow:auto;
      background: rgba(255,255,255,.96);
      border-radius: 24px;
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 28px 90px rgba(0,0,0,.25);
      padding: 14px 14px 12px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{font-weight:800; opacity:.9}
    .modal .foot{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      margin-top:12px;
    }
    .tiny{font-size:12px; opacity:.8; font-weight:900}

    /* Greeting */
    .greet{
      text-align:center;
      padding: 18px 14px 14px;
    }
    .greet input{
       width: 80%;
       max-width: 320px;
       margin: 10px auto;
       display:block;
       padding: 12px;
       border-radius: 12px;
       border: 1px solid rgba(17,13,26,.15);
       font-weight: 900;
       font-size: 16px;
       text-align:center;
       background: rgba(255,255,255,.9);
    }
    .greet img{
      width:min(380px, 82vw);
      height:auto;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,.14));
      margin: 4px auto 10px;
      display:block;
    }
    .greet h2{ margin: 6px 0 8px; }
    .greet .sub{
      font-weight:900;
      opacity:.8;
      margin: 0 auto 10px;
      max-width: 560px;
    }
    .greet .cta{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }

    /* Combo GIF Overlay (GIF only, no HTML particle spam) */
    .comboFx {
      position: absolute;
      width: 160px; height: 160px; /* JS will override per CELL */
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 999;
      display: none; /* shown by JS */
      align-items: center;
      justify-content: center;
    }
    .comboFx.show{ display:flex; }
    .comboSprite{
      position:absolute;
      width: 120px; height: 120px;
      transform: translate(-50%, -50%);
      pointer-events:none;
      z-index: 998;
      background-position: 0% 0%;
      background-repeat: no-repeat;
      display:block;
      animation:
        comboRainbow var(--rainbow-dur, 520ms) linear infinite,
        comboFlicker var(--flicker-dur, 320ms) ease-in-out infinite;
      animation-delay: var(--rainbow-delay, 0ms);
    }
    @keyframes comboRainbow{
      0%{ filter: sepia(1) saturate(var(--rainbow-sat, 3.2)) hue-rotate(calc(var(--rainbow-hue, 0deg) + 0deg)) brightness(var(--rainbow-br, 1.05)); }
      100%{ filter: sepia(1) saturate(var(--rainbow-sat, 3.2)) hue-rotate(calc(var(--rainbow-hue, 0deg) + 360deg)) brightness(var(--rainbow-br, 1.05)); }
    }
    @keyframes comboFlicker{
      0%{ opacity: 1; transform: translate(-50%, -50%) rotate(var(--combo-rot, 0deg)) scale(1); }
      12%{ opacity: 0.78; transform: translate(-50%, -50%) rotate(calc(var(--combo-rot, 0deg) + var(--combo-wiggle, 0deg))) scale(1.1); }
      25%{ opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--combo-rot, 0deg) - var(--combo-wiggle, 0deg))) scale(0.92); }
      45%{ opacity: 0.7; transform: translate(-50%, -50%) rotate(calc(var(--combo-rot, 0deg) + var(--combo-wiggle, 0deg))) scale(1.16); }
      60%{ opacity: 1; transform: translate(-50%, -50%) rotate(calc(var(--combo-rot, 0deg) - var(--combo-wiggle, 0deg))) scale(0.9); }
      78%{ opacity: 0.8; transform: translate(-50%, -50%) rotate(calc(var(--combo-rot, 0deg) + var(--combo-wiggle, 0deg))) scale(1.08); }
      100%{ opacity: 1; transform: translate(-50%, -50%) rotate(var(--combo-rot, 0deg)) scale(1); }
    }

    /* Death GIF Overlay */
    .deathFx{
      position:absolute;
      width: 160px; height: 160px; /* JS will override */
      transform: translate(-50%, -50%);
      pointer-events:none;
      z-index: 998;
      background-position:center;
      background-size:contain;
      background-repeat:no-repeat;
      display:none;
    }
    .deathFx.show{ display:block; }
    .comboScore {
      font-size: 32px;
      font-weight: 900;
      color: #9d4edd;
      text-shadow: 0 0 10px #e0aaff, 2px 2px 0px #fff;
      animation: popScore 0.8s ease-out forwards;
      margin-top: -20px; /* Center it nicely over the burst */
    }
    @keyframes popScore {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1.0); opacity: 0; }
    }

    /* FX star */
    .star{
      position:absolute;
      left:0; top:0;
      width: 12px; height: 12px;
      transform: translate(-50%, -50%) scale(.6);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.2));
      clip-path: polygon(50% 0%, 62% 30%, 100% 50%, 62% 70%, 50% 100%, 38% 70%, 0% 50%, 38% 30%);
      animation: starPop 820ms ease forwards;
      filter: drop-shadow(0 0 8px rgba(255,255,255,.8)); /* Brighter flash */
    }
    @keyframes starPop{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.4) rotate(0deg)}
      20%{opacity:1; transform:translate(-50%,-50%) scale(1) rotate(20deg)}
      100%{opacity:0; transform:translate(-50%,-75%) scale(.9) rotate(160deg)}
    }

    .ring{
      position:absolute; left:0; top:0;
      width: 10px; height: 10px;
      border-radius:999px;
      border: 3px solid rgba(255,255,255,.95);
      box-shadow: 0 0 30px rgba(255,79,185,.28);
      transform: translate(-50%,-50%) scale(.4);
      opacity:0;
      animation: ring 720ms ease-out forwards;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes ring{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.35)}
      15%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(4.2)}
    }

    /* Fullscreen */
    body.fs{ overflow:hidden; }
    body.fs #page,
    body.maximized #page{
      height: var(--app-height, 100vh);
      overflow:hidden;
    }
    body.fs #app{ width: min(1200px, 98vw); margin: 10px auto; }
    body.fs #boardWrap{
      min-height: var(--app-height, 100vh);
      padding-top: calc(84px + var(--safe-top));
      padding-bottom: calc(12px + var(--safe-bottom));
      padding-left: calc(8px + var(--safe-left));
      padding-right: calc(8px + var(--safe-right));
    }

    /* FS HUD: left / center / right */
    #fsHud{
      position:absolute;
      left: calc(14px + var(--safe-left));
      right: calc(14px + var(--safe-right));
      top: calc(12px + var(--safe-top));
      z-index: 60;
      display:none;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    body.fs #fsHud{display:flex}

    .hudLeft, .hudCenter, .hudRight{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .hudCenter{
      justify-content:center;
      flex: 1;
      min-width: 240px;
    }

    .hudChip{
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      font-weight:1000;
      font-size: 13px;
      white-space:nowrap;
      pointer-events:none;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    @keyframes chipFade{
      0%,100%{ opacity:.92; }
      50%{ opacity:1; }
    }
    .hudChip.color{
      background: linear-gradient(135deg, rgba(255,79,185,.88), rgba(122,216,255,.86));
      color:#fff;
      border:1px solid rgba(255,255,255,.35);
      background-size: 200% 200%;
      animation: hudGlow 3.2s ease-in-out infinite;
      opacity:1;
    }
    @keyframes hudGlow{
      0%{ background-position: 0% 50%; }
      50%{ background-position: 100% 50%; }
      100%{ background-position: 0% 50%; }
    }

    .hudProg{
      pointer-events:none;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(17,13,26,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.12);
      min-width: min(520px, 70vw);
      justify-content:center;
    }
    .hudProg .pbar{
      flex:1;
      height: 12px;
      border-radius:999px;
      overflow:hidden;
      background: rgba(140,120,200,.18);
      border:1px solid rgba(60,20,120,.10);
      min-width: 160px;
    }
    .hudProg .pbar i{
      display:block;height:100%;width:0%;
      border-radius:999px;
      background: linear-gradient(90deg,#ff4fb9,#ffcf5a,#7ad8ff,#8b5cf6,#ff4fb9);
      background-size: 300% 100%;
      animation: barHue 3.2s linear infinite;
      transition: width .25s ease;
      box-shadow:0 0 18px rgba(255,79,185,.22);
    }

    .hudBtn{
      pointer-events:auto;
      height: 40px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(17,13,26,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 14px 34px rgba(0,0,0,.12);
      font-weight:1000;
      cursor:pointer;
      animation: chipFade 3.2s ease-in-out infinite;
    }
    .hudBtn.mini{
      height: 30px;
      padding: 0 10px;
      font-size: 12px;
    }
      #fsToggleUi{
        background: linear-gradient(135deg, rgba(255,220,80,.94), rgba(255,120,220,.88));
        color:#2b1b4f;
        border:1px solid rgba(255,255,255,.45);
      }
    body.fs #fsHud .hudChip{
      color:#fff;
      background: rgba(30,24,48,.72);
      border:1px solid rgba(255,255,255,.20);
      text-shadow: 0 1px 2px rgba(0,0,0,.45);
    }
    body.fs #fsHud .hudProg{
      background: rgba(30,24,48,.72);
      border:1px solid rgba(255,255,255,.20);
    }
    body.fs #fsHud .hudProg .tiny,
    body.fs #fsHud #hudPct{
      color:#fff;
      text-shadow: 0 1px 2px rgba(0,0,0,.45);
    }
    body.fs #fsHud .hudBtn{
      color:#fff;
    }
    .hudBtn:hover{ animation: jello-horizontal .9s both; }

    /* Colored fullscreen buttons */
    .hudBtn.exit{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,130,130,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
    .hudBtn.guide{
      background: linear-gradient(135deg, rgba(90,170,255,.92), rgba(140,220,255,.86));
      color:#fff;
      border: 1px solid rgba(255,255,255,.28);
    }
      .hudBtn.hint{
        background: linear-gradient(135deg, rgba(255,79,185,.92), rgba(255,170,230,.86));
        color:#fff;
        border: 1px solid rgba(255,255,255,.28);
        animation: pulseBtn 2s infinite;
      }
      /* FX Light: reduce heavy effects for smoother dragging */
      body.fxLight .tile{ transition: transform 140ms ease; }
      body.fxLight .tile img{ filter: none; }
      body.fxLight .plate:before{ opacity: .6; }
      body.fxLight .hudBtn{ animation: none; }
      body.fxLight #board{ filter: none; }
    @keyframes pulseBtn{
      0%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0.7); }
      70%{ transform:scale(1.05); box-shadow: 0 0 0 10px rgba(255,79,185, 0); }
      100%{ transform:scale(1); box-shadow: 0 0 0 0 rgba(255,79,185, 0); }
    }

    /* Mobile/Tablet fullscreen layout */
    @media (max-width: 820px){
      body.fs #boardWrap{ padding-top: 2px; padding-bottom: 90px; min-height: var(--app-height, 100vh); }
      #fsHud{
        top:auto;
        bottom: calc(10px + var(--safe-bottom));
        left: calc(6px + var(--safe-left));
        right: calc(6px + var(--safe-right));
        align-items:flex-end;
        justify-content:center;
        gap:6px;
      }
      .hudLeft, .hudCenter, .hudRight{ justify-content:center; width:100%; }
      .hudProg{ min-width:0; width:100%; padding:6px 8px; }
      .hudProg .pbar{ min-width:0; }
      .hudBtn{ height:44px; padding:0 14px; }
    }
    @media (max-width: 520px){
      .hudChip{ font-size:12px; padding:6px 8px; }
      .hudBtn{ height:40px; padding:0 10px; font-size:12px; }
    }
    @media (orientation: portrait) and (min-width: 600px){
      body.fs #boardWrap{ padding-top: 16px; padding-bottom: 110px; }
      .hudProg{ min-width: min(560px, 92vw); }
    }
    @media (max-height: 720px){
      body.fs #boardWrap{ padding-top: 8px; padding-bottom: 90px; min-height: var(--app-height, 100vh); }
      #fsHud{
        top:auto;
        bottom: calc(10px + var(--safe-bottom));
        left: calc(6px + var(--safe-left));
        right: calc(6px + var(--safe-right));
        align-items:flex-end;
        justify-content:center;
        gap:6px;
      }
      .hudLeft, .hudCenter, .hudRight{ justify-content:center; width:100%; }
      .hudProg{ min-width:0; width:100%; padding:6px 8px; }
      .hudProg .pbar{ min-width:0; }
      .hudBtn{ height:44px; padding:0 14px; }
    }

    /* Better large screen FS */
    @media (min-width: 1600px) and (min-height: 900px){
       body.fs #boardWrap{ padding-top: 60px; padding-bottom: 40px; min-height: 100vh; }
       #scrollBg{ min-height: 150vh; }
    }
    @media (min-height: 1400px){
       body.fs #boardWrap{ min-height: 1500px; justify-content:center; }
    }
  

    /* Maximize HUD (shown in body.maximized) */
    #maxHud{
      display:none;
      position:fixed;
      left:50%;
      top:10px;
      transform: translateX(-50%);
      z-index:99998;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding:10px 12px;
      border-radius:18px;
      background: rgba(255,255,255,.86);
      border:1px solid rgba(17,13,26,.10);
      box-shadow: 0 16px 40px rgba(20,10,60,.10);
      backdrop-filter: blur(10px);
    }
    body.dark #maxHud{
      background: rgba(40,35,60,.86);
      border:1px solid rgba(255,255,255,.12);
    }
    body.maximized #maxHud{ display:flex; }

    #maxHud .pill{
      padding:8px 10px;
      border-radius:14px;
      background: rgba(255,255,255,.72);
      border:1px solid rgba(17,13,26,.08);
      font-weight:900;
      display:flex; gap:6px; align-items:center;
    }
    body.dark #maxHud .pill{
      background: rgba(30,26,45,.72);
      border:1px solid rgba(255,255,255,.10);
    }


    /* Luvvies cards: subtle per-character background to make them easier to recognize */
    .luvCard.hasPal{
      background:
        linear-gradient(145deg, rgba(255,255,255,.88), rgba(255,255,255,.70)),
        radial-gradient(circle at 20% 20%, var(--c1, #ffffff), transparent 55%),
        radial-gradient(circle at 80% 80%, var(--c2, #f2f3ff), transparent 60%);
    }
    body.dark .luvCard.hasPal{
      background:
        linear-gradient(145deg, rgba(40,35,60,.86), rgba(30,26,45,.80)),
        radial-gradient(circle at 20% 20%, color-mix(in srgb, var(--c1, #ffffff) 30%, transparent), transparent 60%),
        radial-gradient(circle at 80% 80%, color-mix(in srgb, var(--c2, #ffffff) 25%, transparent), transparent 65%);
      border:1px solid rgba(255,255,255,.10);
    }
    /* Mobile Optimization: Portrait Compact */
    @media (max-width: 640px) and (orientation: portrait) {
      .topRow { margin-top: 4px; padding: 8px; }
      .stats { margin-top: 6px; gap: 4px; }
      .progressRow { margin-top: 6px; padding: 6px 8px; }
      .playArea { margin-top: 6px; padding: 4px; }
      #boardWrap { padding: 2px; }
    }

    /* Mobile Optimization: Landscape Side Layout */
    @media (max-width: 900px) and (orientation: landscape) and (max-height: 600px) {
      #app {
        display: grid;
        grid-template-columns: 74px 1fr 50px;
        grid-template-rows: auto 1fr;
        grid-template-areas:
          "top top top"
          "stats play prog";
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0 4px 4px;
        gap: 4px;
        align-content: start;
      }
      .topRow { grid-area: top; margin: 0; margin-bottom: 2px; padding: 4px 8px; border-radius: 0 0 12px 12px; }
      .stats {
        grid-area: stats;
        display: flex !important;
        flex-direction: column;
        gap: 4px;
        margin: 0;
        padding: 0;
        grid-template-columns: none;
      }
      .stat { 
        padding: 2px 4px; 
        min-height: 36px; 
        font-size: 10px;
        border-radius: 10px;
      }
      .stat .k { font-size: 9px; }
      .stat .v { font-size: 13px; }
      
      .progressRow {
        grid-area: prog;
        margin: 0;
        flex-direction: column-reverse;
        width: 100%;
        height: 100%;
        padding: 8px 4px;
        justify-content: center;
      }
      .progressRow b { writing-mode: vertical-rl; transform: rotate(180deg); margin-bottom: 6px; font-size: 10px; }
      .bar { width: 12px; height: 100%; flex:1; }
      .bar > i { width: 100%; height: var(--pct, 0%); }
      .pct { writing-mode: vertical-rl; transform: rotate(180deg); margin-top: 6px; min-width: 0; text-align: center; }
      
      .playArea { grid-area: play; margin: 0; height: 100%; border-radius: 12px; }
      .below { display: none; }
      #boardWrap { min-height: 0; height: 100%; padding: 2px; }
    }
    /* Fix FS HUD Mobile Top Position & Width & Draggable */
    @media (max-width: 820px), (max-height: 720px) {
      body.fs #fsHud {
        top: calc(10px + var(--safe-top));
        bottom: auto;
        flex-wrap: nowrap;
        align-items: center;
        background: rgba(255,255,255,0.85);
        border-radius: 999px;
        padding: 4px 10px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        pointer-events: auto;
        width: fit-content;
        max-width: 96vw;
        justify-content: center;
        left: 50%;
        transform: translateX(-50%);
        touch-action: none;
      }
      body.dark.fs #fsHud {
        background: rgba(30,24,48,0.85);
      }
      body.fs #fsHud .hudLeft, 
      body.fs #fsHud .hudRight { display: flex; transform: scale(0.85); gap: 4px; }
      body.fs #fsHud .hudProg { min-width: 120px; width: 140px; }
      body.fs #fsHud .hudChip { padding: 4px 8px; font-size: 11px; }
      body.fs #fsHud .hudBtn { height: 32px; padding: 0 8px; font-size: 11px; }
    }
</style>
</head>

<body>
  <button id="globalThemeBtn" type="button">Light</button>
  <button id="debugBtn" type="button">Debug</button>
  <!-- ROGUELIKE OVERLAYS -->
  <div id="townView" style="position:fixed; inset:0; background:#151326; z-index:320000; display:none; flex-direction:column; align-items:center; padding:20px; color:white; overflow-y:auto;">
      <div class="townWrap">
          <div class="townHeader">
              <div>
                  <h2 style="margin:0 0 6px;">Stadt</h2>
                  <div class="tiny" id="townSub">Meta-Progression und Upgrades</div>
              </div>
              <div class="townRes" id="townResources"></div>
          </div>
          <div class="townSection">
              <div class="townSectionHead">
                  <h3 style="margin:0;">Run-Schwierigkeit</h3>
                  <div class="tiny" id="townDiffHint">Easy ist frei.</div>
              </div>
              <div class="townDiffRow">
                  <div class="diffPills" id="townDiffPills">
                      <input type="radio" name="rogueDiff" id="td_easy" value="easy"><label for="td_easy">Easy</label>
                      <input type="radio" name="rogueDiff" id="td_normal" value="normal"><label for="td_normal">Normal</label>
                      <input type="radio" name="rogueDiff" id="td_hard" value="hard"><label for="td_hard">Hard</label>
                      <input type="radio" name="rogueDiff" id="td_shock" value="shock"><label for="td_shock">Zuckerschock</label>
                  </div>
              </div>
          </div>
          <div id="townBuildings" class="townGrid"></div>
          <div class="townSection">
              <div class="townSectionHead">
                  <h3 style="margin:0;">Helden freischalten</h3>
                  <div class="tiny" id="townHeroUnlockHint">Mehr Luvvies = mehr Kombos.</div>
              </div>
              <div id="townHeroes" class="townGrid heroGrid"></div>
          </div>
          <div class="townSection">
              <div class="townSectionHead">
                  <h3 style="margin:0;">Helden-Kombos</h3>
                  <div class="tiny" id="townHeroName">Waehle erst einen Helden.</div>
              </div>
              <div id="townCombos" class="townGrid combosGrid"></div>
          </div>
          <div class="townSection">
              <div class="townSectionHead">
                  <h3 style="margin:0;">Marktplatz</h3>
                  <div class="tiny">Tausche Ressourcen. Markt-Level verbessert die Raten.</div>
              </div>
              <div id="townMarket" class="townGrid marketGrid"></div>
          </div>
          <div class="townActions">
              <button class="Btn secondary" id="townStartRun">Run starten</button>
              <button class="Btn ghost" id="townContinueRun" style="display:none;">Run fortsetzen</button>
          </div>
      </div>
  </div>
  <div id="charView" style="position:fixed; inset:0; background:#1a1a2e; z-index:300000; display:none; flex-direction:column; align-items:center; justify-content:center; color:white; overflow-y:auto; padding:20px;">
      <h2>Wähle deinen Helden</h2>
      <div id="charList"></div>
      <button class="Btn secondary" onclick="rogueEngine.confirmChar()">Abenteuer Starten</button>
  </div>

  <div id="mapView" style="position:fixed; inset:0; background:#2c1e3b; z-index:250000; display:none; flex-direction:column; align-items:center; padding:20px; color:white; overflow-y:auto;">
      <div style="display:flex; justify-content:space-between; width:100%; max-width:500px; margin-bottom:20px;">
          <span>Biome: <b id="mapBiomeName">Wald</b></span>
          <span>Gold: <b id="mapGold">0</b></span>
      </div>
      <div id="mapGraph">
          <svg id="mapLines" aria-hidden="true"></svg>
          <div id="mapNodes"></div>
          <div id="mapFog" aria-hidden="true"></div>
      </div>
  </div>

  <div id="shopView" style="position:fixed; inset:0; background:#16213e; z-index:280000; display:none; flex-direction:column; align-items:center; padding:20px; color:white;">
      <div class="shopWrap">
          <div class="shopHeader">
              <div class="shopTitle">
                  <img id="shopHostImg" class="shopHost" src="" alt="Lovelie">
                  <div>
                      <h2 class="shopName" style="margin:0;">Lovelies Laden</h2>
                      <div class="shopLine" id="shopLine">Willkommen im Shop!</div>
                  </div>
              </div>
              <div class="shopStats">
                  <div class="shopStat">Gold: <b id="shopGold">0</b></div>
                  <div class="shopStat">HP: <b id="shopHp">0</b></div>
              </div>
          </div>
          <div class="shopBanner">
              <img id="shopCandyImg" class="shopCandy" src="" alt="">
              <div class="shopBubble" id="shopBubble">Schau dich um!</div>
              <div class="shopDecor">
                  <img id="shopDecor1" class="shopDecorImg" src="" alt="">
                  <img id="shopDecor2" class="shopDecorImg" src="" alt="">
                  <img id="shopDecor3" class="shopDecorImg" src="" alt="">
              </div>
          </div>
          <div id="shopContent" class="shopGrid"></div>
          <div id="shopNotes" class="shopNotes"></div>
          <button class="Btn ghost" id="shopBackBtn">Zurueck zur Map</button>
      </div>
  </div>

  <div id="gameView" style="display:none; width:100%; height:100%;">
    <!-- Main Board will be here -->
  </div>

  <div id="page">
    <div id="scrollBg"></div>
    <div id="globalBg"></div>
    <div id="darkOverlay"></div>
    <div id="toast"></div>

    <div class="modalBack" id="greetBack">
      <div class="modal greet">
        <img id="greetLogo" alt="Logo" />
        <h2>Willkommen bei Luvvies Crush 🍭</h2>
        <div class="sub">
          Süßes Chaos, geheime Kombos & Boss‑Momente ✨<br>
          Finde neue Kombinationen, schalte Steckbriefe frei und jag die Bestenliste.
        </div>
        <input id="greetName" placeholder="Dein Name" maxlength="24" />
        <div class="cta">
          <button class="Btn secondary" id="greetPlay">Spielen</button>
          <button class="Btn ghost" id="greetGuide">Anleitung</button>
        </div>
        <div class="tiny" style="margin-top:10px;">(Dieser Screen erscheint ca. alle 3 Stunden.)</div>
      </div>
    </div>

    <div class="modalBack" id="introBack">
      <div class="modal">
        <h2>So spielst du Luvvies Crush 🍭</h2>
        <div style="font-weight:900; opacity:.85; margin-bottom:12px;">Ein knuffiges Puzzle-Abenteuer!</div>
        
        <div class="panel" style="margin-bottom:10px;">
           <h3>Grundlagen</h3>
           <ul>
             <li><b>Verschiebe</b> Luvvies, um 3 oder mehr Gleiche zu matchen.</li>
             <li><b>Zieh Menüs weg:</b> Das Menü und die Toast-Nachrichten kannst du einfach per Drag & Drop verschieben, wenn sie im Weg sind!</li>
             <li><b>4er/5er Matches</b> erschaffen Powerups (Würmer, Citrussies, Koalas).</li>
           </ul>
        </div>

        <div class="panel" style="margin-bottom:10px;">
           <h3>Tipps & Tricks</h3>
           <ul>
             <li><b>Kombiniere Powerups</b> (z.B. Koala + Wurm) für riesige Effekte!</li>
             <li><b>Mellows</b> (die kleinen Geister) sind keine Gegner – du kannst sie <b>gratis bewegen</b>, um Kombos zu bauen.</li>
             <li><b>Entdecke Secrets:</b> Manche Luvvies haben geheime Synergien (z.B. Sweety + Sleepy). Probier alles aus!</li>
           </ul>
        </div>

        <div class="panel">
           <h3>Menü-Guide</h3>
           <ul style="list-style:none; padding-left:4px;">
             <li>💡 <b>Hint:</b> Zeigt dir einen möglichen Zug (kostet 1 Move).</li>
             <li>🌈 <b>Farben:</b> Würfelt die Farben deiner Luvvies neu (nur Optik).</li>
             <li>🌙 <b>Theme:</b> Wechselt zwischen Tag- und Nachtmodus.</li>
             <li>⚙️ <b>Optionen:</b> Einstellungen, Grafik & Speicherstand.</li>
           </ul>
        </div>

        <div class="foot">
          <button class="Btn ghost" id="introClose">Verstanden!</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="gameOverBack" style="z-index:99999;">
      <div class="modal" style="text-align:center;">
        <h2 style="font-size:32px;margin-bottom:4px;">GAME OVER 😵</h2>
        
        <div style="display:flex;align-items:center;justify-content:center;gap:14px;margin-bottom:10px;">
           <img id="goZillaLeft" style="height:110px;transform:scaleX(-1);filter:drop-shadow(0 10px 20px rgba(0,0,0,.2));object-fit:contain;" alt="">
           <div style="font-weight:900;font-size:24px;opacity:.4;font-style:italic;">VS</div>
           <img id="goZillaRight" style="height:110px;filter:drop-shadow(0 10px 20px rgba(0,0,0,.2));object-fit:contain;" alt="">
        </div>

        <div class="sub" style="font-size:16px;margin-bottom:18px;max-width:320px;margin-left:auto;margin-right:auto;line-height:1.4;">
           Schade, die Mellows haben gewonnen.<br>Versuch es nochmal!
        </div>

        <div class="stat" style="margin:0 auto 18px; max-width:200px;">
           <div class="k">Final Score</div>
           <div class="v" id="goScore">0</div>
        </div>

        <input id="goName" placeholder="Dein Name" maxlength="24" style="width:80%;max-width:320px;margin:0 auto 14px;display:block;padding:12px;border-radius:12px;border:1px solid rgba(17,13,26,.15);font-weight:900;font-size:16px;text-align:center;background:rgba(255,255,255,.9);" />

        <div class="cta" style="justify-content:center;gap:12px;">
           <button class="Btn" id="goPost">Score Posten</button>
           <button class="Btn ghost" id="goContinue" style="display:none;">Weiter</button>
           <button class="Btn secondary" id="goNew">Neues Spiel</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="infoBack">
      <div class="modal">
        <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
          <img id="infoImg" src="" alt=""
               style="width:172px;height:172px;object-fit:contain;filter:drop-shadow(0 18px 28px rgba(0,0,0,.18));">
          <div style="min-width:240px;">
            <h2 id="infoName" style="margin:0 0 6px">—</h2>
            <div class="tiny" id="infoTag">—</div>
            <div style="height:10px"></div>
            <div class="panel" style="padding:10px; border-radius:18px;">
              <b>Ability</b>
              <div id="infoAbility" style="margin-top:6px;font-weight:900;opacity:.9;">—</div>
            </div>
            <div style="height:10px"></div>
            <div class="panel" style="padding:10px; border-radius:18px;">
              <b>Kombo</b>
              <div id="infoCombo" style="margin-top:6px;font-weight:900;opacity:.9;">—</div>
            </div>
          </div>
        </div>

        <p id="infoStory" style="margin:12px 0 10px;font-weight:900;opacity:.9;">—</p>

        <div class="panel" style="padding:10px; border-radius:18px;">
          <b>3 Sprüche</b>
          <ul id="infoLines" style="margin:8px 0 0; padding-left:18px;"></ul>
        </div>

        <p class="tiny" style="margin:10px 0 0;">(Platzhalter) Später: Plushie-Shop Link ✨</p>
        <div class="foot">
          <button class="Btn ghost" id="infoClose">Schließen</button>
        </div>
      </div>
    </div>

    <div id="comboBack">
      <div class="comboModal" id="comboModal">
        <h3 id="comboTitle" style="margin:0 0 4px;">Neue Kombo!</h3>
        <div class="comboRow" id="comboIcons"></div>
        <div class="tiny" id="comboStory"></div>
        <div class="foot" style="margin-top:10px; display:flex; justify-content:flex-end;">
          <button class="Btn secondary" id="comboOk">Okay</button>
        </div>
      </div>
    </div>

    <div id="debugView">
      <div class="debugModal">
        <h3 style="margin:0;">Debug Tools</h3>
        <div class="tiny">Values add to current resources.</div>
        <div class="debugGrid" style="margin-top:8px;">
          <label>Meta Gold
            <input id="dbgGold" type="number" value="0">
          </label>
          <label>Meta Wood
            <input id="dbgWood" type="number" value="0">
          </label>
          <label>Meta Stone
            <input id="dbgStone" type="number" value="0">
          </label>
          <label>Meta Essence
            <input id="dbgEssence" type="number" value="0">
          </label>
          <label>Run Gold
            <input id="dbgRunGold" type="number" value="0">
          </label>
          <label>Run HP
            <input id="dbgRunHp" type="number" value="0">
          </label>
          <label>Run Max HP
            <input id="dbgRunMaxHp" type="number" value="0">
          </label>
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button class="Btn ghost" id="debugClose">Close</button>
          <button class="Btn secondary" id="debugApply">Apply</button>
        </div>
      </div>
    </div>

    <div class="modalBack" id="settingsBack">
      <div class="modal" style="position:relative;">
         <button id="menuCloseX" style="position:sticky;top:0;float:right;z-index:100;background:rgba(255,255,255,0.95);border-radius:50%;width:40px;height:40px;border:2px solid #ff4fb9;color:#ff4fb9;font-size:28px;font-weight:bold;cursor:pointer;line-height:1;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 10px rgba(0,0,0,0.15);margin:-6px -6px 10px 10px;">×</button>
         <h2 style="margin-right:30px;">Optionen</h2>

         <div class="panel" style="margin-bottom:10px;">
            <h3>Grafik & FX</h3>
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
               <b>FX Dimmer</b>
               <input type="range" id="fxSlider" min="0" max="100" value="0" style="flex:1">
            </div>
            <div style="display:flex;align-items:center;gap:10px;">
               <b>FX Light (Performance)</b>
               <input type="checkbox" id="fxLightToggle">
            </div>
         </div>

         <div class="panel" style="margin-bottom:10px;">
            <h3>Spiel</h3>
            <div class="cta" style="justify-content:flex-start;gap:10px;flex-wrap:wrap;">
               <button class="Btn secondary" id="menuNew">Neuer Run</button>
               <button class="Btn ghost" id="menuMap">Zur Map</button>
               <button class="Btn ghost" id="menuIntro">Anleitung</button>
               <button class="Btn ghost" id="menuHint">Hint</button>
            </div>
         </div>



         <div class="panel">
            <h3>Deine Luvvies</h3>
            <div class="luvGrid" id="menuLuvGrid"></div>
         </div>
      </div>
    </div>

    <div class="modalBack" id="fsMenuBack" style="z-index:99999;">
      <div class="modal">
         <h2>Pause</h2>
         <div class="tiny" style="margin-bottom:12px;">Fullscreen Menü</div>

         <div class="panel" style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <b>FX Dimmer</b>
            <input type="range" id="fsMenuFx" min="0" max="100" value="0" style="flex:1">
         </div>
         <div class="panel" style="margin-bottom:12px; display:flex; align-items:center; gap:10px;">
            <b>FX Light</b>
            <input type="checkbox" id="fsMenuFxLight">
         </div>

         <div class="panel" style="margin-bottom:12px;">
            <h3>Secret Kombos</h3>
            <div class="tiny" id="fsMenuTips"></div>
         </div>

         <div class="cta" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
            <button class="Btn secondary" id="fsMenuClose">Weiter</button>
            <button class="Btn ghost" id="fsMenuMap">Zur Map</button>
            <button class="Btn ghost" id="fsMenuIntro">Anleitung</button>
            <button class="Btn ghost" id="fsMenuLuv">Luvvies</button>
         </div>
         <div class="panel fsQuickRow" style="margin-top:12px; display:flex; align-items:center; justify-content:center; gap:10px;">
            <button class="hudBtn mini" id="fsMenuMax" title="Maximize">⛶</button>
            <button class="hudBtn mini" id="fsMenuReroll" title="Farben neu wuerfeln">🌈</button>
            <button class="hudBtn mini" id="fsMenuTheme" title="Theme">🌙</button>
         </div>
         <div style="margin-top:12px; text-align:center;">
            <button class="Btn ghost" onclick="document.exitFullscreen()">Exit Fullscreen</button>
         </div>
      </div>
    </div>

    <div id="app">
      <div class="topRow" style="position:relative;">
        <div class="diffWrap">
          <div class="diffPills" id="diffPills">
            <input type="radio" name="diff" id="d_easy" value="easy" checked><label for="d_easy">Easy</label>
            <input type="radio" name="diff" id="d_normal" value="normal"><label for="d_normal">Normal</label>
            <input type="radio" name="diff" id="d_hard" value="hard"><label for="d_hard">Hard</label>
            <input type="radio" name="diff" id="d_shock" value="shock"><label for="d_shock">Zuckerschock</label>
          </div>
          <button class="Btn ghost" id="btnHintTop" title="Hint (kostet 1 Move)" style="margin-left:8px;">💡</button>
        </div>

        <img id="mainLogo" alt="Luvvies Crush" style="height:90px;width:auto;position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);z-index:10;filter:drop-shadow(0 10px 20px rgba(0,0,0,.15));pointer-events:none;display:block;" />

        <div class="actions">
          <button class="Btn ghost" id="btnMax" title="Maximize Board">⛶</button>
          <button class="Btn ghost" id="btnReroll" title="Farben neu würfeln" style="padding:0 12px;min-width:46px;">🌈</button>
          <button class="Btn ghost" id="btnSaveColors" title="Farben speichern" style="padding:0 12px;min-width:46px;">💾</button>
          <button class="Btn ghost" id="btnTheme" style="padding:0 12px;min-width:46px;">🌙</button>
          <button class="Btn" id="btnMenu">Optionen</button>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><div class="k">Level</div><div class="v" id="uiLevel">1</div></div>
        <div class="stat"><div class="k">Ziel</div><div class="v" id="uiGoal">4000</div></div>
        <div class="stat"><div class="k">Score</div><div class="v" id="uiScore">0</div></div>
        <div class="stat"><div class="k">Moves</div><div class="v" id="uiMoves">30</div></div>
        <div class="stat"><div class="k">Combo</div><div class="v" id="uiCombo">x1</div></div>
      </div>

      <div class="progressRow">
        <b>Fortschritt zum Ziel</b>
        <div class="bar"><i id="uiBar"></i></div>
        <div class="pct" id="uiPct">0%</div>
      </div>

      <div id="rogueEnemy" class="rogueEnemy">
        <div class="enemyPortrait">
          <img id="enemyImg" src="" alt="">
        </div>
        <div class="enemyMeta">
          <div class="enemyTitle">
            <span id="enemyName">Gegner</span>
            <span id="enemyTier" class="enemyTier">—</span>
          </div>
          <div class="enemyDesc" id="enemyDesc">—</div>
          <div class="enemyTags">
            <span class="enemyTag" id="enemyBiome">—</span>
            <span class="enemyTag" id="enemyHazard">—</span>
          </div>
        </div>
      </div>

      <div class="playArea" id="playArea">
        <div id="boardWrap">
          <div id="fsBg"></div>
          <div id="board"></div>
          <div id="fxLayer"></div>

          <div id="fsHud">
            <div class="hudLeft">
              <div class="hudChip color" id="hudLevel">Level 1</div>
              <div class="hudChip color" id="hudScore">Score 0</div>
              <div class="hudChip color" id="hudMoves">Moves 0</div>
              <div class="hudChip color" id="hudCombo">Combo x1</div>
            </div>

            <div class="hudCenter">
              <div class="hudProg">
                <div class="tiny" style="opacity:.85;">Ziel</div>
                <div class="pbar"><i id="hudBar"></i></div>
                <div class="tiny" id="hudPct" style="min-width:40px;text-align:right;">0%</div>
              </div>
            </div>

            <div class="hudRight">
              <button class="hudBtn hint" id="fsHint">💡</button>
              <button class="hudBtn" id="fsReroll" title="Farben neu würfeln">🌈</button>
              <button class="hudBtn" id="fsTheme" title="Theme">🌙</button>
              <button class="hudBtn" id="fsSaveColors" title="Farben speichern">💾</button>
              <button class="hudBtn" id="fsMenuBtn">Optionen</button>
              <button class="hudBtn exit" id="fsExit">Exit</button>
            </div>
          </div>
        </div>
      </div>
        <!-- Maximize HUD: visible when board is maximized (so you still see score + can go back) -->
        <div id="maxHud">
          <button class="hudBtn exit" id="btnUnmax">Zurück</button>
          <div class="pill"><b>Lvl</b> <span id="maxLvl">1</span></div>
          <div class="pill"><b>Score</b> <span id="maxScore">0</span></div>
          <div class="pill"><b>Moves</b> <span id="maxMoves">0</span></div>
          <div class="pill"><b>Combo</b> <span id="maxCombo">x1</span></div>
          <button class="hudBtn hint" id="maxHint">Hint</button>
        </div>


      <div class="below">
        <div class="panel" id="luvPanel">
          <h3 style="display:flex;justify-content:space-between;align-items:center;">
            <span>Deine Luvvies <span class="tiny">(anklicken für Steckbrief)</span></span>
            <button class="Btn ghost mini" id="btnResetColors" style="height:30px;font-size:12px;padding:0 10px;">Farben Reset</button>
          </h3>
          <div class="luvGrid" id="luvMenu"></div>
        </div>

        <div class="panel" id="rightPanel">
          <div>
            <h3>Secret Kombos</h3>
            <div id="comboList" class="tiny" style="margin-top:6px;"></div>
          </div>
          <div style="height:1px;background:rgba(17,13,26,.08);"></div>
          <div style="display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
               <h3 style="margin:0;" id="lbTitle">Leaderboard</h3>

               <!-- Leaderboard filter tabs (like the difficulty pills above) -->
               <div class="diffPills" id="lbTabs">
                 <input type="radio" name="lbDiff" id="lb_easy" value="easy" checked><label for="lb_easy">Easy</label>
                 <input type="radio" name="lbDiff" id="lb_normal" value="normal"><label for="lb_normal">Normal</label>
                 <input type="radio" name="lbDiff" id="lb_hard" value="hard"><label for="lb_hard">Hard</label>
                 <input type="radio" name="lbDiff" id="lb_shock" value="shock"><label for="lb_shock">Zuckerschock</label>
               </div>

               <!-- Keep select for compatibility, but hide it (tabs drive the selection) -->
               <select id="lbDiffSelect" style="display:none;">
                 <option value="easy">Easy</option>
                 <option value="normal">Normal</option>
                 <option value="hard">Hard</option>
                 <option value="shock">Zuckerschock</option>
               </select>
            </div>
            <div class="lbRow">
              <input id="lbName" maxlength="24" placeholder="Dein Name (z.B. KOALAaufPILLEN)" />
              <label class="tiny" style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" id="lbAuto" checked>
                Auto-Post bei Game Over
              </label>
            </div>
            <div class="lbRow">
              <button class="Btn secondary" id="btnPost">Score posten</button>
              <button class="Btn ghost" id="btnRefresh">Refresh</button>
            </div>
            <div class="lbList" id="lbList"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     * Helpers
     **********************/
    function fmt(n){ return Number(n||0).toLocaleString("de-DE"); }
    function getViewportHeight(){
      return (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
    }
    function getViewportWidth(){
      return (window.visualViewport && window.visualViewport.width) ? window.visualViewport.width : window.innerWidth;
    }
    function setAppHeight(){
      document.documentElement.style.setProperty("--app-height", Math.round(getViewportHeight()) + "px");
    }
    window.toggleTileDebug = function(){
      document.body.classList.toggle("debugTiles");
    };

    /**********************
     * Identity / Seasons
     **********************/
    function seasonStartIso(){
      // Rolling 90-day "season" (≈ 3 months) so leaderboards stay fresh without hard resets
      return new Date(Date.now() - 90*24*60*60*1000).toISOString();
    }

    /**********************
     * Visual helpers (neutral tile backgrounds)
     * - Background is NOT tied to the character (avoids confusion)
     * - Still varied and candy-ish so tiles are readable
     **********************/
    const NEUTRAL_PALS = {
      A: ["#ff4fb9", "#7ad8ff"],      // knallig pink -> cyan
      B: ["#ffcf5a", "#8b5cf6"]       // knallig gelb -> violet
    };

    const SPECIAL_PALS = {
      worm: ["#ffe082", "#ff7043"],
      cit: ["#b2ff59", "#69f0ae"],
      koala: ["#a5b4fc", "#7c3aed"],
      mellow: ["#ffccbc", "#ff8a65"],
      lovelie: ["#ff9adf", "#ff4fb9"],
      myst: ["#d1c4e9", "#9575cd"],
      supernuss: ["#ffd740", "#ff8f00"]
    };
    // -------------------------
    // Tile background + tinting
    // -------------------------
    // We want each Luvvie (baseKey) to have a stable, UNIQUE pastel tint that CONTRASTS the character
    // (no "yellow on yellow"), and we want the board tile background to be the jelly image (no extra backplate).
    const TILE_TINT_CACHE = new Map();     // key -> [c1,c2]
    const USED_TINT_HUES = [];             // assigned hues to keep them unique
    const BASE_INDEX_CACHE = new Map();
    const TINT_STATE = { seed: 0, minDist: 58, extraShift: 0 };
    const TINT_OVERRIDES = new Map();
    const TINT_STATE_KEY = "luvvies_tint_state";
    const TINT_OVERRIDES_KEY = "luvvies_tint_overrides";
    const TINT_SNAPSHOT_KEY = "luvvies_tint_snapshot";
    const TINT_SNAPSHOT_OVERRIDES_KEY = "luvvies_tint_snapshot_overrides";

    function clamp(n,min,max){ return Math.min(max, Math.max(min,n)); }
    function hueDist(a,b){
      let d = Math.abs(a-b) % 360;
      return d > 180 ? 360 - d : d;
    }
    function hexToRgb(hex){
      if(!hex) return null;
      let h = (""+hex).trim().replace("#","");
      if(h.length===3) h = h.split("").map(x=>x+x).join("");
      if(h.length!==6) return null;
      const n = parseInt(h,16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0, s=0;
      const l=(max+min)/2;
      const d=max-min;
      if(d!==0){
        s = d / (1 - Math.abs(2*l - 1));
        switch(max){
          case r: h = ((g-b)/d) % 6; break;
          case g: h = (b-r)/d + 2; break;
          case b: h = (r-g)/d + 4; break;
        }
        h = (h*60+360) % 360;
      }
      return {h, s:s*100, l:l*100};
    }
    function hslToRgb(h,s,l){
      s/=100; l/=100;
      const c=(1-Math.abs(2*l-1))*s;
      const x=c*(1-Math.abs((h/60)%2 - 1));
      const m=l-c/2;
      let r=0,g=0,b=0;
      if(h<60){ r=c; g=x; b=0; }
      else if(h<120){ r=x; g=c; b=0; }
      else if(h<180){ r=0; g=c; b=x; }
      else if(h<240){ r=0; g=x; b=c; }
      else if(h<300){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      return { r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255) };
    }
    function rgbToHex(r,g,b){
      const to = (n)=>n.toString(16).padStart(2,"0");
      return "#"+to(r)+to(g)+to(b);
    }
    function pastelFromHue(h, isLightSprite, tone=0){
      // pastel but with stronger contrast
      const sat = clamp(84 + tone*6, 64, 92);
      const l1 = clamp((isLightSprite ? 64 : 78) + tone*4, 46, 86);
      const l2 = clamp((isLightSprite ? 52 : 66) + tone*4, 36, 78);
      const c1 = hslToRgb(h, sat, l1);
      const c2 = hslToRgb(h, sat-10, l2);
      return [rgbToHex(c1.r,c1.g,c1.b), rgbToHex(c2.r,c2.g,c2.b)];
    }

    function deriveSpriteHueAndLight(baseKey){
      // Prefer explicit palettes from BASES (fast, stable, no async).
      const base = getBase(baseKey);
      const spec = getSpecial(baseKey);
      const meta = base || spec;
      const palA = meta?.palettes?.A;
      const palB = meta?.palettes?.B;
      const src = (palA && palA[0]) || (SPECIAL_PALS[baseKey] && SPECIAL_PALS[baseKey][0]) || (NEUTRAL_PALS.A[0]);
      const rgb = hexToRgb(src);
      const hsl = rgb ? rgbToHsl(rgb.r,rgb.g,rgb.b) : {h:210, l:60};
      return {h: hsl.h, l: hsl.l};
    }

    function uniqueHue(preferredHue){
      let h = (preferredHue%360+360)%360;
      // enforce uniqueness against already assigned hues
      for(let attempt=0; attempt<48; attempt++){
        const clash = USED_TINT_HUES.some(u => hueDist(u,h) < TINT_STATE.minDist);
        if(!clash) { USED_TINT_HUES.push(h); return h; }
        h = (h + 29) % 360; // pseudo-golden-ish step
      }
      // fallback (should never happen)
      USED_TINT_HUES.push(h);
      return h;
    }

    function paletteForKey(baseKey, variant){
      const k = baseKey + ":" + (variant || "A");
      const cached = TILE_TINT_CACHE.get(k);
      if(cached) return cached;

      const {h: spriteHue, l: spriteLight} = deriveSpriteHueAndLight(baseKey);
      const isLightSprite = spriteLight >= 62;

      // Stable per-character hue with wide spacing
      let baseIdx = BASE_INDEX_CACHE.get(baseKey);
      if(baseIdx == null){
        baseIdx = (getBase(baseKey) ? BASES.findIndex(b=>b.key===baseKey) : -1);
        BASE_INDEX_CACHE.set(baseKey, baseIdx);
      }
      const baseHue = (baseIdx >= 0) ? (baseIdx * 92) % 360 : (hashStr(baseKey) * 137.508) % 360;
      const override = TINT_OVERRIDES.get(baseKey + ":" + (variant || "A")) || TINT_OVERRIDES.get(baseKey);
      
      let preferred;
      if(override !== undefined && override !== null){
        preferred = override;
      } else {
        preferred = (baseHue + TINT_STATE.seed + TINT_STATE.extraShift) % 360;
        if(hueDist(preferred, spriteHue) < 55) preferred = (preferred + 140) % 360;
        // Separate A/B variants clearly
        const vShift = (variant === "B") ? 185 : 0;
        preferred = (preferred + vShift) % 360;
      }

      const tone = (hashStr(baseKey) % 3) - 1 + (variant === "B" ? -1 : 0);
      const h = uniqueHue(preferred);
      const pal = pastelFromHue(h, isLightSprite, tone);

      TILE_TINT_CACHE.set(k, pal);
      return pal;
    }

    function hashStr(str){
      let h=2166136261>>>0;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h>>>0;
    }

    const BG_PICK_CACHE = new Map();
    loadTintState();

    function tileBgFor(tile){
      const { baseKey, variant } = parseTypeId(tile?.type || "");
      const v = (variant || "A") === "B" ? "B" : "A";
      const list = (v === "B") ? (IMG.variantsB || []) : (IMG.variantsA || []);
      if(!list.length) return null;

      // Stable choice per (baseKey, variant) so identical Luvvies keep identical jelly backgrounds
      const k = (baseKey || (tile?.type||"")) + ":" + v;
      let idx = BG_PICK_CACHE.get(k);
      if(idx == null){
        idx = hashStr(k) % list.length;
        BG_PICK_CACHE.set(k, idx);
      }
      return list[idx];
    }



    // Color helpers (small + cached) to derive complementary gradients per character
    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||"");
      if(!m) return null;
      return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
    }
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h,s,l=(max+min)/2;
      if(max===min){ h=s=0; }
      else{
        const d=max-min;
        s=l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d+(g<b?6:0); break;
          case g: h=(b-r)/d+2; break;
          case b: h=(r-g)/d+4; break;
        }
        h/=6;
      }
      return {h,s,l};
    }
    function hslToHex(h,s,l){
      const hue2rgb=(p,q,t)=>{
        if(t<0) t+=1;
        if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3 - t)*6;
        return p;
      };
      let r,g,b;
      if(s===0){ r=g=b=l; }
      else{
        const q=l<0.5 ? l*(1+s) : l+s-l*s;
        const p=2*l-q;
        r=hue2rgb(p,q,h+1/3);
        g=hue2rgb(p,q,h);
        b=hue2rgb(p,q,h-1/3);
      }
      const toHex=(x)=>{
        const v=Math.round(x*255).toString(16).padStart(2,"0");
        return v;
      };
      return "#"+toHex(r)+toHex(g)+toHex(b);
    }
    function complementHex(hex){
      const rgb=hexToRgb(hex);
      if(!rgb) return null;
      const hsl=rgbToHsl(rgb.r,rgb.g,rgb.b);
      const nh=((hsl.h*360 + 160) % 360)/360;
      const ns=Math.min(1, hsl.s*0.9 + 0.05);
      const nl=Math.min(1, hsl.l*0.9 + 0.08);
      return hslToHex(nh, ns, nl);
    }

    function paletteForTile(tile){
      const { baseKey, variant } = parseTypeId(tile?.type || "");
      if(isPowerupKey(baseKey) || baseKey==="myst" || baseKey==="lovelie"){
        return ["rgba(255,255,255,0)","rgba(255,255,255,0)"];
      }
      // Keep explicit special palettes where they matter visually (powerups etc.)
      if(SPECIAL_PALS[baseKey]) return SPECIAL_PALS[baseKey];
      // Unique, stable, contrast-first pastel tint for each (baseKey, variant)
      return paletteForKey(baseKey, (variant||"A")==="B" ? "B" : "A");
    }

    function saveTintState(){
      try{
        localStorage.setItem(TINT_STATE_KEY, JSON.stringify(TINT_STATE));
      }catch(e){}
    }
    function saveTintOverrides(){
      try{
        const obj = {};
        for(const [k,v] of TINT_OVERRIDES.entries()) obj[k] = v;
        localStorage.setItem(TINT_OVERRIDES_KEY, JSON.stringify(obj));
      }catch(e){}
    }
    function loadTintState(){
      try{
        const raw = localStorage.getItem(TINT_STATE_KEY);
        if(raw){
          const v = JSON.parse(raw);
          if(v && typeof v.seed === "number") TINT_STATE.seed = v.seed;
          if(v && typeof v.minDist === "number") TINT_STATE.minDist = v.minDist;
          if(v && typeof v.extraShift === "number") TINT_STATE.extraShift = v.extraShift;
        }
      }catch(e){}
      try{
        const raw = localStorage.getItem(TINT_OVERRIDES_KEY);
        if(raw){
          const obj = JSON.parse(raw);
          if(obj && typeof obj === "object"){
            for(const k of Object.keys(obj)){
              const v = Number(obj[k]);
              if(!Number.isNaN(v)) TINT_OVERRIDES.set(k, v);
            }
          }
        }
      }catch(e){}
    }
    function saveTintSnapshot(){
      try{
        localStorage.setItem(TINT_SNAPSHOT_KEY, JSON.stringify(TINT_STATE));
        const obj = {};
        for(const [k,v] of TINT_OVERRIDES.entries()) obj[k] = v;
        localStorage.setItem(TINT_SNAPSHOT_OVERRIDES_KEY, JSON.stringify(obj));
        toast("Farben gespeichert", "Du kannst sie spaeter laden.", 2200);
      }catch(e){}
    }
    function applyTintSnapshot(){
      try{
        const rawState = localStorage.getItem(TINT_SNAPSHOT_KEY);
        if(!rawState){ toast("Keine Farben gespeichert", "Bitte zuerst speichern.", 2000); return; }
        if(TINT_OVERRIDES.size > 0){
          const ok = confirm("Du hast individuelle Luvvie-Farben. Alle ueberschreiben?");
          if(!ok) return;
        }
        const v = JSON.parse(rawState);
        if(v && typeof v.seed === "number") TINT_STATE.seed = v.seed;
        if(v && typeof v.minDist === "number") TINT_STATE.minDist = v.minDist;
        if(v && typeof v.extraShift === "number") TINT_STATE.extraShift = v.extraShift;
        TINT_OVERRIDES.clear();
        const rawOv = localStorage.getItem(TINT_SNAPSHOT_OVERRIDES_KEY);
        if(rawOv){
          const obj = JSON.parse(rawOv);
          if(obj && typeof obj === "object"){
            for(const k of Object.keys(obj)){
              const n = Number(obj[k]);
              if(!Number.isNaN(n)) TINT_OVERRIDES.set(k, n);
            }
          }
        }
        TILE_TINT_CACHE.clear();
        USED_TINT_HUES.length = 0;
        saveTintState();
        saveTintOverrides();
        if(isGridReady()){
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              const t = grid[r][c];
              if(t) refreshTileEl(t);
            }
          }
        }
        toast("Farben geladen", "Alle Luvvies aktualisiert.", 2200);
      }catch(e){}
    }

    function rerollTileTints(){
      TINT_STATE.seed = Math.random() * 360;
      TINT_STATE.minDist = 86;
      TINT_STATE.extraShift = 60 + Math.random() * 140;
      TILE_TINT_CACHE.clear();
      USED_TINT_HUES.length = 0;
      saveTintState();
      saveTintOverrides();
      if(!isGridReady()) return;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t) refreshTileEl(t);
        }
      }
      toast("Farben neu gewürfelt 🌈","Mehr Kontrast zwischen Tiles", 2200);
    }

    function rerollLuvvieTint(baseKey){
      if(!baseKey) return;
      TINT_STATE.minDist = 86;
      TINT_OVERRIDES.set(baseKey + ":A", Math.random() * 360);
      TILE_TINT_CACHE.clear();
      USED_TINT_HUES.length = 0;
      saveTintState();
      saveTintOverrides();
      if(!isGridReady()) return;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t && parseTypeId(t.type).baseKey === baseKey) refreshTileEl(t);
        }
      }
      toast("Luvvie‑Farbe geändert ✨", getBase(baseKey)?.name || baseKey, 2000);
    }

    function rerollLuvvieTintB(baseKey){
      if(!baseKey) return;
      TINT_STATE.minDist = 86;
      TINT_OVERRIDES.set(baseKey + ":B", Math.random() * 360);
      TILE_TINT_CACHE.clear();
      USED_TINT_HUES.length = 0;
      saveTintState();
      saveTintOverrides();
      if(!isGridReady()) return;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t){
            const p = parseTypeId(t.type);
            if(p.baseKey === baseKey && p.variant === "B") refreshTileEl(t);
          }
        }
      }
      toast("Variante B Farbe geÇÏndert ƒoù", getBase(baseKey)?.name || baseKey, 2000);
    }
/**********************
     * DOM safety: remove orphan tile elements (prevents rare "static tiles" you can't drag)
     **********************/
    function collectGridIds(){
      const ids = new Set();
      if(!isGridReady()) return ids;
      for(let r=0;r<rows;r++){
        const row = grid[r];
        if(!row) continue;
        for(let c=0;c<cols;c++){
          const t = row[c];
          if(t && t.id) ids.add(t.id);
        }
      }
      return ids;
    }
    function gridHasVariantB(baseKey){
      if(!baseKey || !isGridReady()) return false;
      for(let r=0;r<rows;r++){
        const row = grid[r];
        if(!row) continue;
        for(let c=0;c<cols;c++){
          const t = row[c];
          if(!t) continue;
          const p = parseTypeId(t.type);
          if(p.baseKey === baseKey && p.variant === "B") return true;
        }
      }
      return false;
    }
    function pruneOrphanTileEls(){
      const ids = collectGridIds();
      for(const [id, el] of tileEls.entries()){
        if(!ids.has(id)){
          try{ el.remove(); }catch(e){}
          tileEls.delete(id);
        }
      }
    }

    function diffLabel(k){
      const key = (k||"").toLowerCase();
      if(key==="shock" || key==="schock" || key==="zuschock" || key==="zuckerschock") return "Zuckerschock";
      if(key==="easy") return "Easy";
      if(key==="normal") return "Normal";
      if(key==="hard") return "Hard";
      return k || "";
    }

    /**********************
     * Supabase (intern)
     **********************/
    const SUPABASE_URL = "https://qgeddoqvzajpeawlythi.supabase.co";
    const SUPABASE_KEY_PUBLISHABLE = "sb_publishable_EQUOdDGiCGgm8vA3YjN_jg_BwPnAiI_";
    const SCORE_TABLE = "luvvies_crush_scores";

    let sb = null;
    try{
      if(window.supabase?.createClient){
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY_PUBLISHABLE, {
          auth: { persistSession:false, autoRefreshToken:false }
        });
      }
    }catch(e){ sb = null; }

    /**********************
     * Cookies (1x/day greeting)
     **********************/
    function getCookie(name){
      const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([$?*|{}\(\)\[\]\\\/\+^])/g,'\\$1') + '=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : "";
    }
    function setCookie(name, value, days=7){
      const maxAge = days * 24 * 60 * 60;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
    }
    const todayKey = ()=>new Date().toISOString().slice(0,10);

    /**********************
     * Difficulty
     **********************/
    const DIFFS = {
      easy:   { key:"easy",   name:"Easy",        rows:10, cols:10, scoreMult:1.00, baseMoves:30, movesPerLevel:2, baseTarget:3500, targetGrow:0.18, lovelieChance:0.006, mystChance:0.010 },
      normal: { key:"normal", name:"Normal",      rows: 9, cols: 9, scoreMult:1.25, baseMoves:26, movesPerLevel:2, baseTarget:4200, targetGrow:0.20, lovelieChance:0.005, mystChance:0.009 },
      hard:   { key:"hard",   name:"Hard",        rows: 9, cols: 8, scoreMult:1.60, baseMoves:24, movesPerLevel:1, baseTarget:5000, targetGrow:0.22, lovelieChance:0.004, mystChance:0.008 },
      shock:  { key:"shock",  name:"Zuckerschock",rows: 8, cols: 8, scoreMult:2.00, baseMoves:22, movesPerLevel:1, baseTarget:6500, targetGrow:0.24, lovelieChance:0.003, mystChance:0.007 }
    };
    const ROGUE_DIFF_ORDER = ["easy", "normal", "hard", "shock"];
    const ROGUE_DIFF_MODS = {
      easy:   { hp: 1.0, atk: 1.0 },
      normal: { hp: 1.18, atk: 1.12 },
      hard:   { hp: 1.38, atk: 1.25 },
      shock:  { hp: 1.7, atk: 1.45 }
    };
    let diff = DIFFS.easy;

    /**********************
     * Images (Local)
     **********************/
    const OPT_SMALL = "Images/optimized-100";
    const OPT_LARGE = "Images/optimized-150";
    const OPT = (window.innerWidth < 680) ? OPT_SMALL : OPT_LARGE;
    const variantPath = (kind, idx)=>{
      const base = (OPT === OPT_SMALL && idx > 4) ? OPT_LARGE : OPT;
      const file = (kind === "A") ? `Variant-A${idx}.png` : `variant-B${idx}.png`;
      return `${base}/Button/${file}`;
    };
    const VARIANTS_A = Array.from({length:9}, (_,i)=>variantPath("A", i+1));
    const VARIANTS_B = Array.from({length:9}, (_,i)=>variantPath("B", i+1));
    document.documentElement.style.setProperty("--tileDefault", `url('${variantPath("A", 1)}')`);
    document.documentElement.style.setProperty("--candiesImg", `url('${OPT}/Button/candies.png')`);
    document.documentElement.style.setProperty("--btnCandy", `url('${OPT}/Button/candies.png')`);
    document.documentElement.style.setProperty("--powerBtn", `url('${OPT}/Button/PowerUpButton.png')`);
    document.documentElement.style.setProperty("--mystBtn", `url('${OPT}/Button/Powerup.png')`);
    const IMG = {
      logo:     "Luvvies/Luvvies-Logonew.png",
      sweety:   `${OPT}/Luvvies/Sweety.png`,
      sleepy:   `${OPT}/Luvvies/Sleepy.png`,
      normal:   `${OPT}/Luvvies/Normalo.png`,
      cry:      `${OPT}/Luvvies/Cry.png`,
      koala:    `${OPT}/Luvvies/KOALA.png`,
      citrussy: `${OPT}/Luvvies/CItrussie.png`,
      cit:      `${OPT}/Luvvies/CItrussie.png`,
      
      // Random Worms
      worm: `${OPT}/Luvvies/Sourwurm-1.png`, // Fallback
      sourwurm: [`${OPT}/Luvvies/Sourwurm-1.png`, `${OPT}/Luvvies/Sourwurm-2.png`, `${OPT}/Luvvies/Sourwurm-3.png`],
      
      grumpy:   `${OPT}/Luvvies/Grumpycookie.png`,
      happy:    `${OPT}/Luvvies/HappyCookie.png`,
      mond:     `${OPT}/Luvvies/Mondlie.png`,
      donut:    `${OPT}/Luvvies/Donutlie.png`,
      joyce:    `${OPT}/Luvvies/joyce.png`,
      smokey:   `${OPT}/Luvvies/Smokey.png`,
      mellow:   `${OPT}/Luvvies/mellow.png`,
      lovelie:  `${OPT}/Luvvies/lovvelie.png`,
      simba:    `${OPT}/Luvvies/Simba.png`,
      mellowlord: `${OPT}/Luvvies/MellowLord.png`,
      
      // Boss Animations (Frame 1-4)
      mellowzilla: [`${OPT}/Luvvies/Mellowzilla-1.png`, `${OPT}/Luvvies/MellowZilla-2.png`, `${OPT}/Luvvies/Mellowzilla-3.png`, `${OPT}/Luvvies/Mellowzilla-4.png`],
      koalazilla:  [`${OPT}/Luvvies/KoalaZilla-1.png`, `${OPT}/Luvvies/KoalaZilla-2.png`, `${OPT}/Luvvies/KoalaZilla-3.png`, `${OPT}/Luvvies/KoalaZilla-4.png`],
      
      fledernuss: `${OPT}/Luvvies/FlederNuss.png`,
      flederheld: `${OPT}/Luvvies/FlederHeld.png`,
      supernuss: `${OPT}/Luvvies/SuperNuss.png`,
      giraffie: `${OPT}/Luvvies/Giraffie.png`,
      
      // Jelly Buttons (Variants)
      variantsA: VARIANTS_A,
      variantsB: VARIANTS_B,
      
      // Special Buttons
      powerBtn: `${OPT}/Button/PowerUpButton.png`,
      mystBtn: `${OPT}/Button/Powerup.png`, // Use as the tile itself for Mystery
      
      // Animations
      comboSprite: "Images/Animation/Combo.png",
      deathGif: `${OPT}/Animation/Deathanimation.gif`
    };
    const RAINBOW_LOOP_S = 6;
    const rainbowOffset = -((Date.now()/1000) % RAINBOW_LOOP_S);
    document.documentElement.style.setProperty("--rainbow-sync", rainbowOffset + "s");
    document.getElementById("greetLogo").src = IMG.logo;
    const ml = document.getElementById("mainLogo");
    if(ml) ml.src = IMG.logo;

    const IMG_SMALL = {
      sweety:   `${OPT_SMALL}/Luvvies/Sweety.png`,
      sleepy:   `${OPT_SMALL}/Luvvies/Sleepy.png`,
      normal:   `${OPT_SMALL}/Luvvies/Normalo.png`,
      cry:      `${OPT_SMALL}/Luvvies/Cry.png`,
      koala:    `${OPT_SMALL}/Luvvies/KOALA.png`,
      citrussy: `${OPT_SMALL}/Luvvies/CItrussie.png`,
      cit:      `${OPT_SMALL}/Luvvies/CItrussie.png`,
      worm:     `${OPT_SMALL}/Luvvies/Sourwurm-1.png`,
      grumpy:   `${OPT_SMALL}/Luvvies/Grumpycookie.png`,
      happy:    `${OPT_SMALL}/Luvvies/HappyCookie.png`,
      mond:     `${OPT_SMALL}/Luvvies/Mondlie.png`,
      donut:    `${OPT_SMALL}/Luvvies/Donutlie.png`,
      joyce:    `${OPT_SMALL}/Luvvies/joyce.png`,
      smokey:   `${OPT_SMALL}/Luvvies/Smokey.png`,
      mellow:   `${OPT_SMALL}/Luvvies/mellow.png`,
      lovelie:  `${OPT_SMALL}/Luvvies/lovvelie.png`,
      simba:    `${OPT_SMALL}/Luvvies/Simba.png`,
      mellowlord:`${OPT_SMALL}/Luvvies/MellowLord.png`,
      mellowzilla:`${OPT_SMALL}/Luvvies/Mellowzilla-1.png`,
      koalazilla:`${OPT_SMALL}/Luvvies/KoalaZilla-1.png`,
      fledernuss:`${OPT_SMALL}/Luvvies/FlederNuss.png`,
      flederheld:`${OPT_SMALL}/Luvvies/FlederHeld.png`,
      supernuss:`${OPT_SMALL}/Luvvies/SuperNuss.png`,
      giraffie: `${OPT_SMALL}/Luvvies/Giraffie.png`,
      myst:     `${OPT_SMALL}/Button/Powerup.png`
    };
    const IMG_LARGE = {
      sweety:   "Images/Luvvies/Sweety.png",
      sleepy:   "Images/Luvvies/Sleepy.png",
      normal:   "Images/Luvvies/Normalo.png",
      cry:      "Images/Luvvies/Cry.png",
      koala:    "Images/Luvvies/KOALA.png",
      citrussy: "Images/Luvvies/CItrussie.png",
      grumpy:   "Images/Luvvies/Grumpycookie.png",
      happy:    "Images/Luvvies/HappyCookie.png",
      mond:     "Images/Luvvies/Mondlie.png",
      donut:    "Images/Luvvies/Donutlie.png",
      joyce:    "Images/Luvvies/joyce.png",
      smokey:   "Images/Luvvies/Smokey.png",
      mellow:   "Images/Luvvies/mellow.png",
      lovelie:  "Images/Luvvies/lovvelie.png",
      simba:    "Images/Luvvies/Simba.png",
      mellowlord:"Images/Luvvies/MellowLord.png",
      mellowzilla:"Images/Luvvies/Mellowzilla-1.png",
      koalazilla:"Images/Luvvies/KoalaZilla-1.png",
      fledernuss:"Images/Luvvies/FlederNuss.png",
      flederheld:"Images/Luvvies/FlederHeld.png",
      supernuss:"Images/Luvvies/SuperNuss.png",
      giraffie:"Images/Luvvies/Giraffie.png"
    };

    function preloadImages(list){
      const seen = new Set();
      const queue = [];
      list.forEach((src)=>{
        if(!src || seen.has(src)) return;
        seen.add(src);
        queue.push(src);
      });

      const loadNext = (deadline)=>{
        let n = 0;
        while(queue.length && (deadline?.timeRemaining?.() > 8 || n < 4)){
          const src = queue.shift();
          const img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.src = src;
          n++;
        }
        if(queue.length){
          if("requestIdleCallback" in window){
            requestIdleCallback(loadNext);
          }else{
            setTimeout(()=>loadNext({ timeRemaining: () => 12 }), 80);
          }
        }
      };
      loadNext();
    }
    function collectImgSources(){
      const list = [];
      for(const v of Object.values(IMG)){
        if(Array.isArray(v)) list.push(...v);
        else list.push(v);
      }
      list.push(`${OPT}/Button/candies.png`);
      for(const v of Object.values(IMG_SMALL)){
        if(v) list.push(v);
      }
      return list;
    }
    try{
      const allImgs = collectImgSources();
      if("requestIdleCallback" in window){
        requestIdleCallback(()=>preloadImages(allImgs));
      }else{
        setTimeout(()=>preloadImages(allImgs), 200);
      }
    }catch(e){}

    /**********************
     * Mystery reveal weights (Wurm > Cit > Mellow > Koala > Lovelie)
     **********************/
    const MYST_POOL = [
      { key:"worm",   w: 40 },
      { key:"cit",    w: 25 },
      { key:"mellow", w: 16 },  // goldene mitte (zwischen cit und koala)
      { key:"koala",  w: 12 },
      { key:"lovelie",w:  7 }   // rare
    ];

    /**********************
     * Bases
     **********************/
    const BASES = [
      { key:"fledernuss", name:"Fledernuss", img:IMG.fledernuss, tag:"normal", minLevel:10,
        palettes:{ A:["#8d6e63","#a1887f"], B:["#a1887f","#bcaaa4"] },
        ability:"Entwickelt sich zu FlederHeld.",
        story:"Kleine Nuss mit großen Träumen.",
        lines:{
          easy:["Fledernuss!","Evolution?","Flatter!"],
          normal:["Ich wachse!","Next stage!","Nuss-Power!"],
          hard:["Schnell entwickeln!","Evolution!","Go!"],
          shock:["SUPER NUSS?!","EVOLUTION!","FLATTER!"]
        }
      },
      { key:"flederheld", name:"FlederHeld", img:IMG.flederheld, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#3e2723","#5d4037"], B:["#5d4037","#795548"] },
        ability:"Entwickelt sich zu SuperNuss.",
        story:"Der Held der Nüsse.",
        lines:{ easy:["Held!"], normal:["Hero!"], hard:["Super!"], shock:["HYPER!"] }
      },
      { key:"supernuss", name:"SuperNuss", img:IMG.supernuss, tag:"normal", minLevel:999, // Only via Evolution
        palettes:{ A:["#ffab00","#ffd740"], B:["#ff6f00","#ff8f00"] },
        ability:"Explodiert!",
        story:"Die ultimative Nuss.",
        lines:{ easy:["BOOM!"], normal:["SUPER!"], hard:["MEGA!"], shock:["ULTRA!"] }
      },
      { key:"mellowlord", name:"Mellow Lord", img:IMG.mellowlord, tag:"boss", minLevel:999, // Only via Merge
        palettes:{ A:["#e57373","#ffcdd2"], B:["#ff5252","#ff8a80"] },
        ability:"3x3 Explosion bei Zerstörung.",
        story:"Der König der Mellows. Wenn er erscheint, bebt das Board.",
        lines:{ easy:["Mellow King!","3x3 Boom!","Mächtig!"], normal:["Zerstör mich!","Platz da!","Boss!"], hard:["Nicht im Weg stehen.","Macht.","King."], shock:["LORD!!","BOOM","MELLOW POWER!"] }
      },
      { key:"giraffie", name:"Giraffie", img:IMG.giraffie, tag:"normal", minLevel:30,
        palettes:{ A:["#fff59d","#fff176"], B:["#ffee58","#fdd835"] },
        ability:"Sieht alles von oben.",
        story:"Giraffie behält den Überblick. Kombinierbar für Tower Power.",
        lines:{
          easy:["Hoher Hals!","Überblick!","Hallo unten!"],
          normal:["Safari Time.","Tower Power?","Weitsicht."],
          hard:["Strategie.","Langfristig.","Plan."],
          shock:["HOCH HINAUS!","GIRAFFEN POWER!","RAGE!"]
        }
      },
      { key:"sweety", name:"Sweety", img:IMG.sweety, tag:"normal",
        palettes:{ A:["#f8bbd0","#f48fb1"], B:["#f48fb1","#ec407a"] },
        ability:"Glitzer-Queen: liebt saubere Lines.",
        story:"Sweety liebt Kettenreaktionen – je mehr es bounct, desto besser.",
        lines:{
          easy:["Zucker-Boom! ✨","Glitzer time!","Noch ein Match! 💖"],
          normal:["Sauberer Swap 😌","Combo? Ich seh’s!","Keep the vibe ✨"],
          hard:["No panic — precision.","Du bist fast da.","Tight! 😈"],
          shock:["ZUCKERSCHOCK!","Mehr Chaos!","Ich will Ketten! 🔥"]
        }
      },
      { key:"sleepy", name:"Sleepy", img:IMG.sleepy, tag:"normal",
        palettes:{ A:["#e3f2fd","#bbdefb"], B:["#bbdefb","#90caf9"] },
        ability:"Schläfer-Glow: bringt Ruhe ins Chaos.",
        story:"Wirkt müde… aber sein Shuffle ist brutal effektiv.",
        lines:{
          easy:["Zzz… aber ok 😴","Sanfter Swap…","Wach für Combo!"],
          normal:["Nicht einschlafen.","Smooth & bouncy.","Weiter… ✨"],
          hard:["Timing ist alles.","Kein Tilt.","Mach’s clean."],
          shock:["ICH BIN WACH!","Shuffle oder RIP.","Mehr! 😈"]
        }
      },
      { key:"normal", name:"Normal", img:IMG.normal, tag:"normal",
        palettes:{ A:["#f3e5f5","#e1bee7"], B:["#ce93d8","#ba68c8"] },
        ability:"Klassiker: stabil & zuverlässig.",
        story:"Normal ist der Anker – wenn’s brennt, rettet er dein Board.",
        lines:{
          easy:["Easy going.","Alles chill.","Noch eins!"],
          normal:["Stabil.","Rund.","Passt."],
          hard:["Disziplin.","Konsequent.","Kein Fehler."],
          shock:["Ich bleib ruhig.","Präzise.","Durchziehen."]
        }
      },
      { key:"cry", name:"Cry", img:IMG.cry, tag:"normal",
        palettes:{ A:["#e0f2f1","#b2dfdb"], B:["#80cbc4","#4db6ac"] },
        ability:"Emo-Boost: fühlt jedes Chaos.",
        story:"Cry weint… aber nur weil’s so schön glitzert.",
        lines:{
          easy:["😭✨ so schön","Bitte noch ein Match","Ich fühl das!"],
          normal:["Combo macht happy.","Nicht aufgeben.","Weiter!"],
          hard:["Tough love.","Du packst das.","Sauber bleiben."],
          shock:["AAAA 😭","Nur noch Kette!","Chaos is love."]
        }
      },
      { key:"happy", name:"Happy Cookie", img:IMG.happy, tag:"normal",
        palettes:{ A:["#fff3e0","#ffe0b2"], B:["#ffcc80","#ffb74d"] },
        ability:"Therapy Time: hält dich im Spiel.",
        story:"Happy macht selbst Grumpy weich. 🍪✨",
        lines:{
          easy:["Smile! 🍪","Alles wird gut!","Süß & stark!"],
          normal:["Therapy incoming.","Du schaffst das.","Nice chain!"],
          hard:["Atmen. Fokus.","Guter Move.","Keep going."],
          shock:["HAPPY RAGE 😈","Wir gewinnen!","Mehr Moves!!"]
        }
      },
      { key:"grumpy", name:"Grumpy Cookie", img:IMG.grumpy, tag:"normal",
        palettes:{ A:["#ffebee","#ffcdd2"], B:["#ef9a9a","#e57373"] },
        ability:"Therapy Time: grummelig, aber hilfreich.",
        story:"Grumpy sagt 'nein'… aber liebt +Moves heimlich.",
        lines:{
          easy:["Hmpf.","Mach schneller.","Ok…"],
          normal:["Weniger Fehler.","Konzentrier dich.","Weiter."],
          hard:["Sauber oder raus.","Nicht tilten.","Knapp!"],
          shock:["Zuckerschock?!","Du bist verrückt.","…gefällt mir."]
        }
      },
      { key:"mond", name:"Mondlie", img:IMG.mond, tag:"normal",
        palettes:{ A:["#ede7f6","#d1c4e9"], B:["#b39ddb","#9575cd"] },
        ability:"Mond-Reset: Nachtmagie pur.",
        story:"Mondlie ist selten ruhig… sein Shuffle ist Nachtmagie.",
        lines:{
          easy:["🌙 leise…","Moon vibes.","Shuffle? 😴"],
          normal:["Nacht-Combo.","Elegant.","Weiter."],
          hard:["Kein Risiko.","Nur Timing.","Mond-Plan."],
          shock:["NACHTCHAOS 😈","Alles mischen!","Mehr!"]
        }
      },
      { key:"donut", name:"Donutlie", img:IMG.donut, tag:"normal",
        palettes:{ A:["#fce4ec","#f8bbd0"], B:["#f48fb1","#f06292"] },
        ability:"Sprinkles: süß & gefährlich.",
        story:"Wenn Donut kommt, wird’s zuckrig gefährlich. 🍩",
        lines:{
          easy:["Sprinkles! ✨","Mehr Donuts!","Süßes Chaos!"],
          normal:["Beam ready.","Zucker-Schub!","Let’s go!"],
          hard:["Timing!","Nicht verschwenden.","Power!"],
          shock:["OVERLOAD!","LASER 🍩","MEHR!!!"]
        }
      },
      { key:"joyce", name:"Joyce", img:IMG.joyce, tag:"normal",
        palettes:{ A:["#efebe9","#d7ccc8"], B:["#bcaaa4","#a1887f"] },
        ability:"Buddy Burst: Teamplayer durch und durch.",
        story:"Joyce ist loyal – wenn Smokey da ist, zündet’s richtig.",
        lines:{
          easy:["Wuff! 🐾","Guter Swap!","Ich helf!"],
          normal:["Buddy time!","Ich bin dabei!","Nice!"],
          hard:["Wir schaffen’s.","Bleib dran.","Clean!"],
          shock:["WUFF ZUCKER!","Vollgas!","No fear!"]
        }
      },
      { key:"smokey", name:"Smokey", img:IMG.smokey, tag:"normal",
        palettes:{ A:["#f5f5f5","#e0e0e0"], B:["#bdbdbd","#9e9e9e"] },
        ability:"Buddy Burst: Boss‑Laune garantiert.",
        story:"Smokey ist Boss-Katze – und Boss-Katzen räumen auf.",
        lines:{
          easy:["Miau.","Ok.","Weiter."],
          normal:["Nicht schlecht.","Hmm.","Passt."],
          hard:["Ich bewerte dich.","Konsequent.","Sauber."],
          shock:["miau… RESPEKT.","Heftig.","No mercy."]
        }
      },
      { key:"simba", name:"Simba", img:IMG.simba, tag:"normal", minLevel:4,
        palettes:{ A:["#fff8e1","#ffecb3"], B:["#ffe0b2","#ffcc80"] },
        ability:"Best Buddies: mutig & loyal.",
        story:"Simba ist mutig und liebt Smokey – zusammen sind sie unaufhaltbar.",
        lines:{
          easy:["Roar! 🦁","Best Buddies!","Wir schaffen’s!"],
          normal:["Starker Move!","Buddy Power!","Nice!"],
          hard:["Fokus.","Clean.","Weiter so."],
          shock:["ROAR SCHOCK!","Buddy Chaos!","No Mercy!"]
        }
      }
    ];

    const SPECIALS = {
      worm:   { key:"worm",   name:"Sourworm", img:IMG.worm, tag:"powerup" },
      cit:    { key:"cit",    name:"Citrussy", img:IMG.citrussy, tag:"powerup" },
      koala:  { key:"koala",  name:"Koala", img:IMG.koala, tag:"powerup" },
      mellow: { key:"mellow", name:"Mellow", img:IMG.mellow, tag:"obstacle" },
      lovelie:{ key:"lovelie",name:"Lovelie", img:IMG.lovelie, tag:"bonus" },
      myst:   { key:"myst",   name:"???", img:null, tag:"powerup" }
    };

    /**********************
     * Discovery (Luvvies)
     **********************/
    function loadDiscovery(){
      try{
        const raw = getCookie("luvvies_seen");
        if(!raw) return new Set();
        return new Set(JSON.parse(raw));
      }catch(e){ return new Set(); }
    }
    function saveDiscovery(){
      try{ setCookie("luvvies_seen", JSON.stringify([...discovered]), 3650); }catch(e){}
    }
    let discovered = loadDiscovery();
    function discoverLuvvie(key){
      if(!key || key==="myst") return;
      if(discovered.has(key)) return;
      discovered.add(key);
      saveDiscovery();
    }

    /**********************
     * Variant unlock
     **********************/
    let unlocked = {};
    const UNLOCKED_KEY = "luvvies_unlocked_variants_rogue";
    function saveUnlocked(){
      try{
        const out = {};
        for(const k of Object.keys(unlocked)){
          out[k] = Array.from(unlocked[k] || []);
        }
        localStorage.setItem(UNLOCKED_KEY, JSON.stringify(out));
      }catch(e){}
    }
    function loadUnlocked(){
      try{
        const raw = localStorage.getItem(UNLOCKED_KEY);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || typeof obj !== "object") return null;
        return obj;
      }catch(e){ return null; }
    }
    function resetUnlocked(){
      unlocked = {};
      for(const b of BASES) unlocked[b.key] = new Set(["A"]);
      const saved = loadUnlocked();
      if(saved){
        for(const key of Object.keys(saved)){
          if(!unlocked[key]) continue;
          const list = saved[key];
          if(Array.isArray(list)){
            for(const v of list) unlocked[key].add(v);
          }
        }
      }
    }
    function maybeUnlockVariant(){
      if(level < 5) return;
      if(level % 5 !== 0) return;
      const candidates = BASES.filter(b => !unlocked[b.key].has("B"));
      if(!candidates.length) return;
      const pick = candidates[Math.floor(Math.random()*candidates.length)];
      unlocked[pick.key].add("B");
      saveUnlocked();
      toast(`Neue Variante 🎨`, `${pick.name} hat jetzt auch Farbe B ✨`, 3200);
      try{ buildMenu(); }catch(e){}
    }

    /**********************
     * State
     **********************/
    let rows=10, cols=10;
    let grid = [];
    let tileEls = new Map();
    let busy = false;
    // big mellow mapping
    const bigMellows = new Map();
    // id -> {id, r, c, hp, type}


    let lastZillaType = null; // used to alternate KoalaZilla/MellowZilla
    let bossFight = null; // { active:true, type:'mellowzilla'|'koalazilla', hp:number, spawnLevel:number, deadlineLevel:number }
    let zillaPlanned = null;
    let zillaAttackCounter = 0;
    let pointer = {down:false, id:null, startX:0, startY:0};
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let target = 4000;
    let moves = 30;
    let mellowFreeMoves = 10;
    let lastPlayerMove = null;
    let combo = 1;

    let lastSwap = null;

    // Auto-post guard (prevents multiple auto-posts for the same game over)
    let autoPostDone = false;

    // cached sizing
    let CELL = 54;
    let GAP = 2;
    let PAD = 14;

    function isGridReady(){
      return Array.isArray(grid) && rows>0 && cols>0 && grid.length >= rows;
    }

    function currentPad(){
      return (document.body.classList.contains("fs") || document.body.classList.contains("maximized")) ? 10 : PAD;
    }

    /**********************
     * UI refs
     **********************/
    const ui = {
      level: document.getElementById("uiLevel"),
      goal:  document.getElementById("uiGoal"),
      score: document.getElementById("uiScore"),
      moves: document.getElementById("uiMoves"),
      combo: document.getElementById("uiCombo"),
      bar:   document.getElementById("uiBar"),
      pct:   document.getElementById("uiPct"),
      board: document.getElementById("board"),
      fx:    document.getElementById("fxLayer"),
      menu:  document.getElementById("luvMenu"),
      hudLevel: document.getElementById("hudLevel"),
      hudScore: document.getElementById("hudScore"),
      hudMoves: document.getElementById("hudMoves"),
      hudCombo: document.getElementById("hudCombo"),
      hudBar:   document.getElementById("hudBar"),
      hudPct:   document.getElementById("hudPct"),
    };

    /**********************
     * Rogue Meta + Run
     **********************/
    const ROGUE_MODE = true;
    const ROGUE_META_KEY = "luvvies_rogue_meta_v1";
    const ROGUE_RUN_KEY = "luvvies_rogue_run_v1";
    const ROGUE_STARTERS = ["sweety", "sleepy", "normal", "cry"];
    const ROGUE_DEFAULT_META = {
      resources: { gold: 0, wood: 0, stone: 0, essence: 0 },
      buildings: { forge: 0, armory: 0, alchemy: 0, library: 0, bank: 0, market: 0 },
      mainHero: null,
      heroCombos: {},
      unlockedHeroes: [],
      diffUnlocked: { easy: true, normal: false, hard: false, shock: false },
      selectedDiff: "easy",
      maxAct: 0,
      wins: { easy: 0, normal: 0, hard: 0, shock: 0 }
    };
    const ROGUE = {
      meta: null,
      run: {
        active: false,
        inCombat: false,
        node: null,
        nodeType: "combat",
        biomeId: "forest",
        hazard: "root",
        heroKey: null,
        act: 1,
        actComplete: false,
        enemy: null,
        enemyHp: 0,
        enemyMaxHp: 0,
        enemyAtk: 0,
        attack: 6,
        attackBonus: 0,
        shield: 0,
        shieldTurns: 0,
        poisonBlockTurns: 0,
        poisonTurns: 0,
        freezeRow: null,
        turn: 0,
        winReady: false,
        loseReady: false,
        loot: { wood: 0, stone: 0, essence: 0 },
        lastLoot: { gold: 0, wood: 0, stone: 0, essence: 0 },
        pending: { bombs: 0, clearRoots: false, unfreeze: false }
      }
    };
    function loadRogueMeta(){
      try{
        const raw = localStorage.getItem(ROGUE_META_KEY);
        if(raw){
          const parsed = JSON.parse(raw);
          if(parsed){
            const heroSet = new Set(Array.isArray(parsed.unlockedHeroes) ? parsed.unlockedHeroes : []);
            ROGUE_STARTERS.forEach(k => heroSet.add(k));
            const diffUnlocked = { ...ROGUE_DEFAULT_META.diffUnlocked, ...(parsed.diffUnlocked || {}) };
            diffUnlocked.easy = true;
            const selectedDiff = diffUnlocked[parsed.selectedDiff] ? parsed.selectedDiff : "easy";
            return {
              resources: { ...ROGUE_DEFAULT_META.resources, ...(parsed.resources || {}) },
              buildings: { ...ROGUE_DEFAULT_META.buildings, ...(parsed.buildings || {}) },
              mainHero: parsed.mainHero || null,
              heroCombos: parsed.heroCombos || {},
              unlockedHeroes: Array.from(heroSet),
              diffUnlocked,
              selectedDiff,
              maxAct: Math.max(0, parsed.maxAct || 0),
              wins: { ...ROGUE_DEFAULT_META.wins, ...(parsed.wins || {}) }
            };
          }
        }
      }catch(e){}
      const fallback = JSON.parse(JSON.stringify(ROGUE_DEFAULT_META));
      fallback.unlockedHeroes = ROGUE_STARTERS.slice();
      return fallback;
    }
    function saveRogueMeta(){
      try{ localStorage.setItem(ROGUE_META_KEY, JSON.stringify(ROGUE.meta)); }catch(e){}
    }
    function calcRogueStats(meta, heroKey=null){
      const forge = meta.buildings.forge || 0;
      const armory = meta.buildings.armory || 0;
      const alchemy = meta.buildings.alchemy || 0;
      const bank = meta.buildings.bank || 0;
      const stats = {
        attack: 6 + (forge * 5),
        maxHp: 100 + (armory * 20),
        healRate: 0.10 * Math.pow(1.05, alchemy),
        interest: Math.min(0.05, 0.001 * bank)
      };
      return applyHeroCombos(stats, heroKey);
    }
    function applyHeroCombos(stats, heroKey){
      if(!heroKey || !ROGUE.meta || !ROGUE.meta.heroCombos) return stats;
      const heroCombos = ROGUE.meta.heroCombos[heroKey] || {};
      for(const combo of ROGUE_COMBO_PERKS){
        if(!combo.heroes.includes(heroKey)) continue;
        const lvl = heroCombos[combo.id] || 0;
        if(lvl <= 0) continue;
        if(combo.stat === "attack") stats.attack += combo.amount * lvl;
        else if(combo.stat === "hp") stats.maxHp += combo.amount * lvl;
        else if(combo.stat === "heal") stats.healRate += combo.amount * lvl;
      }
      return stats;
    }
    function setRogueBody(){
      if(!document.body.classList.contains("rogue")) document.body.classList.add("rogue");
    }
    ROGUE.meta = loadRogueMeta();
    const ROGUE_META_COST_MULT = 1.35;
    const ROGUE_META_REWARD_MULT = 0.85;
    const ROGUE_BUILDINGS = [
      { id:"forge", name:"Schmiede", desc:"+5 Angriff pro Level.", base:{ gold:120, wood:4 }, growth:1.35 },
      { id:"armory", name:"Ruestkammer", desc:"+20 Max-HP pro Level.", base:{ gold:150, stone:3 }, growth:1.35 },
      { id:"alchemy", name:"Alchemie", desc:"+5% Heilung pro Level.", base:{ gold:140, essence:2 }, growth:1.35 },
      { id:"library", name:"Bibliothek", desc:"Schaltet Skills frei (passiv).", base:{ gold:180, wood:2, essence:1 }, growth:1.35 },
      { id:"bank", name:"Bank", desc:"Zinsen auf Gold nach jedem Run.", base:{ gold:200, stone:2 }, growth:1.4 },
      { id:"market", name:"Marktplatz", desc:"Bessere Tauschraten fuer Ressourcen.", base:{ gold:160, wood:2, stone:2 }, growth:1.35 }
    ];
    const ROGUE_BIOME_RULES = {
      forest:   { hazard:"root",   goldMult:1.0, hpMult:1.0, loot:{ wood:2, stone:0, essence:0 } },
      farmland: { hazard:"root",   goldMult:1.4, hpMult:1.1, loot:{ wood:2, stone:1, essence:0 } },
      swamp:    { hazard:"poison", goldMult:2.2, hpMult:1.25, loot:{ wood:0, stone:0, essence:2 } },
      beach:    { hazard:"poison", goldMult:2.0, hpMult:1.2, loot:{ wood:0, stone:1, essence:1 } },
      glacier:  { hazard:"ice",    goldMult:3.0, hpMult:1.45, loot:{ wood:0, stone:2, essence:1 } }
    };
    // Glacier uses cave tiles as a placeholder until custom art is provided.
    const ROGUE_BIOMES = [
      { id: "forest", name: "Wald", bg: "Images/Zip/Cute_Fantasy/Cute_Fantasy/Tiles/Grass/Grass_2_Middle.png", filter: "blur(0.3px) saturate(1.05)", opacity: 0.36, size: "48px 48px", blend: "soft-light", mapSize: "48px 48px",
        pageBg: "linear-gradient(160deg, #1c2b1f, #0c1511)", scrollBg: "radial-gradient(circle at 20% 20%, rgba(120,180,120,.22), transparent 55%), radial-gradient(circle at 80% 30%, rgba(70,120,90,.2), transparent 60%), linear-gradient(160deg, rgba(20,40,26,.55), rgba(8,16,12,.75))",
        boardBg: "radial-gradient(circle at 20% 20%, rgba(90,120,90,.75), rgba(50,60,40,.45)), radial-gradient(circle at 80% 70%, rgba(80,140,110,.22), transparent 55%), linear-gradient(180deg, rgba(40,55,40,.75), rgba(20,30,20,.55))",
        accent: "#9adf8f", fog: "rgba(12,18,12,.55)",
        pageBgLight: "linear-gradient(160deg, #f4fbf2, #dfeee0)",
        scrollBgLight: "radial-gradient(circle at 20% 20%, rgba(170,210,170,.35), transparent 55%), radial-gradient(circle at 80% 30%, rgba(140,190,160,.25), transparent 60%), linear-gradient(160deg, rgba(245,250,244,.85), rgba(218,230,218,.9))",
        boardBgLight: "radial-gradient(circle at 20% 20%, rgba(210,230,210,.95), rgba(170,200,170,.75)), radial-gradient(circle at 80% 70%, rgba(140,190,160,.35), transparent 55%), linear-gradient(180deg, rgba(215,230,210,.85), rgba(190,210,185,.75))",
        accentLight: "#4e9a63", fogLight: "rgba(220,230,220,.7)", inkLight: "#2a2f2a"
      },
      { id: "farmland", name: "Felder", bg: "Images/Zip/Cute_Fantasy_Free/Cute_Fantasy_Free/Tiles/FarmLand_Tile.png", filter: "blur(0.2px) saturate(1.1) brightness(1.02)", opacity: 0.34, size: "48px 48px", blend: "soft-light", mapSize: "48px 48px",
        pageBg: "linear-gradient(160deg, #3a2a18, #1a1208)", scrollBg: "radial-gradient(circle at 15% 15%, rgba(200,150,90,.2), transparent 55%), radial-gradient(circle at 80% 30%, rgba(130,90,40,.2), transparent 60%), linear-gradient(160deg, rgba(60,35,15,.55), rgba(20,12,6,.75))",
        boardBg: "radial-gradient(circle at 20% 20%, rgba(140,95,60,.75), rgba(70,45,25,.45)), radial-gradient(circle at 80% 70%, rgba(170,120,70,.22), transparent 55%), linear-gradient(180deg, rgba(70,50,30,.75), rgba(35,22,14,.55))",
        accent: "#ffcf5a", fog: "rgba(30,20,10,.55)",
        pageBgLight: "linear-gradient(160deg, #fff6e6, #f2e2c8)",
        scrollBgLight: "radial-gradient(circle at 15% 15%, rgba(255,220,170,.35), transparent 55%), radial-gradient(circle at 80% 30%, rgba(210,170,110,.28), transparent 60%), linear-gradient(160deg, rgba(255,245,230,.9), rgba(240,220,190,.9))",
        boardBgLight: "radial-gradient(circle at 20% 20%, rgba(245,220,180,.95), rgba(210,180,140,.75)), radial-gradient(circle at 80% 70%, rgba(220,180,120,.35), transparent 55%), linear-gradient(180deg, rgba(240,215,180,.85), rgba(210,180,150,.75))",
        accentLight: "#b26a2f", fogLight: "rgba(240,225,205,.7)", inkLight: "#2f2417"
      },
      { id: "swamp", name: "Sumpf", bg: "Images/Zip/Cute_Fantasy/Cute_Fantasy/Tiles/Water/Water_Middle.png", filter: "blur(0.35px) saturate(0.8)", opacity: 0.3, size: "48px 48px", blend: "multiply", mapSize: "48px 48px",
        pageBg: "linear-gradient(160deg, #102a2a, #0a1515)", scrollBg: "radial-gradient(circle at 20% 20%, rgba(60,140,120,.22), transparent 55%), radial-gradient(circle at 80% 30%, rgba(40,90,80,.2), transparent 60%), linear-gradient(160deg, rgba(10,30,28,.6), rgba(6,14,12,.78))",
        boardBg: "radial-gradient(circle at 20% 20%, rgba(60,90,90,.75), rgba(30,50,50,.45)), radial-gradient(circle at 80% 70%, rgba(60,120,110,.22), transparent 55%), linear-gradient(180deg, rgba(20,45,45,.75), rgba(12,24,24,.55))",
        accent: "#7cf0c0", fog: "rgba(8,16,18,.55)",
        pageBgLight: "linear-gradient(160deg, #e7f6f1, #cfe8df)",
        scrollBgLight: "radial-gradient(circle at 20% 20%, rgba(160,220,200,.35), transparent 55%), radial-gradient(circle at 80% 30%, rgba(120,180,170,.25), transparent 60%), linear-gradient(160deg, rgba(235,248,244,.9), rgba(210,232,226,.9))",
        boardBgLight: "radial-gradient(circle at 20% 20%, rgba(210,235,228,.95), rgba(170,210,200,.75)), radial-gradient(circle at 80% 70%, rgba(140,200,190,.35), transparent 55%), linear-gradient(180deg, rgba(210,235,228,.85), rgba(180,212,205,.75))",
        accentLight: "#2e8f7b", fogLight: "rgba(210,230,225,.7)", inkLight: "#1e2b2a"
      },
      { id: "beach", name: "Strand", bg: "Images/Zip/Cute_Fantasy_Free/Cute_Fantasy_Free/Tiles/Beach_Tile.png", filter: "blur(0.2px) brightness(1.08) saturate(1.1)", opacity: 0.3, size: "48px 48px", blend: "soft-light", mapSize: "48px 48px",
        pageBg: "linear-gradient(160deg, #3a3a28, #16140f)", scrollBg: "radial-gradient(circle at 20% 20%, rgba(220,200,140,.2), transparent 55%), radial-gradient(circle at 80% 30%, rgba(140,120,70,.2), transparent 60%), linear-gradient(160deg, rgba(50,40,18,.55), rgba(18,14,8,.75))",
        boardBg: "radial-gradient(circle at 20% 20%, rgba(170,140,90,.75), rgba(80,60,30,.45)), radial-gradient(circle at 80% 70%, rgba(210,180,110,.22), transparent 55%), linear-gradient(180deg, rgba(80,70,40,.75), rgba(35,28,16,.55))",
        accent: "#ffd26a", fog: "rgba(22,18,10,.55)",
        pageBgLight: "linear-gradient(160deg, #fff8e2, #f2e4c6)",
        scrollBgLight: "radial-gradient(circle at 20% 20%, rgba(255,235,190,.35), transparent 55%), radial-gradient(circle at 80% 30%, rgba(215,190,130,.28), transparent 60%), linear-gradient(160deg, rgba(255,247,230,.9), rgba(235,220,190,.9))",
        boardBgLight: "radial-gradient(circle at 20% 20%, rgba(245,225,185,.95), rgba(210,190,150,.75)), radial-gradient(circle at 80% 70%, rgba(230,205,140,.35), transparent 55%), linear-gradient(180deg, rgba(240,220,185,.85), rgba(210,190,160,.75))",
        accentLight: "#c97a1e", fogLight: "rgba(235,225,205,.7)", inkLight: "#2f2a1f"
      },
      { id: "glacier", name: "Gletscher", bg: "Images/Zip/Cute_Fantasy/Cute_Fantasy/Tiles/Cave/Cave_Floor_Middle.png", filter: "blur(0.25px) brightness(1.12) saturate(0.65) hue-rotate(190deg)", opacity: 0.28, size: "48px 48px", blend: "soft-light", mapSize: "48px 48px",
        pageBg: "linear-gradient(160deg, #101b2d, #070b12)", scrollBg: "radial-gradient(circle at 20% 20%, rgba(120,170,255,.2), transparent 55%), radial-gradient(circle at 80% 30%, rgba(80,110,200,.2), transparent 60%), linear-gradient(160deg, rgba(12,18,32,.6), rgba(6,8,14,.78))",
        boardBg: "radial-gradient(circle at 20% 20%, rgba(90,120,180,.75), rgba(40,50,80,.45)), radial-gradient(circle at 80% 70%, rgba(120,160,240,.22), transparent 55%), linear-gradient(180deg, rgba(40,50,90,.75), rgba(18,22,40,.55))",
        accent: "#9dc6ff", fog: "rgba(8,12,22,.55)",
        pageBgLight: "linear-gradient(160deg, #eef6ff, #d6e7f5)",
        scrollBgLight: "radial-gradient(circle at 20% 20%, rgba(190,220,255,.35), transparent 55%), radial-gradient(circle at 80% 30%, rgba(160,190,230,.28), transparent 60%), linear-gradient(160deg, rgba(240,247,255,.9), rgba(216,232,245,.9))",
        boardBgLight: "radial-gradient(circle at 20% 20%, rgba(215,230,250,.95), rgba(180,200,230,.75)), radial-gradient(circle at 80% 70%, rgba(170,200,235,.35), transparent 55%), linear-gradient(180deg, rgba(220,235,250,.85), rgba(190,205,230,.75))",
        accentLight: "#3b6fa8", fogLight: "rgba(210,220,240,.7)", inkLight: "#1f2836"
      }
    ];
    const ENEMY_BASE = "Images/Zip/Tiny RPG Character Asset Pack v1.03b -Full 20 Characters/Tiny RPG Character Asset Pack v1.03 -Full 20 Characters/Characters(100x100)";
    const ROGUE_ENEMIES = [
      { id:"werewolf", name:"Werewolf", tier:"common", biomes:["forest"], img:`${ENEMY_BASE}/Werewolf/Werewolf/Werewolf.png`, desc:"Schneller Jager mit hohem Druck." },
      { id:"werebear", name:"Werebear", tier:"common", biomes:["forest"], img:`${ENEMY_BASE}/Werebear/Werebear/Werebear.png`, desc:"Traege Wucht, aber zaeh." },
      { id:"archer", name:"Archer", tier:"common", biomes:["forest"], img:`${ENEMY_BASE}/Archer/Archer/Archer.png`, desc:"Pfeile aus dem Schatten." },
      { id:"armoredaxeman", name:"Armored Axeman", tier:"elite", biomes:["forest"], img:`${ENEMY_BASE}/Armored Axeman/Armored Axeman/Armored Axeman.png`, desc:"Ruestung frisst Schaden." },
      { id:"soldier", name:"Soldier", tier:"common", biomes:["farmland"], img:`${ENEMY_BASE}/Soldier/Soldier/Soldier.png`, desc:"Solider Gegner, viele Treffer." },
      { id:"lancer", name:"Lancer", tier:"common", biomes:["farmland"], img:`${ENEMY_BASE}/Lancer/Lancer/Lancer.png`, desc:"Durchstoesst Schilde." },
      { id:"swordsman", name:"Swordsman", tier:"elite", biomes:["farmland"], img:`${ENEMY_BASE}/Swordsman/Swordsman/Swordsman.png`, desc:"Klingenmeister mit Tempo." },
      { id:"knight", name:"Knight", tier:"elite", biomes:["farmland"], img:`${ENEMY_BASE}/Knight/Knight/Knight.png`, desc:"Zaehe Verteidigung." },
      { id:"orcrider", name:"Orc Rider", tier:"boss", biomes:["farmland"], img:`${ENEMY_BASE}/Orc rider/Orc rider/Orc rider.png`, desc:"Boss mit Sturmangriff." },
      { id:"slime", name:"Slime", tier:"common", biomes:["swamp"], img:`${ENEMY_BASE}/Slime/Slime/Slime.png`, desc:"Teilt sich bei Treffer." },
      { id:"orc", name:"Orc", tier:"common", biomes:["swamp"], img:`${ENEMY_BASE}/Orc/Orc/Orc.png`, desc:"Roher Schaden." },
      { id:"armoredorc", name:"Armored Orc", tier:"elite", biomes:["swamp"], img:`${ENEMY_BASE}/Armored Orc/Armored Orc/Armored Orc.png`, desc:"Schwere Ruestung." },
      { id:"eliteorc", name:"Elite Orc", tier:"boss", biomes:["swamp"], img:`${ENEMY_BASE}/Elite Orc/Elite Orc/Elite Orc.png`, desc:"Boss mit brutaler Wut." },
      { id:"skeleton", name:"Skeleton", tier:"common", biomes:["beach"], img:`${ENEMY_BASE}/Skeleton/Skeleton/Skeleton.png`, desc:"Bricht leicht, kommt haeufig." },
      { id:"skeletonarcher", name:"Skeleton Archer", tier:"common", biomes:["beach"], img:`${ENEMY_BASE}/Skeleton Archer/Skeleton Archer/Skeleton Archer.png`, desc:"Fernangriff aus der Duene." },
      { id:"priest", name:"Priest", tier:"elite", biomes:["beach"], img:`${ENEMY_BASE}/Priest/Priest/Priest.png`, desc:"Segen fuer die Horde." },
      { id:"greatsword", name:"Greatsword Skeleton", tier:"boss", biomes:["beach"], img:`${ENEMY_BASE}/Greatsword Skeleton/Greatsword Skeleton/Greatsword Skeleton.png`, desc:"Boss mit schweren Hieben." },
      { id:"armoredskeleton", name:"Armored Skeleton", tier:"elite", biomes:["glacier"], img:`${ENEMY_BASE}/Armored Skeleton/Armored Skeleton/Armored Skeleton.png`, desc:"Kaeltepanzer." },
      { id:"wizard", name:"Wizard", tier:"elite", biomes:["glacier"], img:`${ENEMY_BASE}/Wizard/Wizard/Wizard.png`, desc:"Frostmagie und Tricks." },
      { id:"templar", name:"Knight Templar", tier:"boss", biomes:["glacier"], img:`${ENEMY_BASE}/Knight Templar/Knight Templar/Knight Templar.png`, desc:"Boss mit Phasenwechsel." }
    ];
    const ROGUE_SHOP_LINES = [
      "Hey Schatz, schau mal, was ich habe!",
      "Alles frisch poliert, nur fuer dich.",
      "Du willst weiter? Dann brauchst du das.",
      "Ich geb dir einen fairen Preis, versprochen."
    ];
    const ROGUE_BG_LINES = [
      "Nebel liegt auf dem Pfad.",
      "Die Luft riecht nach Gift.",
      "Etwas lauert im Dunkel.",
      "Das Eis knackt unter dir."
    ];
    const ROGUE_COMBO_PERKS = [
      { id:"moonshuffle", name:"Moonshuffle", heroes:["sleepy","mond"], stat:"attack", amount:2, base:{ gold:120, essence:1 }, growth:1.32, max:10, desc:"+2 Angriff pro Level." },
      { id:"therapy", name:"Therapy", heroes:["grumpy","happy"], stat:"hp", amount:12, base:{ gold:110, wood:2 }, growth:1.3, max:10, desc:"+12 Max-HP pro Level." },
      { id:"bittersweet", name:"Bittersweet", heroes:["sweety","cry"], stat:"heal", amount:0.012, base:{ gold:130, essence:1 }, growth:1.34, max:10, desc:"+1.2% Heilung pro Level." },
      { id:"sweetdreams", name:"Sweet Dreams", heroes:["sweety","sleepy"], stat:"heal", amount:0.01, base:{ gold:120, essence:1 }, growth:1.32, max:10, desc:"+1% Heilung pro Level." },
      { id:"buddies", name:"Buddies", heroes:["smokey","joyce"], stat:"attack", amount:1, base:{ gold:90, wood:2 }, growth:1.28, max:10, desc:"+1 Angriff pro Level." },
      { id:"safaritour", name:"Safari Tour", heroes:["giraffie","koala"], stat:"hp", amount:8, base:{ gold:140, stone:2 }, growth:1.35, max:10, desc:"+8 Max-HP pro Level." }
    ];
    const ROGUE_MARKET_OFFERS = [
      { id:"woodToGold", name:"Holz gegen Gold", give:{ wood:3 }, get:{ gold:45 }, kind:"sell" },
      { id:"stoneToGold", name:"Stein gegen Gold", give:{ stone:2 }, get:{ gold:55 }, kind:"sell" },
      { id:"essenceToGold", name:"Essenz gegen Gold", give:{ essence:1 }, get:{ gold:80 }, kind:"sell" },
      { id:"goldToEssence", name:"Gold gegen Essenz", give:{ gold:110 }, get:{ essence:1 }, kind:"buy" }
    ];
    const ROGUE_SHOP_ITEMS = [
      { id:"heal", name:"Heiltrank", desc:"+25 HP sofort", cost:40, iconKey:"lovelie", apply:()=>healPlayer(25) },
      { id:"bomb", name:"Bombenwurf", desc:"3x3 Feld leeren", cost:70, iconKey:"cit", apply:()=>clearRandomBlock(3) },
      { id:"shield", name:"Schutzrune", desc:"-2 Schaden fuer 3 Zuege", cost:55, iconKey:"supernuss", apply:()=>applyShield(2,3) },
      { id:"focus", name:"Kampffokus", desc:"+4 Angriff bis Kampfende", cost:65, iconKey:"giraffie", apply:()=>applyAttackBoost(4) },
      { id:"root", name:"Wurzel-Klinge", desc:"Entfernt alle Wurzeln", cost:45, iconKey:"smokey", apply:()=>clearRoots() },
      { id:"antidote", name:"Antidot", desc:"Entfernt Gift + blockt 5 Zuege", cost:45, iconKey:"mystBtn", apply:()=>applyAntidote(5) },
      { id:"ice", name:"Eispickel", desc:"Taut eine gefrorene Reihe", cost:50, iconKey:"mond", apply:()=>unfreezeOneRow() }
    ];
    function buildingCost(building, level){
      const mult = Math.pow(building.growth || 1.35, Math.max(0, level - 1));
      const out = {};
      for(const [k,v] of Object.entries(building.base)){
        out[k] = Math.max(1, Math.round(v * mult * ROGUE_META_COST_MULT));
      }
      return out;
    }
    function formatCost(cost){
      const parts = [];
      if(cost.gold) parts.push(`${cost.gold}G`);
      if(cost.wood) parts.push(`${cost.wood}W`);
      if(cost.stone) parts.push(`${cost.stone}S`);
      if(cost.essence) parts.push(`${cost.essence}E`);
      return parts.join(" ");
    }
    function hasResources(cost){
      const res = ROGUE.meta.resources;
      return (!cost.gold || res.gold >= cost.gold)
        && (!cost.wood || res.wood >= cost.wood)
        && (!cost.stone || res.stone >= cost.stone)
        && (!cost.essence || res.essence >= cost.essence);
    }
    function spendResources(cost){
      if(!hasResources(cost)) return false;
      const res = ROGUE.meta.resources;
      if(cost.gold) res.gold -= cost.gold;
      if(cost.wood) res.wood -= cost.wood;
      if(cost.stone) res.stone -= cost.stone;
      if(cost.essence) res.essence -= cost.essence;
      saveRogueMeta();
      return true;
    }
    function normalizeRogueMeta(){
      if(!Array.isArray(ROGUE.meta.unlockedHeroes)) ROGUE.meta.unlockedHeroes = [];
      ROGUE_STARTERS.forEach(k => {
        if(!ROGUE.meta.unlockedHeroes.includes(k)) ROGUE.meta.unlockedHeroes.push(k);
      });
      if(!ROGUE.meta.diffUnlocked) ROGUE.meta.diffUnlocked = { ...ROGUE_DEFAULT_META.diffUnlocked };
      ROGUE.meta.diffUnlocked.easy = true;
      if(!ROGUE.meta.selectedDiff || !ROGUE.meta.diffUnlocked[ROGUE.meta.selectedDiff]){
        ROGUE.meta.selectedDiff = "easy";
      }
      if(!ROGUE.meta.wins) ROGUE.meta.wins = { ...ROGUE_DEFAULT_META.wins };
      if(!Number.isFinite(ROGUE.meta.maxAct)) ROGUE.meta.maxAct = 0;
    }
    normalizeRogueMeta();
    setRogueDiff(getRogueDiffKey(), false);
    function getRogueDiffKey(){
      return ROGUE.meta.selectedDiff || "easy";
    }
    function isDiffUnlocked(key){
      return !!(ROGUE.meta.diffUnlocked && ROGUE.meta.diffUnlocked[key]);
    }
    function getRogueDiffMod(){
      return ROGUE_DIFF_MODS[getRogueDiffKey()] || ROGUE_DIFF_MODS.easy;
    }
    function setRogueDiff(key, persist=true){
      if(!DIFFS[key]) return;
      if(!isDiffUnlocked(key)) return;
      diff = DIFFS[key];
      ROGUE.meta.selectedDiff = key;
      if(persist) saveRogueMeta();
      syncRogueDiffUI();
    }
    function unlockNextDifficulty(key){
      const idx = ROGUE_DIFF_ORDER.indexOf(key);
      if(idx < 0) return;
      const next = ROGUE_DIFF_ORDER[idx + 1];
      if(next && !isDiffUnlocked(next)){
        ROGUE.meta.diffUnlocked[next] = true;
        saveRogueMeta();
        toast("Schwierigkeit frei", diffLabel(next) + " ist jetzt verfuegbar.", 2200);
      }
    }
    function registerRogueWin(){
      const key = getRogueDiffKey();
      if(!ROGUE.meta.wins[key]) ROGUE.meta.wins[key] = 0;
      ROGUE.meta.wins[key] += 1;
      unlockNextDifficulty(key);
      saveRogueMeta();
      syncRogueDiffUI();
    }
    const HERO_UNLOCK_CACHE = { order: null };
    function getHeroUnlockOrder(){
      if(HERO_UNLOCK_CACHE.order) return HERO_UNLOCK_CACHE.order;
      const all = BASES.filter(b => (!b.tag || b.tag === "normal"));
      const sorted = all.slice().sort((a,b)=>{
        const la = (a.minLevel || 1);
        const lb = (b.minLevel || 1);
        if(la !== lb) return la - lb;
        return (a.name || "").localeCompare(b.name || "");
      });
      HERO_UNLOCK_CACHE.order = sorted.map(b => b.key).filter(k => !ROGUE_STARTERS.includes(k));
      return HERO_UNLOCK_CACHE.order;
    }
    function isHeroUnlocked(key){
      if(!key) return false;
      if(!Array.isArray(ROGUE.meta.unlockedHeroes)) ROGUE.meta.unlockedHeroes = [];
      if(ROGUE_STARTERS.includes(key) && !ROGUE.meta.unlockedHeroes.includes(key)){
        ROGUE.meta.unlockedHeroes.push(key);
      }
      return ROGUE.meta.unlockedHeroes.includes(key);
    }
    function heroUnlockTier(key){
      const order = getHeroUnlockOrder();
      const idx = order.indexOf(key);
      if(idx < 0) return 0;
      return Math.floor(idx / 2) + 1;
    }
    function heroUnlockRequirement(key){
      const tier = heroUnlockTier(key);
      return Math.max(1, tier);
    }
    function heroUnlockCost(key){
      const order = getHeroUnlockOrder();
      const idx = order.indexOf(key);
      const tier = heroUnlockTier(key);
      if(idx < 0 || tier <= 0) return { gold: 0 };
      const gold = 160 + idx * 40 + tier * 60;
      const cost = { gold: Math.max(1, Math.round(gold * ROGUE_META_COST_MULT)) };
      if(tier >= 2) cost.wood = Math.max(1, Math.round((tier + 1) * 0.6));
      if(tier >= 3) cost.stone = Math.max(1, tier - 1);
      if(tier >= 4) cost.essence = Math.max(1, Math.floor((tier - 2) / 2) + 1);
      return cost;
    }
    function canUnlockHero(key){
      if(isHeroUnlocked(key)) return true;
      const req = heroUnlockRequirement(key);
      return (ROGUE.meta.maxAct || 0) >= req;
    }
    function unlockHero(key){
      if(isHeroUnlocked(key)) return true;
      if(!canUnlockHero(key)) return false;
      const cost = heroUnlockCost(key);
      if(!hasResources(cost)) return false;
      spendResources(cost);
      if(!ROGUE.meta.unlockedHeroes.includes(key)) ROGUE.meta.unlockedHeroes.push(key);
      saveRogueMeta();
      return true;
    }
    function heroName(key){
      if(!key) return "Unbekannt";
      const base = BASES.find(b => b.key === key);
      return base ? base.name : key;
    }
    function getHeroComboState(heroKey){
      if(!heroKey) return {};
      if(!ROGUE.meta.heroCombos[heroKey]) ROGUE.meta.heroCombos[heroKey] = {};
      return ROGUE.meta.heroCombos[heroKey];
    }
    function heroComboLevel(heroKey){
      if(!heroKey) return 0;
      const heroCombos = getHeroComboState(heroKey);
      let total = 0;
      for(const combo of ROGUE_COMBO_PERKS){
        if(!combo.heroes.includes(heroKey)) continue;
        total += heroCombos[combo.id] || 0;
      }
      return total;
    }
    function heroComboMax(heroKey){
      if(!heroKey) return 0;
      let total = 0;
      for(const combo of ROGUE_COMBO_PERKS){
        if(!combo.heroes.includes(heroKey)) continue;
        total += combo.max || 0;
      }
      return total;
    }
    function heroComboCap(heroKey){
      const base = 10;
      const lib = ROGUE.meta.buildings.library || 0;
      return base + (lib * 2);
    }
    function heroComboDisplayCap(heroKey){
      const cap = heroComboCap(heroKey);
      const max = heroComboMax(heroKey);
      return max > 0 ? Math.min(cap, max) : cap;
    }
    function comboResetCost(heroKey){
      const used = heroComboLevel(heroKey);
      if(used <= 0) return { gold: 0 };
      const gold = Math.round(70 * Math.pow(1.2, Math.max(0, used - 1)));
      const essence = Math.floor(used / 4);
      const wood = Math.floor(used / 6);
      const stone = Math.floor(used / 6);
      const cost = { gold: Math.max(1, Math.round(gold * ROGUE_META_COST_MULT)) };
      if(essence) cost.essence = Math.max(1, Math.round(essence * ROGUE_META_COST_MULT));
      if(wood) cost.wood = Math.max(1, Math.round(wood * ROGUE_META_COST_MULT));
      if(stone) cost.stone = Math.max(1, Math.round(stone * ROGUE_META_COST_MULT));
      return cost;
    }
    function comboCost(combo, level){
      const mult = Math.pow(combo.growth || 1.3, Math.max(0, level - 1));
      const out = {};
      for(const [k,v] of Object.entries(combo.base || {})){
        out[k] = Math.max(1, Math.round(v * mult * ROGUE_META_COST_MULT));
      }
      return out;
    }
    function marketOfferAdjusted(offer){
      const lvl = ROGUE.meta.buildings.market || 0;
      const bonus = 1 + (lvl * 0.08);
      const discount = Math.max(0.6, 1 - (lvl * 0.04));
      const give = { ...(offer.give || {}) };
      const get = { ...(offer.get || {}) };
      if(offer.kind === "sell" && get.gold){
        get.gold = Math.round(get.gold * bonus);
      } else if(offer.kind === "buy" && give.gold){
        give.gold = Math.round(give.gold * discount);
      }
      return { give, get };
    }
    function updateTownResources(){
      const el = document.getElementById("townResources");
      if(!el) return;
      const res = ROGUE.meta.resources;
      el.innerHTML = `
        <span>Gold ${res.gold||0}</span>
        <span>Wood ${res.wood||0}</span>
        <span>Stone ${res.stone||0}</span>
        <span>Essence ${res.essence||0}</span>
      `;
      const heroLabel = document.getElementById("townHeroName");
      if(heroLabel){
        const heroKey = ROGUE.meta.mainHero || ROGUE.run.heroKey;
        if(heroKey){
          const lvl = heroComboLevel(heroKey);
          const cap = heroComboDisplayCap(heroKey);
          heroLabel.textContent = `Main-Held: ${heroName(heroKey)} (${lvl}/${cap})`;
        } else {
          heroLabel.textContent = "Waehle erst einen Helden.";
        }
      }
    }
    function syncRogueDiffUI(){
      if(!ROGUE_MODE) return;
      const key = getRogueDiffKey();
      const inputs = document.querySelectorAll('#diffPills input[name="diff"], #townDiffPills input[name="rogueDiff"]');
      inputs.forEach(input => {
        const k = input.value;
        const unlocked = isDiffUnlocked(k);
        input.disabled = !unlocked;
        input.checked = (k === key);
        const label = document.querySelector(`label[for="${input.id}"]`);
        if(label) label.classList.toggle("locked", !unlocked);
      });
      const hint = document.getElementById("townDiffHint");
      if(hint){
        const nextKey = ROGUE_DIFF_ORDER.find(k => !isDiffUnlocked(k));
        if(nextKey){
          const prevIdx = Math.max(0, ROGUE_DIFF_ORDER.indexOf(nextKey) - 1);
          const prev = ROGUE_DIFF_ORDER[prevIdx] || "easy";
          hint.textContent = `Gewinne ${diffLabel(prev)} fuer ${diffLabel(nextKey)}.`;
        } else {
          hint.textContent = "Alle Schwierigkeiten frei.";
        }
      }
    }
    function renderTown(){
      const wrap = document.getElementById("townBuildings");
      if(!wrap) return;
      wrap.innerHTML = "";
      for(const b of ROGUE_BUILDINGS){
        const lvl = ROGUE.meta.buildings[b.id] || 0;
        const cost = buildingCost(b, lvl + 1);
        const card = document.createElement("div");
        card.className = "townCard";
        card.innerHTML = `
          <div class="title">${b.name}</div>
          <div class="desc">${b.desc}</div>
          <div class="lvl">Level ${lvl}</div>
          <div class="desc">Upgrade: ${formatCost(cost)}</div>
        `;
        const btn = document.createElement("button");
        btn.className = "Btn ghost";
        btn.textContent = "Upgrade";
        btn.addEventListener("click", ()=>{
          if(!hasResources(cost)){
            toast("Zu teuer", "Dir fehlen Ressourcen.", 1800);
            return;
          }
          spendResources(cost);
          ROGUE.meta.buildings[b.id] = lvl + 1;
          saveRogueMeta();
          renderTown();
          updateTownResources();
        });
        card.appendChild(btn);
        wrap.appendChild(card);
      }
      renderTownHeroes();
      renderTownCombos();
      renderTownMarket();
    }
    function renderTownHeroes(){
      const wrap = document.getElementById("townHeroes");
      if(!wrap) return;
      wrap.innerHTML = "";
      const hint = document.getElementById("townHeroUnlockHint");
      if(hint) hint.textContent = `Akt ${ROGUE.meta.maxAct || 0} erreicht.`;
      const all = BASES.filter(b => (!b.tag || b.tag === "normal"));
      const order = getHeroUnlockOrder();
      const orderIndex = (key)=>{
        const idx = order.indexOf(key);
        return idx < 0 ? 999 : idx;
      };
      const sorted = all.slice().sort((a,b)=>{
        const aStarter = ROGUE_STARTERS.includes(a.key);
        const bStarter = ROGUE_STARTERS.includes(b.key);
        if(aStarter && !bStarter) return -1;
        if(bStarter && !aStarter) return 1;
        const ia = orderIndex(a.key);
        const ib = orderIndex(b.key);
        if(ia !== ib) return ia - ib;
        return (a.name || "").localeCompare(b.name || "");
      });
      const lockedHeroes = sorted.filter(b => !isHeroUnlocked(b.key));
      if(!lockedHeroes.length){
        const note = document.createElement("div");
        note.className = "townNote";
        note.textContent = "Alle Helden sind bereits freigeschaltet.";
        wrap.appendChild(note);
        return;
      }
      lockedHeroes.forEach(b => {
        const reqAct = heroUnlockRequirement(b.key);
        const cost = heroUnlockCost(b.key);
        const canUnlock = (ROGUE.meta.maxAct || 0) >= reqAct;
        const card = document.createElement("div");
        card.className = "heroCard locked";
        const imgSrc = IMG_LARGE[b.key] || b.img || IMG[b.key] || "";
        card.innerHTML = `
          <div class="heroArt">${imgSrc ? `<img src="${imgSrc}" alt="${b.name}">` : ""}</div>
          <div class="heroName">${b.name || b.key}</div>
          <div class="heroNote">Akt ${reqAct} noetig</div>
          <div class="heroNote">Kosten: ${formatCost(cost)}</div>
        `;
        const btn = document.createElement("button");
        btn.className = "Btn ghost";
        btn.textContent = canUnlock ? "Freischalten" : "Gesperrt";
        btn.disabled = !canUnlock;
        btn.addEventListener("click", ()=>{
          if(!canUnlock){
            toast("Gesperrt", `Erreiche Akt ${reqAct}.`, 1800);
            return;
          }
          if(!hasResources(cost)){
            toast("Zu teuer", "Dir fehlen Ressourcen.", 1800);
            return;
          }
          if(unlockHero(b.key)){
            renderTownHeroes();
            renderRogueCharSelect(window.rogueEngine);
            updateTownResources();
            toast("Freigeschaltet", `${b.name} ist jetzt spielbar.`, 2000);
          }
        });
        card.appendChild(btn);
        wrap.appendChild(card);
      });
    }
    function renderTownCombos(){
      const wrap = document.getElementById("townCombos");
      if(!wrap) return;
      wrap.innerHTML = "";
      const heroKey = ROGUE.meta.mainHero || ROGUE.run.heroKey;
      if(!heroKey){
        const note = document.createElement("div");
        note.className = "townNote";
        note.textContent = "Waehle einen Helden, um Kombos freizuschalten.";
        wrap.appendChild(note);
        return;
      }
      const combos = ROGUE_COMBO_PERKS.filter(c => c.heroes.includes(heroKey));
      const heroCombos = getHeroComboState(heroKey);
      const used = heroComboLevel(heroKey);
      const cap = heroComboDisplayCap(heroKey);
      const capRaw = heroComboCap(heroKey);
      if(!combos.length){
        const note = document.createElement("div");
        note.className = "townNote";
        note.textContent = "Fuer diesen Helden gibt es noch keine Kombos.";
        wrap.appendChild(note);
        return;
      }
      const slotNote = document.createElement("div");
      slotNote.className = "townNote";
      slotNote.textContent = `Combo slots: ${used}/${cap}. Library adds +2 per level (cap ${capRaw}).`;
      wrap.appendChild(slotNote);
      combos.forEach(combo => {
        const lvl = heroCombos[combo.id] || 0;
        const nextCost = comboCost(combo, lvl + 1);
        const card = document.createElement("div");
        card.className = "townCard comboCard";
        card.innerHTML = `
          <div class="comboBadge">Combo</div>
          <div class="title">${combo.name}</div>
          <div class="desc">${combo.desc}</div>
          <div class="comboIconsSmall">
            <img src="${IMG_SMALL[combo.heroes[0]] || IMG[combo.heroes[0]]}" alt="">
            <span>+</span>
            <img src="${IMG_SMALL[combo.heroes[1]] || IMG[combo.heroes[1]]}" alt="">
          </div>
          <div class="lvl">Level ${lvl}/${combo.max}</div>
          <div class="desc">Kosten: ${formatCost(nextCost)}</div>
        `;
        const btn = document.createElement("button");
        btn.className = "Btn ghost";
        const atCap = used >= cap;
        btn.textContent = (lvl >= combo.max) ? "Max" : (atCap ? "Limit" : "Kaufen");
        btn.disabled = (lvl >= combo.max) || atCap;
        btn.addEventListener("click", ()=>{
          if(lvl >= combo.max) return;
          if(used >= cap){
            toast("Limit", "Combo slots voll.", 1800);
            return;
          }
          if(!hasResources(nextCost)){
            toast("Zu teuer", "Dir fehlen Ressourcen.", 1800);
            return;
          }
          spendResources(nextCost);
          heroCombos[combo.id] = lvl + 1;
          saveRogueMeta();
          renderTownCombos();
          updateTownResources();
        });
        card.appendChild(btn);
        wrap.appendChild(card);
      });
      const resetCard = document.createElement("div");
      resetCard.className = "townCard";
      const resetCost = comboResetCost(heroKey);
      resetCard.innerHTML = `
        <div class="title">Reset Kombos</div>
        <div class="desc">Loescht alle Kombos fuer diesen Helden.</div>
        <div class="desc">Kosten: ${formatCost(resetCost)}</div>
      `;
      const resetBtn = document.createElement("button");
      resetBtn.className = "Btn ghost";
      resetBtn.textContent = (used > 0) ? "Reset" : "Leer";
      resetBtn.disabled = (used <= 0);
      resetBtn.addEventListener("click", ()=>{
        if(used <= 0) return;
        if(!hasResources(resetCost)){
          toast("Zu teuer", "Dir fehlen Ressourcen.", 1800);
          return;
        }
        spendResources(resetCost);
        ROGUE.meta.heroCombos[heroKey] = {};
        saveRogueMeta();
        renderTownCombos();
        updateTownResources();
      });
      resetCard.appendChild(resetBtn);
      wrap.appendChild(resetCard);
    }
    function renderTownMarket(){
      const wrap = document.getElementById("townMarket");
      if(!wrap) return;
      wrap.innerHTML = "";
      ROGUE_MARKET_OFFERS.forEach(offer => {
        const adj = marketOfferAdjusted(offer);
        const card = document.createElement("div");
        card.className = "townCard marketCard";
        card.innerHTML = `
          <div class="title">${offer.name}</div>
          <div class="desc">Gib: ${formatCost(adj.give)}</div>
          <div class="desc">Erhalte: ${formatCost(adj.get)}</div>
        `;
        const btn = document.createElement("button");
        btn.className = "Btn ghost";
        btn.textContent = "Tauschen";
        btn.addEventListener("click", ()=>{
          if(!hasResources(adj.give)){
            toast("Zu teuer", "Dir fehlen Ressourcen.", 1800);
            return;
          }
          spendResources(adj.give);
          const res = ROGUE.meta.resources;
          if(adj.get.gold) res.gold += adj.get.gold;
          if(adj.get.wood) res.wood += adj.get.wood;
          if(adj.get.stone) res.stone += adj.get.stone;
          if(adj.get.essence) res.essence += adj.get.essence;
          saveRogueMeta();
          renderTownMarket();
          updateTownResources();
        });
        card.appendChild(btn);
        wrap.appendChild(card);
      });
    }
    function showTown(show){
      const town = document.getElementById("townView");
      if(!town) return;
      town.style.display = show ? "flex" : "none";
      if(show){
        updateTownResources();
        renderTown();
        syncRogueDiffUI();
        const cont = document.getElementById("townContinueRun");
        const startBtn = document.getElementById("townStartRun");
        if(cont) cont.style.display = (ROGUE.run.active && !ROGUE.run.inCombat) ? "inline-flex" : "none";
        if(startBtn) startBtn.textContent = (ROGUE.run.active ? "Neuer Run" : "Run starten");
      }
    }
    function applyMetaToRun(full=true){
      const stats = calcRogueStats(ROGUE.meta, ROGUE.run.heroKey || ROGUE.meta.mainHero);
      ROGUE.run.attack = stats.attack;
      if(window.rogueEngine && window.rogueEngine.state){
        window.rogueEngine.state.maxHp = stats.maxHp;
        window.rogueEngine.state.hp = full ? stats.maxHp : Math.min(window.rogueEngine.state.hp || stats.maxHp, stats.maxHp);
      }
    }
    function resetRogueRun(){
      ROGUE.run.active = true;
      ROGUE.run.inCombat = false;
      ROGUE.run.node = null;
      ROGUE.run.nodeType = "combat";
      ROGUE.run.biomeId = "forest";
      ROGUE.run.hazard = "root";
      ROGUE.run.heroKey = ROGUE.meta.mainHero || null;
      ROGUE.run.act = 1;
      ROGUE.run.actComplete = false;
      ROGUE.run.enemy = null;
      ROGUE.run.enemyHp = 0;
      ROGUE.run.enemyMaxHp = 0;
      ROGUE.run.enemyAtk = 0;
      ROGUE.run.shield = 0;
      ROGUE.run.shieldTurns = 0;
      ROGUE.run.poisonBlockTurns = 0;
      ROGUE.run.poisonTurns = 0;
      ROGUE.run.attackBonus = 0;
      ROGUE.run.freezeRow = null;
      ROGUE.run.turn = 0;
      ROGUE.run.winReady = false;
      ROGUE.run.loseReady = false;
      ROGUE.run.loot = { wood: 0, stone: 0, essence: 0 };
      ROGUE.run.pending = { bombs: 0, clearRoots: false, unfreeze: false };
      if(window.rogueEngine && window.rogueEngine.state){
        window.rogueEngine.state.gold = 0;
      }
      applyMetaToRun(true);
    }
    function startRogueRun(continueRun=false){
      if(window.rogueEngine){
        if(continueRun && ROGUE.run.active){
          showTown(false);
          if(ROGUE.run.actComplete){
            startNextAct();
          } else {
            window.rogueEngine.showMap();
          }
          return;
        }
        resetRogueRun();
        showTown(false);
        setRogueDiff(getRogueDiffKey(), false);
        if(ROGUE._origStartNewRun) ROGUE._origStartNewRun();
        else window.rogueEngine.init();
      }
    }
    function biomeRule(id){
      return ROGUE_BIOME_RULES[id] || ROGUE_BIOME_RULES.forest;
    }
    function biomeById(id){
      return ROGUE_BIOMES.find(b => b.id === id) || ROGUE_BIOMES[0];
    }
    function applyBiomeTheme(biome){
      const b = biome || ROGUE_BIOMES[0];
      if(!b) return;
      const isDark = document.body.classList.contains("dark");
      const fallbackDark = "linear-gradient(160deg, #1b1530, #0f0b1a)";
      const fallbackLight = "linear-gradient(160deg, #f7f5fb, #e9ecf5)";
      const pageBg = isDark ? (b.pageBg || fallbackDark) : (b.pageBgLight || b.pageBg || fallbackLight);
      const scrollBg = isDark ? (b.scrollBg || "") : (b.scrollBgLight || b.scrollBg || "");
      const boardBg = isDark ? (b.boardBg || "") : (b.boardBgLight || b.boardBg || "");
      const accent = isDark ? (b.accent || "#7ad8ff") : (b.accentLight || b.accent || "#4b7aa8");
      const fog = isDark ? (b.fog || "rgba(20,20,40,.55)") : (b.fogLight || b.fog || "rgba(220,230,245,.7)");
      const ink = isDark ? (b.ink || "#e7e3f7") : (b.inkLight || b.ink || "#2c2336");
      document.documentElement.style.setProperty("--biome-page-bg", pageBg);
      document.documentElement.style.setProperty("--biome-scroll-bg", scrollBg);
      document.documentElement.style.setProperty("--biome-scroll-opacity", b.scrollOpacity || "0.35");
      document.documentElement.style.setProperty("--biome-board-bg", boardBg);
      document.documentElement.style.setProperty("--biome-accent", accent);
      document.documentElement.style.setProperty("--biome-fog", fog);
      document.documentElement.style.setProperty("--biome-ink", ink);
    }
    function awardNodeLoot(node){
      const rule = biomeRule(node?.biome?.id || "forest");
      const depth = (node && typeof node.row === "number") ? node.row + 1 : level;
      const baseGold = 18 + depth * 6;
      const mult = rule.goldMult || 1;
      const bossMult = (node && node.type === "boss") ? 2.2 : 1;
      const addGold = Math.round(baseGold * mult * bossMult * ROGUE_META_REWARD_MULT);
      if(window.rogueEngine && window.rogueEngine.state){
        window.rogueEngine.state.gold = (window.rogueEngine.state.gold || 0) + addGold;
      }
      if(rule.loot){
        ROGUE.run.loot.wood += Math.round((rule.loot.wood || 0) * ROGUE_META_REWARD_MULT);
        ROGUE.run.loot.stone += Math.round((rule.loot.stone || 0) * ROGUE_META_REWARD_MULT);
        ROGUE.run.loot.essence += Math.round((rule.loot.essence || 0) * ROGUE_META_REWARD_MULT);
      }
    }
    function snapshotRogueLoot(){
      const runGold = window.rogueEngine?.state?.gold || 0;
      ROGUE.run.lastLoot = {
        gold: runGold,
        wood: ROGUE.run.loot.wood || 0,
        stone: ROGUE.run.loot.stone || 0,
        essence: ROGUE.run.loot.essence || 0
      };
      return runGold;
    }
    function finishRogueRun(){
      const stats = calcRogueStats(ROGUE.meta, ROGUE.run.heroKey || ROGUE.meta.mainHero);
      const res = ROGUE.meta.resources;
      const runGold = snapshotRogueLoot();
      res.gold += runGold;
      res.wood += ROGUE.run.loot.wood || 0;
      res.stone += ROGUE.run.loot.stone || 0;
      res.essence += ROGUE.run.loot.essence || 0;
      const interest = Math.floor(res.gold * stats.interest);
      if(interest > 0) res.gold += interest;
      saveRogueMeta();
      ROGUE.run.active = false;
      ROGUE.run.inCombat = false;
      ROGUE.run.act = 1;
      ROGUE.run.actComplete = false;
      ROGUE.run.loot = { wood: 0, stone: 0, essence: 0 };
      if(window.rogueEngine && window.rogueEngine.state) window.rogueEngine.state.gold = 0;
      showTown(true);
    }
    function completeRogueAct(){
      const finishedAct = Math.max(1, ROGUE.run.act || 1);
      ROGUE.run.inCombat = false;
      ROGUE.run.winReady = false;
      ROGUE.run.loseReady = false;
      ROGUE.run.actComplete = true;
      ROGUE.run.act = finishedAct + 1;
      if((ROGUE.meta.maxAct || 0) < finishedAct){
        ROGUE.meta.maxAct = finishedAct;
        saveRogueMeta();
      }
      registerRogueWin();
      snapshotRogueLoot();
      showRogueSummary(true, true);
    }
    function startNextAct(){
      if(!window.rogueEngine) return;
      ROGUE.run.active = true;
      ROGUE.run.actComplete = false;
      ROGUE.run.inCombat = false;
      ROGUE.run.node = null;
      ROGUE.run.nodeType = "combat";
      ROGUE.run.biomeId = "forest";
      ROGUE.run.hazard = "root";
      window.ROGUE_PENDING_NODE = null;
      window.rogueEngine.generateMap();
      window.rogueEngine.showMap();
      syncRogueDiffUI();
    }
    function setStatLabel(id, text){
      const v = document.getElementById(id);
      if(!v) return;
      const k = v.parentElement ? v.parentElement.querySelector(".k") : null;
      if(k) k.textContent = text;
    }
    function initRogueUI(){
      if(!ROGUE_MODE) return;
      setRogueBody();
      applyBiomeTheme(biomeById("forest"));
      setStatLabel("uiLevel", "Node");
      setStatLabel("uiGoal", "Enemy");
      setStatLabel("uiScore", "HP");
      setStatLabel("uiMoves", "Moves");
      setStatLabel("uiCombo", "Gold");
      const progLabel = document.querySelector(".progressRow b");
      if(progLabel) progLabel.textContent = "Enemy HP";
      const hudProgLabel = document.querySelector("#fsHud .hudProg .tiny");
      if(hudProgLabel) hudProgLabel.textContent = "Enemy";
      const maxHud = document.getElementById("maxHud");
      if(maxHud){
        const labels = maxHud.querySelectorAll(".pill b");
        if(labels.length >= 4){
          labels[0].textContent = "Node";
          labels[1].textContent = "HP";
          labels[2].textContent = "Moves";
          labels[3].textContent = "Gold";
        }
      }
      const goLabel = document.querySelector("#gameOverBack .stat .k");
      if(goLabel) goLabel.textContent = "Run Loot";
      const goName = document.getElementById("goName");
      if(goName) goName.style.display = "none";
      const goPost = document.getElementById("goPost");
      if(goPost) goPost.style.display = "none";
      const goNew = document.getElementById("goNew");
      if(goNew) goNew.textContent = "Zur Stadt";
      const shopBackBtn = document.getElementById("shopBackBtn");
      if(shopBackBtn) shopBackBtn.addEventListener("click", ()=>window.rogueEngine && window.rogueEngine.showMap());
      const townStart = document.getElementById("townStartRun");
      if(townStart) townStart.addEventListener("click", ()=>startRogueRun(false));
      const townContinue = document.getElementById("townContinueRun");
      if(townContinue) townContinue.addEventListener("click", ()=>startRogueRun(true));
      syncRogueDiffUI();
    }
    function updateRogueUI(){
      const st = window.rogueEngine ? window.rogueEngine.state : null;
      const hp = st ? (st.hp || 0) : 0;
      const maxHp = st ? (st.maxHp || 0) : 0;
      const gold = st ? (st.gold || 0) : 0;
      ui.level.textContent = level;
      ui.goal.textContent = `${ROGUE.run.enemyHp}/${ROGUE.run.enemyMaxHp}`;
      ui.score.textContent = `${hp}/${maxHp}`;
      ui.moves.textContent = moves;
      ui.combo.textContent = gold;
      const pct = ROGUE.run.enemyMaxHp > 0 ? clamp(Math.round((ROGUE.run.enemyHp/ROGUE.run.enemyMaxHp)*100), 0, 100) : 0;
      ui.bar.style.setProperty("--pct", pct+"%");
      ui.pct.textContent = pct+"%";
      ui.hudLevel.textContent = "Node "+level;
      ui.hudScore.textContent = "HP "+hp+"/"+maxHp;
      ui.hudMoves.textContent = "Moves "+moves;
      ui.hudCombo.textContent = "Gold "+gold;
      ui.hudBar.style.setProperty("--pct", pct+"%");
      ui.hudPct.textContent = pct+"%";
      const ml = document.getElementById("maxLvl");
      const ms = document.getElementById("maxScore");
      const mm = document.getElementById("maxMoves");
      const mc = document.getElementById("maxCombo");
      if(ml) ml.textContent = level;
      if(ms) ms.textContent = hp+"/"+maxHp;
      if(mm) mm.textContent = moves;
      if(mc) mc.textContent = gold;
      const enemy = ROGUE.run.enemy;
      const enemyImg = document.getElementById("enemyImg");
      const enemyName = document.getElementById("enemyName");
      const enemyTier = document.getElementById("enemyTier");
      const enemyDesc = document.getElementById("enemyDesc");
      const enemyBiome = document.getElementById("enemyBiome");
      const enemyHazard = document.getElementById("enemyHazard");
      const biome = biomeById(ROGUE.run.biomeId);
      const hazard = biomeRule(ROGUE.run.biomeId).hazard;
      if(enemyImg) enemyImg.src = enemy?.img || "";
      if(enemyName) enemyName.textContent = enemy?.name || "Gegner";
      if(enemyTier){
        enemyTier.textContent = enemy?.tier ? enemy.tier.toUpperCase() : "—";
        enemyTier.dataset.tier = enemy?.tier || "";
      }
      if(enemyDesc) enemyDesc.textContent = enemy?.desc || "—";
      if(enemyBiome) enemyBiome.textContent = biome ? biome.name : "Biome";
      if(enemyHazard) enemyHazard.textContent = hazard === "root" ? "Wurzeln" : (hazard === "poison" ? "Gift" : "Eis");
      checkRoguePendingOutcome();
    }
    function getShopItemsForBiome(){
      const hazard = ROGUE.run.hazard || biomeRule(ROGUE.run.biomeId).hazard;
      return ROGUE_SHOP_ITEMS.filter(item => {
        if(item.id === "root") return hazard === "root";
        if(item.id === "antidote") return hazard === "poison";
        if(item.id === "ice") return hazard === "ice";
        return true;
      });
    }
    function pickRogueEnemy(node){
      const biomeId = node?.biome?.id || ROGUE.run.biomeId || "forest";
      const pool = ROGUE_ENEMIES.filter(e => (e.biomes || []).includes(biomeId));
      const bosses = pool.filter(e => e.tier === "boss");
      const elites = pool.filter(e => e.tier === "elite");
      const commons = pool.filter(e => e.tier === "common");
      const pick = (arr)=>arr[Math.floor(Math.random() * arr.length)];
      if(node?.type === "boss" && bosses.length) return pick(bosses);
      if(Math.random() < 0.18 && elites.length) return pick(elites);
      if(commons.length) return pick(commons);
      return pool.length ? pick(pool) : null;
    }
    function renderShop(){
      const grid = document.getElementById("shopContent");
      if(!grid) return;
      grid.innerHTML = "";
      const hostImg = document.getElementById("shopHostImg");
      if(hostImg && IMG?.lovelie) hostImg.src = IMG.lovelie;
      const candyImg = document.getElementById("shopCandyImg");
      if(candyImg && IMG?.powerBtn) candyImg.src = IMG.powerBtn;
      const decor1 = document.getElementById("shopDecor1");
      const decor2 = document.getElementById("shopDecor2");
      const decor3 = document.getElementById("shopDecor3");
      if(decor1 && IMG?.sweety) decor1.src = IMG.sweety;
      if(decor2 && IMG?.sleepy) decor2.src = IMG.sleepy;
      if(decor3 && IMG?.cry) decor3.src = IMG.cry;
      const lineEl = document.getElementById("shopLine");
      const bubbleEl = document.getElementById("shopBubble");
      const line = ROGUE_SHOP_LINES[Math.floor(Math.random() * ROGUE_SHOP_LINES.length)];
      if(lineEl) lineEl.textContent = line;
      if(bubbleEl) bubbleEl.textContent = line;
      const items = getShopItemsForBiome();
      for(const item of items){
        const card = document.createElement("div");
        card.className = "shopItem";
        const iconSrc = item.iconKey ? (IMG[item.iconKey] || IMG_SMALL[item.iconKey]) : item.icon;
        card.innerHTML = `
          <div class="shopItemHead">
            ${iconSrc ? `<img class="shopIcon" src="${iconSrc}" alt="">` : ""}
            <div>
              <div class="title">${item.name}</div>
              <div class="desc">${item.desc}</div>
            </div>
          </div>
          <div class="cost">${item.cost}G</div>
        `;
        card.addEventListener("click", ()=>{
          const st = window.rogueEngine ? window.rogueEngine.state : null;
          const gold = st ? (st.gold || 0) : 0;
          if(gold < item.cost){
            toast("Zu teuer", "Dir fehlen Goldmuenzen.", 1600);
            return;
          }
          if(st) st.gold = gold - item.cost;
          item.apply();
          renderShop();
          updateRogueUI();
        });
        grid.appendChild(card);
      }
      const st = window.rogueEngine ? window.rogueEngine.state : null;
      const shopGold = document.getElementById("shopGold");
      const shopHp = document.getElementById("shopHp");
      if(shopGold) shopGold.textContent = st ? (st.gold || 0) : 0;
      if(shopHp) shopHp.textContent = st ? `${st.hp||0}/${st.maxHp||0}` : "0/0";
      const notes = document.getElementById("shopNotes");
      if(notes){
        const effects = [];
        if(ROGUE.run.shieldTurns > 0) effects.push(`Shield ${ROGUE.run.shield} (${ROGUE.run.shieldTurns} turns)`);
        if(ROGUE.run.poisonBlockTurns > 0) effects.push(`Antidote (${ROGUE.run.poisonBlockTurns} turns)`);
        notes.textContent = effects.length ? "Aktive Effekte: " + effects.join(" | ") : "Keine aktiven Effekte.";
      }
    }
    function setupRogueCombat(node){
      if(!ROGUE_MODE) return;
      window.ROGUE_PENDING_NODE = null;
      ROGUE.run.active = true;
      ROGUE.run.inCombat = true;
      ROGUE.run.node = node || null;
      ROGUE.run.nodeType = node?.type || "combat";
      ROGUE.run.biomeId = node?.biome?.id || "forest";
      ROGUE.run.hazard = biomeRule(ROGUE.run.biomeId).hazard;
      ROGUE.run.enemy = pickRogueEnemy(node);
      applyBiomeTheme(node?.biome || biomeById(ROGUE.run.biomeId));
      const baseAtk = calcRogueStats(ROGUE.meta, ROGUE.run.heroKey || ROGUE.meta.mainHero).attack;
      const bonusAtk = ROGUE.run.attackBonus || 0;
      ROGUE.run.attack = baseAtk + bonusAtk;
      ROGUE.run.attackBonus = 0;
      ROGUE.run.turn = 0;
      ROGUE.run.winReady = false;
      ROGUE.run.loseReady = false;
      ROGUE.run.poisonTurns = 0;
      ROGUE.run.freezeRow = rows - 1;
      const baseDepth = (node && typeof node.row === "number") ? node.row + 1 : level;
      const actSize = (window.rogueEngine && window.rogueEngine.state && window.rogueEngine.state.mapRows) ? window.rogueEngine.state.mapRows : 18;
      const depth = baseDepth + ((ROGUE.run.act || 1) - 1) * actSize;
      const rule = biomeRule(ROGUE.run.biomeId);
      const baseHp = 120 + depth * 28;
      const bossMult = (node && node.type === "boss") ? 2.4 : 1;
      const hpMult = rule.hpMult || 1;
      const diffMod = getRogueDiffMod();
      ROGUE.run.enemyMaxHp = Math.round(baseHp * hpMult * bossMult * (diffMod.hp || 1));
      ROGUE.run.enemyHp = ROGUE.run.enemyMaxHp;
      ROGUE.run.enemyAtk = Math.round((5 + depth * 2.4) * (hpMult || 1) * 0.32 * (diffMod.atk || 1));
      if(ROGUE.run.enemyAtk < 3) ROGUE.run.enemyAtk = 3;
      const lib = ROGUE.meta.buildings.library || 0;
      moves = calcMoves(depth) + Math.floor(lib / 3);
      applyBiomeHazards();
      applyPendingCombatItems();
      updateRogueUI();
    }
    function showRogueSummary(win, actComplete=false){
      const back = document.getElementById("gameOverBack");
      if(!back) return;
      const title = back.querySelector("h2");
      const sub = back.querySelector(".sub");
      const contBtn = document.getElementById("goContinue");
      const goNew = document.getElementById("goNew");
      const last = ROGUE.run.lastLoot || { gold:0, wood:0, stone:0, essence:0 };
      const lootText = `G${last.gold||0} W${last.wood||0} S${last.stone||0} E${last.essence||0}`;
      if(title) title.textContent = win ? (actComplete ? "AKT GESCHAFFT" : "RUN GESCHAFFT") : "RUN GESCHEITERT";
      if(sub) sub.textContent = win ? (actComplete ? "Akt geschafft! Weiter oder Run beenden?" : "Boss besiegt! Zeit fuer die Stadt.") : "Du wurdest besiegt. Staerke dich in der Stadt.";
      if(goNew) goNew.textContent = actComplete ? "Run beenden" : "Zur Stadt";
      const score = document.getElementById("goScore");
      if(score) score.textContent = lootText;
      if(contBtn){
        contBtn.style.display = (win && actComplete) ? "inline-flex" : "none";
        contBtn.textContent = `Weiter (Akt ${ROGUE.run.act || 2})`;
      }
      back.style.display = "flex";
    }
    function endRogueCombat(win){
      if(!ROGUE_MODE) return;
      ROGUE.run.inCombat = false;
      ROGUE.run.winReady = false;
      ROGUE.run.loseReady = false;
      if(win){
        awardNodeLoot(ROGUE.run.node);
        if(ROGUE.run.nodeType === "boss"){
          completeRogueAct();
        } else {
          toast("Sieg", "Zur Map", 1800);
          setTimeout(()=>window.rogueEngine && window.rogueEngine.showMap(), 450);
        }
      } else {
        finishRogueRun();
        showRogueSummary(false);
      }
    }
    function checkRoguePendingOutcome(){
      if(!ROGUE.run.inCombat) return;
      if(resolving || busy) return;
      if(ROGUE.run.winReady) endRogueCombat(true);
      else if(ROGUE.run.loseReady) endRogueCombat(false);
    }
    function applyEnemyAttack(turns=1){
      if(!ROGUE.run.inCombat) return;
      if(ROGUE.run.enemyHp <= 0) return;
      const st = window.rogueEngine ? window.rogueEngine.state : null;
      if(!st) return;
      let dmg = Math.max(0, (ROGUE.run.enemyAtk - ROGUE.run.shield)) * turns;
      if(dmg > 0) st.hp = Math.max(0, (st.hp || 0) - dmg);
      if(ROGUE.run.shieldTurns > 0){
        ROGUE.run.shieldTurns = Math.max(0, ROGUE.run.shieldTurns - turns);
        if(ROGUE.run.shieldTurns === 0) ROGUE.run.shield = 0;
      }
      if(st.hp <= 0) ROGUE.run.loseReady = true;
    }
    function applyRogueTurnEffects(turns=1){
      if(!ROGUE.run.inCombat) return;
      const hazard = biomeRule(ROGUE.run.biomeId).hazard;
      if(ROGUE.run.poisonBlockTurns > 0){
        ROGUE.run.poisonBlockTurns = Math.max(0, ROGUE.run.poisonBlockTurns - turns);
      }
      if(hazard === "poison" && ROGUE.run.poisonBlockTurns === 0){
        ROGUE.run.poisonTurns += turns;
        if(ROGUE.run.poisonTurns >= 5){
          spawnPoisonTiles(2);
          ROGUE.run.poisonTurns = 0;
        }
      }
      if(hazard === "ice"){
        ROGUE.run.freezeTurns = (ROGUE.run.freezeTurns || 0) + turns;
        if(ROGUE.run.freezeTurns >= 4){
          freezeNextRow();
          ROGUE.run.freezeTurns = 0;
        }
      }
    }
    function damageEnemy(amount){
      if(amount <= 0) return;
      ROGUE.run.enemyHp = Math.max(0, ROGUE.run.enemyHp - amount);
      if(ROGUE.run.enemyHp <= 0) ROGUE.run.winReady = true;
    }
    function damagePlayer(amount){
      const st = window.rogueEngine ? window.rogueEngine.state : null;
      if(!st || amount <= 0) return;
      st.hp = Math.max(0, (st.hp || 0) - amount);
      if(st.hp <= 0) ROGUE.run.loseReady = true;
    }
    function healPlayer(amount){
      const st = window.rogueEngine ? window.rogueEngine.state : null;
      if(!st || amount <= 0) return;
      st.hp = Math.min(st.maxHp || st.hp, (st.hp || 0) + amount);
    }
    function applyShield(amount, turns){
      ROGUE.run.shield = Math.max(ROGUE.run.shield, amount);
      ROGUE.run.shieldTurns = Math.max(ROGUE.run.shieldTurns, turns);
    }
    function applyAttackBoost(amount){
      if(ROGUE.run.inCombat){
        ROGUE.run.attack += amount;
      } else {
        ROGUE.run.attackBonus = (ROGUE.run.attackBonus || 0) + amount;
      }
    }
    function applyAntidote(turns){
      clearPoison();
      ROGUE.run.poisonBlockTurns = Math.max(ROGUE.run.poisonBlockTurns, turns);
    }
    function clearRandomBlock(size){
      if(!ROGUE.run.inCombat || !isGridReady()){
        ROGUE.run.pending.bombs += 1;
        return;
      }
      const r = Math.floor(Math.random() * rows);
      const c = Math.floor(Math.random() * cols);
      const half = Math.floor(size/2);
      const cells = [];
      for(let rr=r-half; rr<=r+half; rr++){
        for(let cc=c-half; cc<=c+half; cc++){
          if(inBounds(rr,cc)) cells.push({r:rr,c:cc});
        }
      }
      clearCells(cells, {protectPower:true});
    }
    function applyRogueMatchResults(clearedTiles, matchInfo){
      if(!ROGUE.run.inCombat) return;
      const stats = calcRogueStats(ROGUE.meta, ROGUE.run.heroKey || ROGUE.meta.mainHero);
      const baseAtk = (ROGUE.run.attack || stats.attack);
      const perTile = baseAtk * 0.65;
      let damage = Math.round((clearedTiles?.length || 0) * perTile);
      if(matchInfo && (matchInfo.hRuns || matchInfo.vRuns)){
        const runs = (matchInfo.hRuns || []).concat(matchInfo.vRuns || []);
        for(const run of runs){
          if(run.len >= 4){
            damage += Math.round(perTile * (run.len - 3) * 0.6);
          }
        }
      }
      if(damage > 0) damageEnemy(damage);
      let poisonHits = 0;
      for(const t of clearedTiles || []){
        if(t && t.poisoned) poisonHits++;
      }
      if(poisonHits > 0) damagePlayer(poisonHits * 6);
      if(matchInfo && (matchInfo.hRuns || matchInfo.vRuns)){
        const healPerRun = Math.round(stats.maxHp * stats.healRate);
        const runs = (matchInfo.hRuns || []).concat(matchInfo.vRuns || []);
        let heals = 0;
        for(const run of runs){
          if(run.len >= 4) heals += healPerRun;
        }
        if(heals > 0) healPlayer(heals);
      }
    }
    function syncTileFlags(el, tile){
      if(!el || !tile) return;
      el.classList.toggle("locked", !!tile.locked);
      el.classList.toggle("rooted", !!tile.rooted);
      el.classList.toggle("poisoned", !!tile.poisoned);
      el.classList.toggle("frozen", !!tile.frozen);
    }
    function applyBiomeHazards(){
      const hazard = biomeRule(ROGUE.run.biomeId).hazard;
      if(hazard === "root") applyRoots(4 + Math.floor(level/2));
      if(hazard === "poison") spawnPoisonTiles(3);
      if(hazard === "ice") freezeNextRow();
    }
    function applyPendingCombatItems(){
      if(!ROGUE.run.pending) return;
      if(ROGUE.run.pending.clearRoots){
        clearRoots();
        ROGUE.run.pending.clearRoots = false;
      }
      if(ROGUE.run.pending.unfreeze){
        unfreezeOneRow();
        ROGUE.run.pending.unfreeze = false;
      }
      if(ROGUE.run.pending.bombs > 0){
        const count = ROGUE.run.pending.bombs;
        ROGUE.run.pending.bombs = 0;
        for(let i=0;i<count;i++) clearRandomBlock(3);
      }
    }
    function applyRoots(count){
      if(!isGridReady()) return;
      const candidates = [];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          if(t.rooted) continue;
          candidates.push(t);
        }
      }
      for(let i=candidates.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }
      const picked = candidates.slice(0, Math.min(count, candidates.length));
      for(const t of picked){
        t.rooted = true;
        t.locked = true;
        const el = tileEls.get(t.id);
        syncTileFlags(el, t);
      }
    }
    function unlockRootsAround(clearedCells){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const p of clearedCells){
        for(const d of dirs){
          const rr = p.r + d[0];
          const cc = p.c + d[1];
          if(!inBounds(rr,cc)) continue;
          const t = grid[rr][cc];
          if(t && t.rooted){
            t.rooted = false;
            t.locked = false;
            const el = tileEls.get(t.id);
            syncTileFlags(el, t);
          }
        }
      }
    }
    function spawnPoisonTiles(count){
      if(!isGridReady()) return;
      const candidates = [];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          if(t.poisoned) continue;
          candidates.push(t);
        }
      }
      for(let i=candidates.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }
      const picked = candidates.slice(0, Math.min(count, candidates.length));
      for(const t of picked){
        t.poisoned = true;
        const el = tileEls.get(t.id);
        syncTileFlags(el, t);
      }
    }
    function clearPoison(){
      if(!isGridReady()) return;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(!t || !t.poisoned) continue;
          t.poisoned = false;
          const el = tileEls.get(t.id);
          syncTileFlags(el, t);
        }
      }
    }
    function freezeNextRow(){
      if(!isGridReady()) return;
      if(ROGUE.run.freezeRow == null) ROGUE.run.freezeRow = rows - 1;
      if(ROGUE.run.freezeRow < 0) return;
      const r = ROGUE.run.freezeRow;
      for(let c=0;c<cols;c++){
        const t = grid[r][c];
        if(!t) continue;
        t.frozen = true;
        t.locked = true;
        t.blocker = true;
        const el = tileEls.get(t.id);
        syncTileFlags(el, t);
      }
      ROGUE.run.freezeRow -= 1;
    }
    function unfreezeOneRow(){
      if(!ROGUE.run.inCombat || !isGridReady()){
        ROGUE.run.pending.unfreeze = true;
        return;
      }
      for(let r=0;r<rows;r++){
        let any = false;
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(!t || !t.frozen) continue;
          any = true;
          t.frozen = false;
          t.locked = false;
          t.blocker = false;
          const el = tileEls.get(t.id);
          syncTileFlags(el, t);
        }
        if(any) break;
      }
    }
    function clearRoots(){
      if(!ROGUE.run.inCombat || !isGridReady()){
        ROGUE.run.pending.clearRoots = true;
        return;
      }
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(!t || !t.rooted) continue;
          t.rooted = false;
          t.locked = false;
          const el = tileEls.get(t.id);
          syncTileFlags(el, t);
        }
      }
    }
    const ROGUE_MAP_ROWS = 18;
    const ROGUE_MAP_COLS = 5;
    function generateCenteredMap(engine){
      if(!engine || !engine.state) return;
      const rows = ROGUE_MAP_ROWS;
      const cols = ROGUE_MAP_COLS;
      const center = Math.floor(cols / 2);
      const band = [center - 1, center, center + 1].filter(c => c >= 0 && c < cols);
      const nodes = [];
      const rowNodes = [];
      let id = 0;

      engine.state.map = [];
      engine.state.currentNode = -1;
      engine.state.path = [];
      engine.state.mapCols = cols;
      engine.state.mapRows = rows;

      const biomeSequence = (engine.biomes && engine.biomes.length)
        ? engine.biomes.slice(0, 5)
        : ROGUE_BIOMES.slice(0, 5);
      const rowsPerBiome = Math.max(3, Math.floor((rows - 1) / Math.max(1, biomeSequence.length)));
      const biomeForRow = (row) => {
        const idx = Math.min(Math.floor(row / rowsPerBiome), biomeSequence.length - 1);
        return biomeSequence[idx] || biomeSequence[0];
      };
      engine.state.biomeSequence = biomeSequence.map(b => b.id);

      const shopRows = new Set();
      let nextShop = 3 + Math.floor(Math.random() * 2);
      while(nextShop < rows - 1){
        shopRows.add(nextShop);
        nextShop += 3 + Math.floor(Math.random() * 2);
      }
      const typeForRow = (row) => {
        if(row === rows - 1) return "boss";
        if(shopRows.has(row)) return "shop";
        return "combat";
      };

      const addRow = (row, colsPicked) => {
        const rowList = [];
        colsPicked.forEach(c => {
          const node = { id: id++, row: row, col: c, type: typeForRow(row), biome: biomeForRow(row), next: [] };
          nodes.push(node);
          rowList.push(node);
        });
        rowNodes.push(rowList);
      };

      addRow(0, [center]);
      if(rows > 1){
        const row1 = [];
        if(center - 1 >= 0) row1.push(center - 1);
        if(center + 1 < cols) row1.push(center + 1);
        if(row1.length < 2) row1.push(center);
        addRow(1, row1);
      }
      if(rows > 2) addRow(2, band.slice());

      let spine = center;
      const shiftSpine = () => {
        const opts = [spine - 1, spine, spine + 1].filter(c => band.includes(c));
        spine = opts[Math.floor(Math.random() * opts.length)];
      };

      for(let r=3; r<rows; r++){
        if(r === rows - 1){
          addRow(r, [center]);
          continue;
        }
        if(Math.random() < 0.7) shiftSpine();
        const roll = Math.random();
        let colsPicked;
        if(roll < 0.16){
          colsPicked = [spine];
        } else if(roll < 0.62){
          if(spine === band[0]) colsPicked = [band[0], band[1]];
          else if(spine === band[2]) colsPicked = [band[1], band[2]];
          else colsPicked = (Math.random() < 0.5) ? [band[0], band[1]] : [band[1], band[2]];
        } else {
          colsPicked = band.slice();
        }
        addRow(r, colsPicked.filter(c => c != null));
      }

      for(let r=0; r<rows-1; r++){
        const curr = rowNodes[r] || [];
        const next = rowNodes[r+1] || [];
        curr.forEach(n => { n.next = []; });
        curr.forEach(n => {
          const options = next.filter(t => Math.abs(t.col - n.col) <= 1);
          options.forEach(t => n.next.push(t.id));
        });
      }

      engine.state.map = nodes;
    }
    function patchRogueMap(){
      if(!window.rogueEngine) return;
      window.rogueEngine.biomes = ROGUE_BIOMES.slice();
      window.rogueEngine.generateMap = function(){
        generateCenteredMap(this);
      };
    }
    function applyMapFog(){
      const nodes = document.querySelectorAll("#mapNodes .map-node");
      nodes.forEach(el => {
        const locked = el.classList.contains("locked");
        const active = el.classList.contains("active");
        const done = el.classList.contains("done");
        const wiggle = (Math.random() * 16 - 8).toFixed(1);
        el.style.setProperty("--wiggle-x", wiggle + "px");
        if(locked){
          el.classList.add("fogged");
          if(!el.dataset.realLabel) el.dataset.realLabel = el.textContent;
          el.textContent = "?";
        } else {
          el.classList.remove("fogged");
          if(el.dataset.realLabel && (active || done)) el.textContent = el.dataset.realLabel;
        }
      });
    }
    function renderRogueCharSelect(engine){
      const list = document.getElementById("charList");
      if(!list) return;
      list.innerHTML = "";
      const starters = new Set(ROGUE_STARTERS);
      const all = BASES.filter(b => (!b.tag || b.tag === "normal"));
      const sorted = all.slice().sort((a,b)=>{
        const ia = ROGUE_STARTERS.indexOf(a.key);
        const ib = ROGUE_STARTERS.indexOf(b.key);
        if(ia !== -1 || ib !== -1){
          if(ia === -1) return 1;
          if(ib === -1) return -1;
          return ia - ib;
        }
        return (a.name || "").localeCompare(b.name || "");
      });
      const selectedKey = (engine && engine.tempHero) ? engine.tempHero : (ROGUE.meta.mainHero || "");
      sorted.forEach(b => {
        const locked = !isHeroUnlocked(b.key);
        const card = document.createElement("div");
        card.className = "char-card" + (locked ? " locked" : "");
        if(selectedKey && selectedKey === b.key) card.classList.add("selected");
        const imgSrc = locked ? (IMG.mystBtn || IMG_SMALL.myst || "") : (IMG_LARGE[b.key] || b.img || "");
        const label = locked ? "???" : b.name;
        const lvl = heroComboLevel(b.key);
        const cap = heroComboDisplayCap(b.key);
        const reqAct = heroUnlockRequirement(b.key);
        const note = locked ? `Akt ${reqAct}` : (starters.has(b.key) ? "Starter" : "Freigeschaltet");
        card.innerHTML = `
          <div class="charArt">${imgSrc ? `<img src="${imgSrc}" alt="${label}">` : ""}</div>
          <h3>${label}</h3>
          <div class="charLvl">${lvl}/${cap}</div>
          <div class="charNote">${note}</div>
        `;
        if(locked){
          card.addEventListener("click", ()=>{
            toast("Gesperrt", `In der Stadt freischalten (Akt ${reqAct}).`, 2200);
          });
        } else {
          card.addEventListener("click", ()=>{
            list.querySelectorAll(".char-card").forEach(c => c.classList.remove("selected"));
            card.classList.add("selected");
            if(engine) engine.tempHero = b.key;
          });
        }
        list.appendChild(card);
      });
    }
    function setupRogueHooks(){
      if(!ROGUE_MODE || !window.rogueEngine || window.rogueEngine._roguePatched) return;
      window.rogueEngine._roguePatched = true;
      patchRogueMap();
      window.rogueEngine.renderCharSelect = function(){
        renderRogueCharSelect(this);
      };
      const origStartCombat = window.rogueEngine.startCombat.bind(window.rogueEngine);
      window.rogueEngine.startCombat = function(node){
        window.ROGUE_PENDING_NODE = node;
        origStartCombat(node);
        setTimeout(()=>setupRogueCombat(node), 60);
      };
      const origConfirmChar = window.rogueEngine.confirmChar.bind(window.rogueEngine);
      window.rogueEngine.confirmChar = function(){
        if(this.tempHero){
          ROGUE.run.heroKey = this.tempHero;
          ROGUE.meta.mainHero = this.tempHero;
          saveRogueMeta();
        }
        origConfirmChar();
      };
      const origShowMap = window.rogueEngine.showMap.bind(window.rogueEngine);
      window.rogueEngine.showMap = function(){
        ROGUE.run.inCombat = false;
        origShowMap();
        try{
          const active = window.rogueEngine.getActiveNodes ? window.rogueEngine.getActiveNodes() : [];
          const biome = active.length ? active[0].biome : null;
          applyBiomeTheme(biome || biomeById(ROGUE.run.biomeId));
        }catch(e){}
        applyMapFog();
      };
      window.rogueEngine.openShop = function(){
        ROGUE.run.inCombat = false;
        window.rogueEngine.showScene("shopView");
        renderShop();
      };
      const origStartNewRun = window.rogueEngine.startNewRun.bind(window.rogueEngine);
      ROGUE._origStartNewRun = origStartNewRun;
      window.rogueEngine.startNewRun = function(){
        resetRogueRun();
        ROGUE.run.active = false;
        showTown(true);
      };
    }

    /**********************
     * Helpers
     **********************/
    // duplicate clamp removed (function clamp is defined earlier)
    const posKey=(r,c)=>`${r},${c}`;
    function toast(title, subtitle="", ms=2600){
      document.documentElement.style.setProperty("--toastMs", ms+"ms");
      const wrap = document.getElementById("toast");
      const t = document.createElement("div");
      t.className="toast";
      t.innerHTML = `${title}${subtitle?`<small>${subtitle}</small>`:""}`;
      wrap.appendChild(t);
      setTimeout(()=>t.remove(), ms);
    }

    function typeId(baseKey, variant){ return `${baseKey}:${variant}`; }
    function parseTypeId(id){
      if(!id) return {baseKey:"", variant:"P"};
      if(!id.includes(":")) return {baseKey:id, variant:"P"};
      const [baseKey, variant] = id.split(":");
      return {baseKey, variant};
    }
    const matchKey = (tile)=>{
      const p = parseTypeId(tile?.type);
      return `${p.baseKey}`;
    };

    /**********************
     * Combo unlock tracking (simple cookie-based log)
     **********************/
    const COMBOS = {
      moonshuffle: { title:"Moon Dream Shuffle", desc:"Shuffle Combo", story:"3x Sleepy + 1x Mondlie -> Board wird neu gemixt.", icons:["sleepy","sleepy","sleepy","mond"] },
      therapy: { title:"Grumpy Therapy", desc:"Moves Boost", story:"Happy beruhigt die Grumpy-Crew -> du bekommst extra Moves.", icons:["grumpy","grumpy","grumpy","happy"] },
      sprinkle: { title:"Sprinkle Beam", desc:"Beam Combo", story:"3x Donut + Sweety -> Glitzer-Beam raeumt auf.", icons:["donut","donut","donut","sweety"] },
      sugar: { title:"Zuckerrausch", desc:"Rush Combo", story:"3x Donut + Happy -> Extra-Clears + Bonus-Moves.", icons:["donut","donut","donut","happy"] },
      buddies: { title:"Buddy Burst", desc:"Buddy-Welle", story:"3x Joyce + 1x Smokey (oder umgekehrt) -> Wellen-Boom.", icons:["joyce","joyce","joyce","smokey"] },
      bestbuddies: { title:"Best Buddies Wave", desc:"Buddy-Finale", story:"3x Simba + 1x Smokey (oder umgekehrt) -> Reihe+Spalte + Bonus.", icons:["simba","simba","simba","smokey"] },
      
      // Powerup Combos (UI)
      crossblast: { title:"Mega Cross Blast", desc:"Cross Clear", story:"Koala + Worm -> Riesiger Kreuz-Knall!", icons:["koala","worm"] },
      bigbang: { title:"Big Bang", desc:"Double Clean", story:"Koala + Citrussy -> Board Clean x2!", icons:["koala","cit"] },
      weaver: { title:"Weaver Web", desc:"Checkerboard", story:"Worm + Worm -> Schachbrett-Muster Wipe.", icons:["worm","worm"] },
      starburst: { title:"Star Burst", desc:"Star Clear", story:"Worm + Citrussy -> Sternförmige Explosion.", icons:["worm","cit"] },
      
      // New Character Combos
      safaritour: { title:"Safari Tour", desc:"High Ground", story:"3x Giraffie + 1x Koala -> Räumt die oberen 2 Reihen ab.", icons:["giraffie","giraffie","giraffie","koala"] },
      towerpower: { title:"Tower Power", desc:"Laser Neck", story:"Giraffie + Supernuss -> Spalte weg + 2 Powerups.", icons:["giraffie","supernuss"] },

      // Gap Fillers
      bittersweet: { title:"Bittersweet", desc:"Sour Surprise", story:"2x Sweety + 2x Cry -> Ein saurer Wurm erscheint.", icons:["sweety","sweety","cry","cry"] },
      sweetdreams: { title:"Sweet Dreams", desc:"Nap Time", story:"Sweety + Sleepy -> Bereich mischen + 2 Moves.", icons:["sweety","sweety","sweety","sleepy"] },

      // Secret Boss
      zillacrush: { title:"Zilla Crush", desc:"Boss vs Boss", story:"Ein neuer Boss verdrängt den alten!", icons:["mellowzilla","mellowzilla"] }
    };

    function comboKeysForBase(baseKey){
      if(!baseKey) return [];
      const keys = [];
      for(const k of Object.keys(COMBOS)){
        const c = COMBOS[k];
        if(c && c.icons && c.icons.includes(baseKey)) keys.push(k);
      }
      return keys;
    }

    function loadComboCookie(){
      try{
        const raw = getCookie("luvvies_combos");
        if(!raw) return new Set();
        return new Set(JSON.parse(raw));
      }catch(e){ return new Set(); }
    }
    let combosUnlocked = loadComboCookie();
    let autoResolveQueued = false;
    let resolving = false;
    function saveCombos(){
      try{ setCookie("luvvies_combos", JSON.stringify([...combosUnlocked]), 3650); }catch(e){}
    }
    function renderCombos(){
      if(ROGUE_MODE) return;
      const box = document.getElementById("comboList");
      if(!box) return;
      const keys = Object.keys(COMBOS);
      box.innerHTML = "";

      keys.forEach((k)=>{
        const c = COMBOS[k];
        const unlocked = combosUnlocked.has(k);
        const row = document.createElement("div");
        row.className = "comboItem" + (unlocked ? "" : " locked");
        row.dataset.combo = k;

        const label = document.createElement("div");
        label.textContent = unlocked ? c.title : "???";

        const icons = document.createElement("div");
        icons.className = "comboIcons";
        const keysToShow = unlocked ? c.icons : Array((c.icons && c.icons.length) || 0).fill(null);
        keysToShow.forEach((key, idx)=>{
          if(idx>0){
            const plus = document.createElement("span");
            plus.className = "comboPlus";
            plus.textContent = "+";
            icons.appendChild(plus);
          }
          if(key){
            const img = document.createElement("img");
            img.src = IMG_SMALL[key] || IMG[key] || "";
            img.alt = key;
            icons.appendChild(img);
          }else{
            const q = document.createElement("span");
            q.className = "comboPlus";
            q.textContent = "?";
            icons.appendChild(q);
          }
        });

        row.appendChild(label);
        row.appendChild(icons);
        if(unlocked){
          row.addEventListener("click", ()=>showComboModal(k, false));
        }
        box.appendChild(row);
      });
    }
    function positionComboModal(){
      const back = document.getElementById("comboBack");
      const modal = document.getElementById("comboModal");
      const board = document.getElementById("boardWrap");
      if(!back || !modal || !board) return;

      const rect = board.getBoundingClientRect();
      const mw = Math.min(420, window.innerWidth * 0.92);
      const mh = modal.offsetHeight || 200;
      const spaceRight = window.innerWidth - rect.right;
      const left = (spaceRight > mw + 20) ? (rect.right + 12) : Math.max(12, rect.left - mw - 12);
      const top = clamp(rect.top + rect.height * 0.18, 10, getViewportHeight() - mh - 10);
      modal.style.left = left + "px";
      modal.style.top = top + "px";
    }
    function showComboModal(key, isNew){
      if(ROGUE_MODE) return;
      const c = COMBOS[key];
      if(!c) return;
      const back = document.getElementById("comboBack");
      const title = document.getElementById("comboTitle");
      const story = document.getElementById("comboStory");
      const icons = document.getElementById("comboIcons");
      if(!back || !title || !story || !icons) return;

      title.textContent = c.title;
      story.textContent = (isNew ? "Freigeschaltet! " : "") + (c.story || c.desc || "");
      icons.innerHTML = "";

      c.icons.forEach((k, idx)=>{
        if(idx>0){
          const plus = document.createElement("span");
          plus.className = "comboPlus";
          plus.textContent = "+";
          icons.appendChild(plus);
        }
        const img = document.createElement("img");
        img.src = IMG_SMALL[k] || IMG[k] || "";
        img.alt = k;
        icons.appendChild(img);
      });

      back.style.display = "block";
      positionComboModal();
    }
    function unlockCombo(key){
      if(ROGUE_MODE) return;
      if(!COMBOS[key]) return;
      if(combosUnlocked.has(key)) return;
      combosUnlocked.add(key);
      saveCombos();
      showComboModal(key, true);
      renderCombos();
    }
    function getBase(baseKey){ return BASES.find(b=>b.key===baseKey) || null; }
    function getSpecial(baseKey){ return SPECIALS[baseKey] || null; }
    function inBounds(r,c){ return r>=0 && c>=0 && r<rows && c<cols; }

    function isPowerupKey(k){ return k==="worm" || k==="cit" || k==="koala"; }

    function isPlaceholder(t){ return t && t.type==="mellow_part"; }
    function isBlocker(t){
      if(!t) return false;
      if(t.blocker || t.frozen) return true;
      const bk = parseTypeId(t.type).baseKey;
      // Small mellow is NO LONGER a blocker (so it falls/swaps)
      if(bk==="mellowlord" || bk==="mellowzilla" || bk==="koalazilla") return true;
      if(isPlaceholder(t)) return true;
      return false;
    }

    function isSwappable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      if(tile.locked) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(baseKey==="myst") return false; // ??? nur klicken
      return true;
    }
    function isMatchable(tile){
      if(!tile) return false;
      if(isBlocker(tile)) return false;
      const {baseKey} = parseTypeId(tile.type);
      if(getSpecial(baseKey)) return false;
      return true;
    }

    function calcTarget(lv){
      return Math.round(diff.baseTarget * (1 + (lv-1)*diff.targetGrow));
    }
    function calcMoves(lv){
      const m = diff.baseMoves + (lv-1)*diff.movesPerLevel;
      // Cap max moves to avoid accumulating too many (e.g. 70 moves at lvl 39 is too much)
      // Cap at 25 extra moves max (so base + 25)
      const cap = diff.baseMoves + 25;
      return Math.min(m, cap);
    }
    function scorePerTile(){ return Math.round(60 * diff.scoreMult); }

    function clearHints(){
      for(const el of tileEls.values()) el.classList.remove("hint");
    }

    /**********************
     * FX helpers
     **********************/
    function tileCenter(r,c){
      // Use getBoundingClientRect to map board cell to FX layer space
      // Find a tile at this pos, or calculate where it would be
      // If tile exists, use it. If not, use slot calc.
      // But calculating slot position relative to boardWrap is tricky if board is centered.
      // Best way: Use the 'board' element rect.
      const boardRect = ui.board.getBoundingClientRect();
      const fxRect = ui.fx.getBoundingClientRect();

      const pad = currentPad();
      const localX = pad + c*(CELL+GAP) + CELL/2;
      const localY = pad + r*(CELL+GAP) + CELL/2;

      // Board Pos relative to FX layer
      const boardX = boardRect.left - fxRect.left;
      const boardY = boardRect.top - fxRect.top;

      return { x: boardX + localX, y: boardY + localY };
    }
    // GIF-only FX mode (performance): disable HTML particle spam for combos
    const FX_GIF_ONLY = true;
    const COMBO_SPRITE = { cols: 4, rows: 4, frames: 16, fps: 28 };


    function makeStar(x,y, big=false){
      if(FX_GIF_ONLY) return;

      const s = document.createElement("div");
      s.className="star";
      s.style.left = x+"px";
      s.style.top  = y+"px";

      // Random size for "unique peng"
      const size = big ? (20 + Math.random()*12) : (10 + Math.random()*8);
      s.style.width = size+"px";
      s.style.height= size+"px";

      // Fully random pastel color
      const h = Math.floor(Math.random()*360);
      const sat = 70 + Math.random()*30;
      const light = 70 + Math.random()*20;

      s.style.background = `radial-gradient(circle at 30% 30%, hsl(${h}, ${sat}%, ${light+10}%), hsl(${h}, ${sat}%, ${light-10}%))`;
      // Random rotation
      s.style.transform = `translate(-50%, -50%) rotate(${Math.random()*360}deg)`;

      ui.fx.appendChild(s);
      setTimeout(()=>s.remove(), 900);
    }
    function ringFx(x,y){
      if(FX_GIF_ONLY) return;

      const r=document.createElement("div");
      r.className="ring";
      r.style.left=x+"px"; r.style.top=y+"px";
      ui.fx.appendChild(r);
      setTimeout(()=>r.remove(), 760);
    }
      function burstFx(x,y, count=12){
        if(FX_GIF_ONLY) return;
  
        ringFx(x,y);
        for(let i=0;i<count;i++){
          const ang = Math.random()*Math.PI*2;
          const dist = 10 + Math.random()*40;
          makeStar(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist, Math.random()<0.4);
        }
      }
  
      function showComboSprite(r, c){
         if(!IMG.comboSprite) return;
         const fx = document.createElement("div");
         fx.className = "comboSprite";
 
         const size = Math.round(Math.min(190, Math.max(86, CELL + 24)));
         fx.style.width = size + "px";
         fx.style.height = size + "px";
       const hue = Math.floor(Math.random() * 360);
       const rot = Math.floor(Math.random() * 360);
       const wiggle = 18 + Math.floor(Math.random() * 30);
       const dur = 1100 + Math.floor(Math.random() * 1200);
       const delay = -Math.floor(Math.random() * dur);
       const sat = (2.6 + Math.random() * 2.2).toFixed(2);
       const br = (0.95 + Math.random() * 0.25).toFixed(2);
       const flicker = 140 + Math.floor(Math.random() * 220);
       fx.style.setProperty("--rainbow-hue", hue + "deg");
       fx.style.setProperty("--rainbow-dur", dur + "ms");
       fx.style.setProperty("--rainbow-delay", delay + "ms");
       fx.style.setProperty("--rainbow-sat", sat);
       fx.style.setProperty("--rainbow-br", br);
       fx.style.setProperty("--flicker-dur", flicker + "ms");
       fx.style.setProperty("--combo-rot", rot + "deg");
       fx.style.setProperty("--combo-wiggle", wiggle + "deg");
         fx.style.backgroundImage = "url('" + IMG.comboSprite + "')";
         fx.style.backgroundSize = (COMBO_SPRITE.cols * size) + "px " + (COMBO_SPRITE.rows * size) + "px";

       const {x,y} = tileCenter(r,c);
       fx.style.left = x + "px";
       fx.style.top  = y + "px";

       ui.fx.appendChild(fx);

       let frame = 0;
       const frameCount = COMBO_SPRITE.frames;
       const frameMs = Math.max(16, Math.round(1000 / COMBO_SPRITE.fps));
       const setFrame = (idx)=>{
         const col = idx % COMBO_SPRITE.cols;
         const row = Math.floor(idx / COMBO_SPRITE.cols);
         fx.style.backgroundPosition = (-col * size) + "px " + (-row * size) + "px";
       };
       setFrame(0);
       const timer = setInterval(()=>{
         frame++;
         if(frame >= frameCount){
           clearInterval(timer);
           fx.remove();
           return;
         }
         setFrame(frame);
       }, frameMs);

       setTimeout(()=>{
         clearInterval(timer);
         fx.remove();
       }, frameMs * frameCount + 60);
    }

    function showComboAnim(score, r, c){
       if(ROGUE_MODE) return;
       if(!ui._comboPool){
         ui._comboPool = [];
         ui._comboPoolIdx = 0;
       }

       const MIN_POOL = 22;
       while(ui._comboPool.length < MIN_POOL){
         const fx = document.createElement("div");
         fx.className = "comboFx";
         const txtEl = document.createElement("div");
         txtEl.className = "comboScore";
         fx.appendChild(txtEl);
         ui.fx.appendChild(fx);
         ui._comboPool.push({ fx, txtEl, timer: 0 });
       }

       const entry = ui._comboPool[ui._comboPoolIdx++ % ui._comboPool.length];
       const fx = entry.fx;
       const txtEl = entry.txtEl;

       // Size relative to cell so it never dwarfs the board
       const size = Math.round(Math.min(200, Math.max(96, CELL * 1.45)));
       fx.style.width  = size + "px";
       fx.style.height = size + "px";

       const showScore = Number.isFinite(score) && score > 0;
       if(showScore){
         const fz = Math.round(Math.min(34, Math.max(18, size * 0.22)));
         txtEl.style.fontSize = fz + "px";
         txtEl.style.maxWidth = (size * 0.92) + "px";
         txtEl.textContent = fmt(score);
         txtEl.style.display = "block";
       }else{
         txtEl.style.display = "none";
       }
       showComboSprite(r, c);

       const {x,y} = tileCenter(r,c);
       fx.style.left = x + "px";
       fx.style.top  = y + "px";

       fx.classList.remove("show");
       void fx.offsetWidth;
       fx.classList.add("show");

       clearTimeout(entry.timer);
       entry.timer = setTimeout(()=>{
         fx.classList.remove("show");
       }, 950);
    }

    function showDeathAnim(r, c){
       if(!ui._deathFx){
         const fx = document.createElement("div");
         fx.className = "deathFx";
         ui.fx.appendChild(fx);
         ui._deathFx = fx;
         ui._deathFxTimer = 0;
       }
       const fx = ui._deathFx;

       const size = Math.round(Math.min(220, Math.max(120, CELL * 1.85)));
       fx.style.width  = size + "px";
       fx.style.height = size + "px";

       const gifUrl = IMG.deathGif + "?t=" + Date.now();
       fx.style.backgroundImage = "url('" + gifUrl + "')";

       const {x,y} = tileCenter(r,c);
       fx.style.left = x + "px";
       fx.style.top  = y + "px";

       fx.classList.add("show");
       clearTimeout(ui._deathFxTimer);
       ui._deathFxTimer = setTimeout(()=>{
         fx.classList.remove("show");
       }, 1100);
    }


    /**********************
     * Responsive sizing
     **********************/
        function computeCell(){
          const wrap = document.getElementById("boardWrap");
          if(!wrap) return 42;
          const rect = wrap.getBoundingClientRect();
          const wrapW = wrap.clientWidth;
          const viewportH = getViewportHeight();
          const viewportW = getViewportWidth();
    
          const isFs = document.body.classList.contains("fs");
          const isMax = document.body.classList.contains("maximized");
          const isMobile = window.innerWidth < 640;
    
          // Margins/Padding - tighter for mobile
          const pad = currentPad();
          const padW = (isFs||isMax) ? 2 : (isMobile ? 4 : 16);
          
          // Vertical calculation
          const topOffset = isFs ? 0 : Math.max(0, rect.top);
          const bottomReserve = isFs ? 0 : (isMobile ? 8 : 24);
          const availH = Math.max(200, viewportH - topOffset - bottomReserve);
    
          const usableW = Math.max(280, Math.min(wrapW, viewportW) - padW);
    
          const cellW = Math.floor((usableW - (cols-1)*GAP - pad*2) / cols);
          const cellH = Math.floor((availH - (rows-1)*GAP - pad*2) / rows);
    
          const maxCell = (isFs||isMax) ? 160 : 120;
          const minCell = 16;
          
          return clamp(Math.min(cellW, cellH), minCell, maxCell);
        }
    
        function setTileXY(el, r, c){
          const pad = currentPad();
          const x = c*(CELL+GAP) + pad;
          const y = r*(CELL+GAP) + pad;
          el.style.setProperty("--x", x+"px");
          el.style.setProperty("--y", y+"px");
        }
    
            function layoutBoard(forceShift=false){
              const viewportW = getViewportWidth();
              const viewportH = getViewportHeight();
              const isMobile = viewportW < 640;
              const narrow = viewportW < 400;
              
              // Global Gap: -2px for a compact look on all boards
              GAP = -2;

              PAD = narrow ? 4 : (isMobile ? 8 : 14);          
          CELL = computeCell();
          const pad = currentPad();
          document.documentElement.style.setProperty("--cell", CELL+"px");
          document.documentElement.style.setProperty("--gap", GAP+"px");
          document.documentElement.style.setProperty("--pad", pad+"px");
          document.documentElement.style.setProperty("--cols", cols);
          document.documentElement.style.setProperty("--rows", rows);
    
          const w = pad*2 + cols*CELL + (cols-1)*GAP;
          const h = pad*2 + rows*CELL + (rows-1)*GAP;
          ui.board.style.width = w+"px";
          ui.board.style.height = h+"px";
    
          // KOALA_LAYOUT_SYNC_FSBG: Fullscreen/Maximize BG exakt an Board-Größe anpassen
          try{
            if(ui && ui.fsBg){
              ui.fsBg.style.width = w+"px";
              ui.fsBg.style.height = h+"px";
            }
          }catch(e){}
      for(const [id, el] of tileEls){
              const tile = findTileById(id);
              if(!tile) continue;
              setTileXY(el, tile.r, tile.c);
            }
    
            updateBoardShift(forceShift);
          syncLbHeight();
          
          // Remove any leftover tile DOM nodes that are no longer in the grid
          pruneOrphanTileEls();
      }

      function updateBoardShift(force=false){
      const board = document.getElementById("board");
      if(!board) return;
      if(!document.body.classList.contains("fs")){
        document.documentElement.style.setProperty("--board-shift-x", "0px");
        document.documentElement.style.setProperty("--board-shift-y", "0px");
        return;
      }
      if(!force) return;
      const rect = board.getBoundingClientRect();
      const vp = window.visualViewport;
      const vpLeft = vp ? vp.offsetLeft : 0;
      const vpTop = vp ? vp.offsetTop : 0;
      const vpW = getViewportWidth();
      const vpH = getViewportHeight();
      const left = rect.left - vpLeft;
      const right = (vpLeft + vpW) - rect.right;
      const top = rect.top - vpTop;
      const bottom = (vpTop + vpH) - rect.bottom;
        let sx = 0;
        let sy = 0;
        const hGap = Math.abs(left - right);
        if(hGap > 40){
          const delta = Math.min(hGap / 2, 90);
          sx = left > right ? -delta : delta;
        }
        const vGap = Math.abs(top - bottom);
        if(vGap > 40){
          const delta = Math.min(vGap / 2, 90);
          sy = top > bottom ? -delta : delta;
        }
        document.documentElement.style.setProperty("--board-shift-x", Math.round(sx) + "px");
        document.documentElement.style.setProperty("--board-shift-y", Math.round(sy) + "px");
      }

    function relayoutAll(forceBg=false, forceShift=false){
      layoutBoard(forceShift);
      syncBgHeight();
      buildGlobalBg(forceBg);
      buildFsBg(forceBg);
    }

    let ro=null;
    let resizeTimer;
    function attachResize(){
      const handler = () => {
        setAppHeight();
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{
           layoutBoard(true);
           syncBgHeight();
           buildGlobalBg();
           buildFsBg();
        }, 150);
      };
      setAppHeight();

      try{
        ro = new ResizeObserver(handler);
        ro.observe(document.getElementById("boardWrap"));
      }catch(e){
        window.addEventListener("resize", handler);
      }
      window.addEventListener("resize", handler);
      if(window.visualViewport){
        window.visualViewport.addEventListener("resize", handler);
        window.visualViewport.addEventListener("scroll", handler);
      }
      document.getElementById("page").addEventListener("scroll", syncBgHeight, {passive:true});
    }

    function syncBgHeight(){
      const page = document.getElementById("page");
      const h = Math.max(page.scrollHeight, getViewportHeight());
      document.getElementById("scrollBg").style.height = h + "px";
      document.getElementById("globalBg").style.height = h + "px";
    }

    /**********************
     * Tile DOM
     **********************/
    function createTileEl(tile, spawnDrop=false){
      const el = document.createElement("div");
      el.className="tile";
      el.dataset.id = tile.id;

      const {baseKey, variant} = parseTypeId(tile.type);
      el.dataset.base = baseKey;
      el.dataset.variant = variant;
      discoverLuvvie(baseKey);
      const base = getBase(baseKey);
      const spec = getSpecial(baseKey);
      const meta = base || spec;

      // palettes (neutral): Background is NOT tied to the character (less confusion, more readable)
      const pal = paletteForTile(tile);
      el.style.setProperty("--p1", pal[0]);
      el.style.setProperty("--p2", pal[1]);

      const plate = document.createElement("div");
      plate.className="plate";
      // Board tile background (jelly image only)
      const bg = tileBgFor(tile);
      if(bg){
        plate.style.setProperty("--bg-img", `url('${bg}')`);
      }


      // Powerups + ??? + Lovelie: animated background
      if(isPowerupKey(baseKey) || baseKey==="lovelie" || baseKey==="myst" || baseKey==="cit" || baseKey==="worm" || baseKey==="koala" || baseKey==="mellowzilla" || baseKey==="koalazilla"){
        el.classList.add("powerAnim");
      }

      // Big mellow size
      if(tile.big){
        el.classList.add("bigMellow");
      }

      if(baseKey === "myst"){
  const qm = document.createElement("div");
  qm.className="qmark";
  qm.textContent = "?";
  plate.appendChild(qm);
}else{
  const img = document.createElement("img");

  // Resolve image source (bases, specials, bosses)
  let src = meta?.img || "";
  if(baseKey==="mellowlord") src = IMG.mellowlord;
  
  if(baseKey==="worm") src = IMG.sourwurm[tile.wormIdx||0] || IMG.sourwurm[0];
  if(baseKey==="mellowzilla") src = IMG.mellowzilla[tile.animFrame||0] || IMG.mellowzilla[0];
  if(baseKey==="koalazilla") src = IMG.koalazilla[tile.animFrame||0] || IMG.koalazilla[0] || IMG.koala;

  img.src = src;
  img.alt = meta?.name || baseKey;

  // Fallbacks (avoid broken icons)
  img.addEventListener("error", ()=>{
    if(baseKey==="koalazilla" && img.src !== IMG.koala) img.src = IMG.koala;
  }, {once:true});

  plate.appendChild(img);

  // Variant badge so A/B are clearly visible (prevents "combo feels broken")
  if(base && variant==="B"){
    const vb = document.createElement("div");
    vb.className = "variantBadge";
    vb.textContent = "B";
    plate.appendChild(vb);
  }
}

      el.appendChild(plate);
      if(tile.big && (baseKey==="mellowlord" || baseKey==="mellowzilla" || baseKey==="koalazilla")){
        const hp = document.createElement("div");
        hp.className="hp";
        hp.textContent = tile.hp;
        el.appendChild(hp);
      }
setTileXY(el, tile.r, tile.c);
      syncTileFlags(el, tile);

      if(spawnDrop){
        const fallDist = (tile.r + 3) * (CELL+GAP);
        plate.style.setProperty("--oy", `-${fallDist}px`);
        plate.style.setProperty("--op", "0");

        requestAnimationFrame(()=>{
          plate.style.setProperty("--oy", "0px");
          plate.style.setProperty("--op", "1");
        });

        // Use timeout instead of transitionend for reliability
        setTimeout(()=>{
          el.classList.add("land");
          const center = tileCenter(tile.r, tile.c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>el.classList.remove("land"), 560);
        }, 300);
      }

      el.addEventListener("pointerdown", onPointerDown);
        el.addEventListener("pointerup", onPointerUp);
  return el;
}

// Keep visuals in sync when a tile changes type without recreating the element
function refreshTileEl(tile){
  const el = tileEls.get(tile.id);
  if(!el) return;

  const {baseKey, variant} = parseTypeId(tile.type);
  el.dataset.base = baseKey;
  el.dataset.variant = variant;
  discoverLuvvie(baseKey);

  const base = getBase(baseKey);
  const spec = getSpecial(baseKey);
  const meta = base || spec;

  // palettes (character/complement based)
  const pal = paletteForTile(tile);
  el.style.setProperty("--p1", pal[0]);
  el.style.setProperty("--p2", pal[1]);

  // image
  const plate = el.querySelector(".plate");
  const img = el.querySelector("img");
  if(plate){
    const bg = tileBgFor(tile);
    if(bg){
      plate.style.setProperty("--bg-img", `url('${bg}')`);
    }
  }
  if(img){
    let src = meta?.img || "";
    if(baseKey==="mellowlord") src = IMG.mellowlord;
    
    if(baseKey==="worm") src = IMG.sourwurm[tile.wormIdx||0] || IMG.sourwurm[0];
    if(baseKey==="mellowzilla") src = IMG.mellowzilla[tile.animFrame||0] || IMG.mellowzilla[0];
    if(baseKey==="koalazilla") src = IMG.koalazilla[tile.animFrame||0] || IMG.koalazilla[0] || IMG.koala;

    img.src = src;
    img.alt = meta?.name || baseKey;
  }

  // variant badge
  const oldBadge = el.querySelector(".variantBadge");
    if(oldBadge) oldBadge.remove();
    if(plate && base && variant==="B"){
      const vb = document.createElement("div");
      vb.className="variantBadge";
      vb.textContent="B";
      plate.appendChild(vb);
    }
    syncTileFlags(el, tile);
}

function updateMellowHp(tile){
      const el = tileEls.get(tile.id);
      if(!el) return;
      const hp = el.querySelector(".hp");
      if(hp) hp.textContent = tile.hp;
    }

    function findTileById(id){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t = grid[r][c];
          if(t && t.id===id) return t;
        }
      }
      return null;
    }

    /**********************
     * Random tile generation
     **********************/
    // Balancing: Limit active Luvvies on small boards
    function getActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);

      // Limit count based on Difficulty/Size to ensure matches are possible
      // Easy (10x10): Max 7-8 colors?
      // Shock (8x8): Max 5-6 colors.
      let maxColors = 6;
      if(diff.key === "easy") maxColors = 7;
      if(diff.key === "normal") maxColors = 6;
      if(diff.key === "hard") maxColors = 6;
      if(diff.key === "shock") maxColors = 5; // 8x8 with too many colors is impossible

      // If pool is larger, slice it?
      // But we want consistent characters.
      // We can consistently slice based on the current level/seed, or just take the first N.
      // BASES is sorted by appearance? Fledernuss is minLevel 10.
      // We should prioritize "basic" ones + 1-2 advanced.
      if(pool.length > maxColors){
         // Always keep basics (sweety, sleepy, normal, cry, joyce, smokey)
         // Rotate the others?
         // For stability, let's just pick the first 'maxColors' valid ones
         // but Fledernuss/Simba might be cut off.
         // Better: Pick random subset per Level? No, confusing.
         // Pick subset per Game? Yes.
         // We can store 'activeSet' in a variable when game starts.
      }
      return pool;
    }

    let gameActivePool = []; // Set on newGame

    function randNormalType(){
      // Use active subset
      const pool = gameActivePool.length ? gameActivePool : BASES;
      const weights = pool.map(b=>{
        const w = (b.key==="joyce"||b.key==="smokey") ? 9 : (b.key==="donut") ? 10 : 12;
        return {b, w};
      });
      const totalW = weights.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*totalW;
      let pick = weights[0].b;
      for(const x of weights){
        r -= x.w;
        if(r<=0){ pick = x.b; break; }
      }

      const variants = Array.from(unlocked[pick.key]);
      let v="A";
      if(variants.includes("B")){
        v = (Math.random() < 0.28) ? "B" : "A";
      }
      return typeId(pick.key, v);
    }

    function makeId(){
      return (crypto?.randomUUID?.() || (Math.random().toString(16).slice(2)+Date.now().toString(16)));
    }

    function makeTile(r,c,type){
      const id = makeId();
      const t = { id, r, c, type, hp:0, big:false, animFrame:0 };
      const {baseKey} = parseTypeId(type);
      if(baseKey === "worm") t.wormIdx = Math.floor(Math.random()*3);
      return t;
    }

    function wouldCreateMatch(r,c,type){
      const k = parseTypeId(type).baseKey;
      if(c>=2){
        const a=grid[r][c-1], b=grid[r][c-2];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      if(r>=2){
        const a=grid[r-1][c], b=grid[r-2][c];
        if(a && b && parseTypeId(a.type).baseKey===k && parseTypeId(b.type).baseKey===k && isMatchable(a) && isMatchable(b)) return true;
      }
      return false;
    }

    /**********************
     * Background (no bubbles) + subtle twinkles
     **********************/
    let globalBgSize = {w:0, h:0};
    let fsBgSize = {w:0, h:0};

    let bgSpeechTimer = null;
    let bgCycleTimer = null;
    function buildGlobalBg(force=false){
      syncBgHeight();
      const cont = document.getElementById("globalBg");

      const page = document.getElementById("page");
      const W = page.clientWidth;
      const H = Math.max(page.scrollHeight, getViewportHeight());
      if(!force && cont.children.length){
        if(Math.abs(W - globalBgSize.w) < 40 && Math.abs(H - globalBgSize.h) < 40) return;
      }
      globalBgSize = {w:W, h:H};
      cont.innerHTML = "";
      if(bgSpeechTimer){ clearInterval(bgSpeechTimer); bgSpeechTimer = null; }
      const isRogue = ROGUE_MODE;
      const source = isRogue ? ROGUE_ENEMIES.slice() : [...BASES].sort((a,b)=>a.key.localeCompare(b.key));
      const bgChars = isRogue ? source.sort(()=>Math.random()-0.5).slice(0,12) : source.slice(0,12);
      const slots = [
        {x:.05,y:.06},{x:.36,y:.08},{x:.68,y:.05},
        {x:.10,y:.34},{x:.42,y:.30},{x:.72,y:.32},
        {x:.06,y:.62},{x:.38,y:.60},{x:.70,y:.64},
        {x:.14,y:.82},{x:.52,y:.82},{x:.82,y:.80}
      ];
      const stable01 = (seed)=>((hashStr(seed) % 10000) / 10000);
      bgChars.forEach((b, idx)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.src = isRogue ? b.img : (IMG_LARGE[b.key] || b.img);
        img.alt = b.name || "";

        const seed = (b.key || b.id || b.name || "bg") + ":" + idx + ":" + Math.round(W) + ":" + Math.round(H);
        const size = Math.min(440, Math.max(80, W * 0.24));
        const slot = slots[idx % slots.length];
        const x = slot.x * (W - size);
        const y = slot.y * (Math.max(520,H) - size);

        wrap.style.left = Math.max(0, x)+"px";
        wrap.style.top  = y+"px";
        wrap.style.animationDuration = (16 + stable01(seed + ":d")*10)+"s";
        wrap.style.width = size+"px";

        wrap.dataset.base = isRogue ? (b.id || b.name || "") : b.key;
        wrap.appendChild(img);
        cont.appendChild(wrap);

        // subtle twinkles around them (rare)
        const tick = ()=>{
          if(stable01(seed + ":t" + Date.now()) < 0.18){
            const rect = wrap.getBoundingClientRect();
            const px = rect.left + rect.width * (0.2 + Math.random()*0.6);
            const py = rect.top  + rect.height* (0.2 + Math.random()*0.6);
            const t = document.createElement("div");
            t.className="twinkle";
            t.style.left = px + "px";
            t.style.top  = (py + window.scrollY) + "px";
            cont.appendChild(t);
            setTimeout(()=>t.remove(), 1300);
          }
        };
        setInterval(tick, 2400 + stable01(seed + ":i")*1600);
      });

      // Speech bubbles (one every 20s)
      bgSpeechTimer = setInterval(()=>{
        const nodes = Array.from(cont.querySelectorAll(".bgLuv"));
        if(!nodes.length) return;
        const pick = nodes[Math.floor(Math.random()*nodes.length)];
        let text = "";
        if(isRogue){
          const idx = Math.floor(Math.random() * ROGUE_BG_LINES.length);
          text = ROGUE_BG_LINES[idx] || "...";
        } else {
          const key = pick.dataset.base || "";
          const base = getBase(key);
          const lines = base?.lines?.[diff.key] || base?.lines?.easy || [];
          const baseStory = base?.story || "";
          if(lines.length >= 2){
            const a = lines[Math.floor(Math.random()*lines.length)];
            let b = lines[Math.floor(Math.random()*lines.length)];
            if(b === a) b = lines[(lines.indexOf(a)+1) % lines.length] || a;
            text = baseStory ? `${baseStory} - ${a} - ${b}` : `${a} - ${b}`;
          }else if(lines.length === 1){
            text = baseStory ? `${baseStory} ${lines[0]}` : lines[0];
          }else{
            text = baseStory || "...";
          }
        }

        const bubble = document.createElement("div");
        bubble.className = "bgBubble";
        bubble.textContent = text;
        pick.appendChild(bubble);
        setTimeout(()=>{ bubble.remove(); }, 5200);
      }, 20000);
    }

    function buildFsBg(force=false){
      const fs = document.getElementById("fsBg");
      if(!document.body.classList.contains("fs") && !document.body.classList.contains("maximized")) return;
      const W = fs.clientWidth || window.innerWidth;
      const H = fs.clientHeight || getViewportHeight();
      if(!force && fs.children.length){
        if(Math.abs(W - fsBgSize.w) < 40 && Math.abs(H - fsBgSize.h) < 40) return;
      }
      fsBgSize = {w:W, h:H};
      fs.innerHTML = "";
      const isRogue = ROGUE_MODE;
      const source = isRogue ? ROGUE_ENEMIES.slice() : [...BASES].sort((a,b)=>a.key.localeCompare(b.key));
      const pick = isRogue ? source.sort(()=>Math.random()-0.5).slice(0,10) : source.slice(0,10);
      const slots = [
        {x:.05,y:.08},{x:.38,y:.08},{x:.70,y:.08},
        {x:.08,y:.38},{x:.42,y:.34},{x:.72,y:.36},
        {x:.06,y:.66},{x:.38,y:.64},{x:.70,y:.66},
        {x:.14,y:.86}
      ];
      const stable01 = (seed)=>((hashStr(seed) % 10000) / 10000);
      pick.forEach((b, idx)=>{
        const wrap = document.createElement("div");
        wrap.className="bgLuv";
        wrap.style.opacity = ".78";
        const size = Math.min(440, Math.max(80, W * 0.26));
        wrap.style.width = size+"px";
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.src = isRogue ? b.img : (IMG_LARGE[b.key] || b.img);
        img.alt = b.name || "";

        const seed = (b.key || b.id || b.name || "bg") + ":" + idx + ":" + Math.round(W) + ":" + Math.round(H);
        const slot = slots[idx % slots.length];
        const x = slot.x * (W - size);
        const y = slot.y * (H - size);
        wrap.style.left = Math.max(0,x)+"px";
        wrap.style.top  = Math.max(0,y)+"px";
        wrap.style.animationDuration = (16 + stable01(seed + ":d")*10)+"s";

        wrap.appendChild(img);
        fs.appendChild(wrap);
      });
    }

    function scheduleBgCycle(){
      if(bgCycleTimer) clearInterval(bgCycleTimer);
      bgCycleTimer = setInterval(()=>{
        buildGlobalBg(true);
        buildFsBg(true);
      }, 5 * 60 * 1000);
    }

    /**********************
     * Board init
     **********************/
    function initBoard(){
      rows = diff.rows;
      cols = diff.cols;

      try{ renderCombos(); }catch(e){}

      grid = Array.from({length:rows}, (_,r)=>Array.from({length:cols}, (_,c)=>null));
      tileEls.clear();
      ui.board.innerHTML="";
      ui.fx.innerHTML="";
      bigMellows.clear();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let t;
          let tries=0;
          do{
            t = randNormalType();
            tries++;
          }while(wouldCreateMatch(r,c,t) && tries<40);

          const tile = makeTile(r,c,t);
          grid[r][c]=tile;
        }
      }

      spawnMellow();
      spawnMellowZilla();
      maybeSpawnLovelie();
      layoutBoard();

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const tile = grid[r][c];
          const el = createTileEl(tile, false);
          tileEls.set(tile.id, el);
          ui.board.appendChild(el);
        }
      }

      buildGlobalBg();
      buildFsBg();
      scheduleBgCycle();

      setTimeout(()=>resolveAll(true), 50);
    }

    /**********************
     * Mellow spawn: ab Level 3, dann alle 4 Level (3,7,11...) / kein HP
     **********************/
    function shouldSpawnMellowThisLevel(){
      if(level < 3) return false;
      return level === 3 || ((level - 3) % 4 === 0);
    }

    function spawnMellow(){
      if(!shouldSpawnMellowThisLevel()) return;
      const count = clamp(1 + Math.floor(level/4), 1, Math.floor(rows*cols/10));
      for(let i=0;i<count;i++){
        for(let tries=0;tries<260;tries++){
          const r=Math.floor(Math.random()*rows);
          const c=Math.floor(Math.random()*cols);
          const cur=grid[r][c];
          if(!cur) continue;
          if(isBlocker(cur)) continue;

          const bk = parseTypeId(cur.type).baseKey;
          if(getSpecial(bk)) continue;

          const m = makeTile(r,c,typeId("mellow","A"));
          m.hp = 0; // Small mellow has no HP (invincible)
          const oldEl = tileEls.get(cur.id);
          if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }

          grid[r][c]=m;
          const el = createTileEl(m, false);
          el.classList.add("spawnGlow");
          tileEls.set(m.id, el);
          ui.board.appendChild(el);
          const center = tileCenter(r,c);
          burstFx(center.x, center.y, 10);
          break;
        }
      }
    }

    function maybeSpawnLovelie(){
      if(Math.random() > diff.lovelieChance) return;
      for(let tries=0;tries<220;tries++){
        const r=Math.floor(Math.random()*rows);
        const c=Math.floor(Math.random()*cols);
        const cur=grid[r][c];
        if(!cur) continue;
        if(isBlocker(cur)) continue;
        const bk = parseTypeId(cur.type).baseKey;
        if(getSpecial(bk)) continue;

        const lov = makeTile(r,c,typeId("lovelie","P"));
        const oldEl = tileEls.get(cur.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(cur.id); }
        grid[r][c]=lov;

        const el = createTileEl(lov, false);
        el.classList.add("spawnGlow");
        tileEls.set(lov.id, el);
        ui.board.appendChild(el);
        toast("Lovelie erscheint! 💖","Ultra selten ✨", 3200);
        break;
      }
    }

    /**********************
     * Mystery reveal (??? click -> random)
     **********************/
    function pickMyst(){
      const total = MYST_POOL.reduce((a,x)=>a+x.w,0);
      let r = Math.random()*total;
      for(const x of MYST_POOL){
        r -= x.w;
        if(r<=0) return x.key;
      }
      return "worm";
    }

    function revealMyst(tile){
      if(busy) return;
      busy = true;
      const el = tileEls.get(tile.id);
      if(el) el.classList.add("puff");

      const {x,y} = tileCenter(tile.r, tile.c);
      burstFx(x,y, 14);

      setTimeout(()=>{
        const pick = pickMyst();

        // replace old tile
        const oldEl = tileEls.get(tile.id);
        if(oldEl){ oldEl.remove(); tileEls.delete(tile.id); }

        let newType = typeId("worm","P");
        if(pick==="cit") newType = typeId("cit","P");
        if(pick==="koala") newType = typeId("koala","P");
        if(pick==="lovelie") newType = typeId("lovelie","P");
        if(pick==="mellow") newType = typeId("mellow","A");

        const t2 = makeTile(tile.r, tile.c, newType);
        if(pick==="mellow") t2.hp = 3;

        grid[tile.r][tile.c] = t2;

        const el2 = createTileEl(t2, false);
        el2.classList.add("spawnGlow");
        tileEls.set(t2.id, el2);
        ui.board.appendChild(el2);

        toast("??? Reveal ✨", pick==="worm" ? "Sourworm!" :
                            pick==="cit" ? "Citrussy!" :
                            pick==="mellow" ? "Mellow Block!" :
                            pick==="koala" ? "Koala!" : "Lovelie 💖", 2800);
        busy = false;
        updateUI();
      }, 360);
    }

    function collectBonus(tile){
       if(busy) return;
       busy=true;
       toast("Bonus! 💖", "Lovelie collected!", 2000);
       clearCells([{r:tile.r, c:tile.c}]);
       totalScore += 5000;
       updateUI();
       setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 300);
    }

    /**********************
     * Pointer & Drag System (1:1 Drag Fix)
     **********************/
    let dragStart = {x:0, y:0};
    let currentDrag = null;
    let busyStart = 0; // Watchdog timestamp

    function onPointerDown(e){
      if(!e.isPrimary && e.isPrimary!==undefined) return;
      e.preventDefault(); 
      // Watchdog: If busy for too long (>2.5s) without active resolution, force unlock
      if(busy){
         if(!busyStart) busyStart = Date.now();
         if(Date.now() - busyStart > 2500){
             console.warn("Busy state stuck, auto-recovering...");
             busy = false;
             busyStart = 0;
             document.querySelectorAll('.tile.dragging').forEach(el=>el.classList.remove('dragging'));
             toast("Auto-Fix 🛠️", "Input block gelöst.", 1500);
         } else {
             return;
         }
      }
      busyStart = Date.now();

      const tEl = e.currentTarget;
      const id = tEl.dataset.id;
      const tile = findTileById(id);
      if(!tile) return;

      if(currentDrag) return;

      clearHints();
      try{ tEl.setPointerCapture(e.pointerId); }catch(ex){}

      const rect = tEl.getBoundingClientRect();
      const boardRect = ui.board.getBoundingClientRect();

      // We calculate current position based on grid logic to ensure we start from "true" position
      // Visual drag uses CSS translate.
      // 1:1 Dragging means: Mouse Delta = Tile Delta.

      // Store initial mouse pos
      dragStart = {
        startX: e.clientX,
        startY: e.clientY,
        // Store initial CSS transform values
        initialLeft: tile.c * (CELL+GAP) + currentPad(),
        initialTop:  tile.r * (CELL+GAP) + currentPad(),
      };

      currentDrag = {
        id: id,
        el: tEl,
        r: tile.r,
        c: tile.c,
        moved: false,
        axis: null
      };

      tEl.classList.add("dragging");
    }

    function onPointerMove(e){
      if(!currentDrag) return;
      e.preventDefault();
      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      // Dynamic Axis: Check which direction is dominant right now
      // Allow switching direction until moved significantly (> 40% of cell)
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      
      let axis = "x";
      if(absY > absX) axis = "y";
      
      // Update current axis dynamically
      currentDrag.axis = axis;
      currentDrag.moved = true;

      const maxShift = (CELL + GAP) * 0.48;
      let shiftX = 0, shiftY = 0;

      if(axis === "x"){
         shiftX = Math.max(-maxShift, Math.min(maxShift, dx));
      } else {
         shiftY = Math.max(-maxShift, Math.min(maxShift, dy));
      }

      const newX = dragStart.initialLeft + shiftX;
      const newY = dragStart.initialTop + shiftY;

      currentDrag.el.style.setProperty('--x', newX+"px");
      currentDrag.el.style.setProperty('--y', newY+"px");
    }

    function onPointerUp(e){
      if(!currentDrag) return;
      const {id, el, r, c, moved, axis} = currentDrag;
      const tile = findTileById(id);
      currentDrag = null;
      el.classList.remove("dragging");
      try{ el.releasePointerCapture(e.pointerId); }catch(ex){}

      // Revert visual to grid slot immediately (animation happens if swap valid)
      setTileXY(el, r, c);

      if(!moved){
         if(tile && tile.type.startsWith("myst")) revealMyst(tile);
         if(tile && parseTypeId(tile.type).baseKey === "lovelie") collectBonus(tile);
         return;
      }

      const dx = e.clientX - dragStart.startX;
      const dy = e.clientY - dragStart.startY;

      // Determine drag direction based on movement
      // Use threshold relative to cell size for better feel?
      // User requested 1:1 follows.
      // Simple threshold 20px
      if(Math.hypot(dx,dy) < 15) return;

      // Direction
      const finalAxis = axis || (Math.abs(dx) > Math.abs(dy) ? "x" : "y");
      let dirStr = "";
      if(finalAxis === "x") dirStr = dx > 0 ? "R" : "L";
      else dirStr = dy > 0 ? "D" : "U";

      const dr = (dirStr==="D")?1:(dirStr==="U")?-1:0;
      const dc = (dirStr==="R")?1:(dirStr==="L")?-1:0;

      const r2 = r + dr;
      const c2 = c + dc;

      if(!inBounds(r2,c2)) return;

      // Determine Lock/Direction Logic
      const t1 = tile;
      const t2 = grid[r2][c2];

      if(!t1 || !t2) return;
      if(isBlocker(t1) || isBlocker(t2)) return;

      const k1 = parseTypeId(t1.type).baseKey;
      const k2 = parseTypeId(t2.type).baseKey;
      const p1 = isPowerupKey(k1);
      const p2 = isPowerupKey(k2);

      // Special: Lovelie + Lovelie -> Harmony
      if(k1==="lovelie" && k2==="lovelie"){
         trySwap(r, c, r2, c2);
         return;
      }

      // Special: Powerup + SuperNuss -> Super Combo
      const sn1 = k1==="supernuss";
      const sn2 = k2==="supernuss";
      if((p1 && sn2) || (p2 && sn1)){
         trySwap(r, c, r2, c2);
         return;
      }

      // Bonus: Lovelie interaction logic
      // Priority 1: If mixing with Powerup -> Swap/Combo
      if((k1==="lovelie" && p2) || (k2==="lovelie" && p1)){
         trySwap(r, c, r2, c2);
         return;
      }
      // Priority 2: Just clicking/swapping with normal -> Collect Bonus
      if(k1 === "lovelie"){ collectBonus(t1); return; }
      if(k2 === "lovelie"){ collectBonus(t2); return; }

      // Case 1: Powerup + Powerup -> FORCE SWAP (Combo)
      if(p1 && p2){
         trySwap(r, c, r2, c2);
         return;
      }

      // Case 2: Dragging FROM Powerup (Powerup + Normal) -> LOCK & ACTIVATE
      if(p1 && !p2){
       try{
         // Activate Powerup t1 in direction (dr,dc)
         toast("Powerup Activate! 💥", "Direction: "+dirStr, 1500);
         busy = true; // Lock input immediately

         if(k1 === "koala"){
            koalaMagicOn(k2);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            combo += 2;
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "worm"){
            if(dr !== 0) clearCol(c);
            else clearRow(r);
            clearCells([{r:t1.r,c:t1.c}]);
            spendMoves(1);
            combo += 2;
            setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
            return;
         }

         if(k1 === "cit"){
             citBlast(r,c,3);
             clearCells([{r:t1.r,c:t1.c}]);
             spendMoves(1);
             combo += 2;
             setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 320);
             return;
         }
         busy = false; // Reset if fallthrough
       }catch(e){
         console.error(e);
         busy=false; // Safety reset
       }
         return;
      }

      // Case 3: Dragging Normal -> Powerup
      if(!p1 && p2){
         // "Nie Powerups verschieben" -> Blocked.
         toast("Blockiert!", "Powerups sind fest verankert.", 1000);
         return;
      }

      // Case 4: Normal Swap
      trySwap(r, c, r2, c2);
    }

    ui.board.removeEventListener("pointermove", ()=>{});
    ui.board.addEventListener("pointermove", onPointerMove);
    ui.board.addEventListener("pointerup", onPointerUp);
    ui.board.addEventListener("pointercancel", onPointerUp);

    /**********************
     * Gameplay core (Swap/Resolve)
     **********************/

    function doSwap(r1,c1,r2,c2){
      const a = grid[r1][c1], b = grid[r2][c2];
      if(!a || !b) return;
      grid[r1][c1]=b; grid[r2][c2]=a;
      a.r=r2; a.c=c2;
      b.r=r1; b.c=c1;

      const elA = tileEls.get(a.id);
      const elB = tileEls.get(b.id);
      if(elA) setTileXY(elA,a.r,a.c);
      if(elB) setTileXY(elB,b.r,b.c);
    }

    function spendMoves(n){
      moves = Math.max(0, moves - n);
      combo = ROGUE_MODE ? 1 : 0; // Reset combo on each paid/consumed move
      if(ROGUE_MODE){
        ROGUE.run.turn += n;
        applyRogueTurnEffects(n);
        applyEnemyAttack(n);
        if(moves === 0 && ROGUE.run.enemyHp > 0) ROGUE.run.loseReady = true;
        updateRogueUI();
        return;
      }
      if(moves===0){
        setTimeout(()=>gameOver(), 350);
      }
    }

    function comboMatchKind(tiles){
      if(!tiles || tiles.length < 4) return null;
      if(tiles.some(t => !t || isBlocker(t))) return null;
      const keys = tiles.map(t => parseTypeId(t.type).baseKey);
      const count = (k)=>keys.filter(x=>x===k).length;
      const len = tiles.length;

      if(len === 4){
        if(count("sleepy")===3 && count("mond")===1){ unlockCombo("moonshuffle"); return "moonshuffle"; }
        if(count("grumpy")===3 && count("happy")===1){ unlockCombo("therapy"); return "therapy"; }
        if(count("donut")===3 && count("sweety")===1){ unlockCombo("sprinkle"); return "sprinkle"; }
        if(count("donut")===3 && count("happy")===1){ unlockCombo("sugar"); return "sugar"; }
        if(count("smokey")===3 && count("joyce")===1){ unlockCombo("buddies"); return "buddies"; }
        if(count("joyce")===3 && count("smokey")===1){ unlockCombo("buddies"); return "buddies"; }
        if(count("smokey")===3 && count("simba")===1){ unlockCombo("bestbuddies"); return "bestbuddies"; }
        if(count("simba")===3 && count("smokey")===1){ unlockCombo("bestbuddies"); return "bestbuddies"; }
        if(count("giraffie")===3 && count("koala")===1){ unlockCombo("safaritour"); return "safaritour"; }
        if(count("koala")===3 && count("giraffie")===1){ unlockCombo("safaritour"); return "safaritour"; }
        if(count("sweety")===2 && count("cry")===2){ unlockCombo("bittersweet"); return "bittersweet"; }
        if(count("sweety")===3 && count("sleepy")===1){ unlockCombo("sweetdreams"); return "sweetdreams"; }
        if(count("sleepy")===3 && count("sweety")===1){ unlockCombo("sweetdreams"); return "sweetdreams"; }
        return null;
      }

      if(len === 5){
        if(count("sleepy")===4 && count("mond")===1){ unlockCombo("moonshuffle"); return "moonshuffle"; }
        if(count("grumpy")===4 && count("happy")===1){ unlockCombo("therapy"); return "therapy"; }
        if(count("donut")===4 && count("sweety")===1){ unlockCombo("sprinkle"); return "sprinkle"; }
        if(count("donut")===4 && count("happy")===1){ unlockCombo("sugar"); return "sugar"; }
        if(count("smokey")===4 && count("joyce")===1){ unlockCombo("buddies"); return "buddies"; }
        if(count("joyce")===4 && count("smokey")===1){ unlockCombo("buddies"); return "buddies"; }
        if(count("smokey")===4 && count("simba")===1){ unlockCombo("bestbuddies"); return "bestbuddies"; }
        if(count("simba")===4 && count("smokey")===1){ unlockCombo("bestbuddies"); return "bestbuddies"; }
        if(count("giraffie")===4 && count("koala")===1){ unlockCombo("safaritour"); return "safaritour"; }
        if(count("koala")===4 && count("giraffie")===1){ unlockCombo("safaritour"); return "safaritour"; }
        if(count("sweety")===3 && count("cry")===2){ unlockCombo("bittersweet"); return "bittersweet"; }
        if(count("sweety")===4 && count("sleepy")===1){ unlockCombo("sweetdreams"); return "sweetdreams"; }
        if(count("sleepy")===4 && count("sweety")===1){ unlockCombo("sweetdreams"); return "sweetdreams"; }
      }

      return null;
    }

    function findSpecialQuads(){
      if(!isGridReady()) return [];
      const specialLen = ROGUE_MODE ? 5 : 4;
      const found = [];
      // Horizontal combos
      for(let r=0;r<rows;r++){
        for(let c=0;c<=cols-specialLen;c++){
          const tiles = [];
          const cells = [];
          for(let i=0;i<specialLen;i++){
            tiles.push(grid[r][c+i]);
            cells.push({r, c:c+i});
          }
          const kind = comboMatchKind(tiles);
          if(kind) found.push({ kind, cells });
        }
      }
      // Vertical combos
      for(let c=0;c<cols;c++){
        for(let r=0;r<=rows-specialLen;r++){
          const tiles = [];
          const cells = [];
          for(let i=0;i<specialLen;i++){
            tiles.push(grid[r+i][c]);
            cells.push({r:r+i, c});
          }
          const kind = comboMatchKind(tiles);
          if(kind) found.push({ kind, cells });
        }
      }
      return found;
    }
    function flashComboCells(cells){
      if(!cells || !cells.length) return;
      cells.forEach(p => {
        const t = grid[p.r]?.[p.c];
        if(!t) return;
        const el = tileEls.get(t.id);
        if(!el) return;
        el.classList.add("comboSpecial");
        setTimeout(()=>{ el.classList.remove("comboSpecial"); }, 520);
      });
    }

    function findLineMatches(){
      if(!isGridReady()) return {clear:new Set(), spawn:new Map(), hRuns:[], vRuns:[]};
      const clear = new Set();
      const hRuns = [];
      const vRuns = [];

      for(let r=0;r<rows;r++){
        let c=0;
        while(c<cols){
          const row = grid[r];
          if(!row){ c=cols; continue; }
          const t = row[c];
          if(!isMatchable(t)){ c++; continue; }
          const k = matchKey(t);
          let start=c;
          while(c<cols && row[c] && isMatchable(row[c]) && matchKey(row[c])===k) c++;
          const len = c-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r,c:x});
              clear.add(posKey(r,x));
            }
            hRuns.push({len,cells});
          }
        }
      }

      for(let c=0;c<cols;c++){
        let r=0;
        while(r<rows){
          const row = grid[r];
          if(!row){ r++; continue; }
          const t = row[c];
          if(!isMatchable(t)){ r++; continue; }
          const k = matchKey(t);
          let start=r;
          while(r<rows && grid[r] && grid[r][c] && isMatchable(grid[r][c]) && matchKey(grid[r][c])===k) r++;
          const len = r-start;
          if(len>=3){
            const cells=[];
            for(let x=start;x<start+len;x++){
              cells.push({r:x,c});
              clear.add(posKey(x,c));
            }
            vRuns.push({len,cells});
          }
        }
      }

      const spawn = new Map();
      const inRunH = new Map();
      const inRunV = new Map();

      for(const run of hRuns) for(const p of run.cells) inRunH.set(posKey(p.r,p.c), 1);
      for(const run of vRuns) for(const p of run.cells) inRunV.set(posKey(p.r,p.c), 1);
      for(const key of clear){
        if(inRunH.has(key) && inRunV.has(key)){
          spawn.set(key, {type:typeId("koala","P"), prio:3});
        }
      }

      function pickSpawnCell(run){
        if(lastSwap){
          const pref = posKey(lastSwap.pref.r, lastSwap.pref.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===pref)) return pref;
          const alt = posKey(lastSwap.alt.r, lastSwap.alt.c);
          if(run.cells.some(p=>posKey(p.r,p.c)===alt)) return alt;
        }
        const mid = run.cells[Math.floor(run.cells.length/2)];
        return posKey(mid.r, mid.c);
      }

      for(const run of [...hRuns, ...vRuns]){
        const k = pickSpawnCell(run);
        if(spawn.get(k)?.prio===3) continue;
        if(run.len>=5) spawn.set(k, {type:typeId("cit","P"), prio:2});
        else if(run.len===4) spawn.set(k, {type:typeId("worm","P"), prio:1});
      }

      for(const [k] of spawn) clear.delete(k);

      return {clear, spawn, hRuns, vRuns};
    }

    function hasAnyMatchOrSpecial(){
      const mm = findLineMatches();
      if(mm.clear.size>0) return true;
      const sp = findSpecialQuads();
      return sp.length>0;
    }

    function checkPowerSwap(t1, t2){
      if(!t1 || !t2) return false;
      const p1 = parseTypeId(t1.type).baseKey;
      const p2 = parseTypeId(t2.type).baseKey;

      const isP1 = isPowerupKey(p1);
      const isP2 = isPowerupKey(p2);
      const isS1 = p1 === "supernuss";
      const isS2 = p2 === "supernuss";
      const isL1 = p1 === "lovelie";
      const isL2 = p2 === "lovelie";

      // 1. Lovelie + Lovelie
      if(isL1 && isL2) return true;

      // 2. Powerup + SuperNuss
      // Also allow Giraffie + SuperNuss (Tower Power)
      const isG1 = p1 === "giraffie";
      const isG2 = p2 === "giraffie";
      if(((isP1||isG1) && isS2) || ((isP2||isG2) && isS1)) return true;

      // 3. Any Powerup involved (Combo or Single)
      // This covers Power+Power, Power+Normal, Lovelie+Power
      if(isP1 || isP2) return true;

      // 4. SuperNuss + SuperNuss? (If logic requires, though usually Powerup+SuperNuss is the key)

      return false;
    }

    function trySwap(r1,c1,r2,c2){
      if(busy) return;
      clearHints();
      const a = grid[r1][c1];
      const b = grid[r2][c2];
      if(!a || !b) return;
      if(isBlocker(a) || isBlocker(b)) return;
      if(!isSwappable(a) || !isSwappable(b)) return;
      // combo reset moved to spendMoves (so mellow moves keep combo)
      busy = true;
      lastSwap = { pref:{r:r2,c:c2}, alt:{r:r1,c:c1} };

      doSwap(r1,c1,r2,c2);
      setTimeout(()=>{
       try{
        const A = grid[r1][c1];
        const B = grid[r2][c2];
        const aBk = parseTypeId(A.type).baseKey;
        const bBk = parseTypeId(B.type).baseKey;

        if( checkPowerSwap(A, B) ){
          spendMoves(1);
          resolvePowerSwap(A,B,{dr:r2-r1, dc:c2-c1});
          setTimeout(()=>{ dropDown(); mergeMellows(); resolveAll(false); }, 220);
          return;
        }

        const ok = hasAnyMatchOrSpecial();

        // Free Swapping: No revert if no match.
      // Track last player move (for zilla targeting)
      lastPlayerMove = { r: r2, c: c2 };

      // Check if Mellow is involved (Free move up to 10x)
      if(aBk === "mellow" || bBk === "mellow"){
         if(mellowFreeMoves > 0){
           mellowFreeMoves -= 1;
         } else {
           spendMoves(1);
           }
        } else {
           spendMoves(1);
        }

        // Even if no match immediately, we resolve (maybe gravity falls? no, just check matches)
        // If ok is false, resolveAll will basically find nothing and just unlock busy.
        resolveAll(false, true);
       }catch(e){
         console.error(e);
         busy=false;
         doSwap(r1,c1,r2,c2); // undo on error
       }
      }, 185);
    }

    function hitMellowAt(r,c, dmg=1){
      const t = grid[r][c];
      if(!t) return false;

      let bigId = null;
      if(isPlaceholder(t)) bigId = t.partOf;
      else if(t.big && bigMellows.has(t.id)) bigId = t.id;

      if(bigId){
        const big = bigMellows.get(bigId);
        if(!big) return false;
        big.hp = Math.max(0, big.hp - dmg);

        // KOALA_BOSSFIGHT_SYNC_HP: Boss HP in State spiegeln
        try{
          if(bossFight && bossFight.active && (big.type==='mellowzilla' || big.type==='koalazilla')){
            bossFight.hp = big.hp;
          }
        }catch(e){}
        const anchorTile = grid[big.r][big.c];
        if(anchorTile){
          anchorTile.hp = big.hp;
          updateMellowHp(anchorTile);
        }
        if(big.hp<=0) removeBigMellow(bigId);
        return true;
      }

      const bk = parseTypeId(t.type).baseKey;
      if(bk==="mellow"){
        // Small Mellow is INVINCIBLE (absorbs hit but takes no damage)
        // It must be merged to form MellowLord to be destroyable (or cleared by special effects?)
        // User said: "mellow sollte unsterblich sein ... 2x2 zusammen packen damit er zu mellowlord wird"
        return true;
      }
      return false;
    }

    function damageMellowsAround(clearedCells){
      const dirs = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
      ];
      for(const p of clearedCells){
        for(const [dr,dc] of dirs){
          const rr=p.r+dr, cc=p.c+dc;
          if(!inBounds(rr,cc)) continue;
          hitMellowAt(rr,cc,1);
        }
      }
    }

    function jellyBumpAround(clearedCells){
      const dirs = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
      ];
      const targets = new Set();
      for(const p of clearedCells){
        for(const [dr,dc] of dirs){
          const rr = p.r + dr, cc = p.c + dc;
          if(!inBounds(rr,cc)) continue;
          const t = grid[rr][cc];
          if(!t || isBlocker(t)) continue;
          targets.add(posKey(rr,cc));
        }
      }
      for(const key of targets){
        const [r,c] = key.split(",").map(Number);
        const t = grid[r][c];
        if(!t) continue;
        const el = tileEls.get(t.id);
        if(!el) continue;
        el.classList.remove("bump");
        // reflow to restart animation
        void el.offsetWidth;
        el.classList.add("bump");
        setTimeout(()=>el.classList.remove("bump"), 520);
      }
    }

    function clearCells(cells, opts={}){
      const protectPower = !!opts.protectPower;
      const PROTECTED = new Set(["fledernuss","flederheld","supernuss"]);
      const uniq = new Set(cells.map(p=>posKey(p.r,p.c)));
      const cleared = [];
      const clearedTiles = [];

      for(const key of uniq){
        const [r,c] = key.split(",").map(Number);
        const t = grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        clearedTiles.push(t);

        if(hitMellowAt(r,c,1)){
          const center = tileCenter(r,c);
          makeStar(center.x, center.y, false);
          continue;
        }
        if(isPlaceholder(t)) continue;

        if(protectPower){
          const bk = parseTypeId(t.type).baseKey;
          if(PROTECTED.has(bk)) continue;
        }

        const el = tileEls.get(t.id);
        if(el){
          el.classList.add("pop");
          const center = tileCenter(r,c);
          showComboSprite(r, c);
          makeStar(center.x, center.y, true);
          setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
        }
        grid[r][c]=null;
        cleared.push({r,c});
      }

      damageMellowsAround(cleared);
      jellyBumpAround(cleared);
      if(ROGUE_MODE){
        applyRogueMatchResults(clearedTiles, null);
        unlockRootsAround(cleared);
        updateRogueUI();
      } else {
        const add = Math.round(cleared.length * scorePerTile() * 1.10);
        totalScore += add;
        levelScore += add;
      }
    }

    function clearRow(r){
      const cells=[];
      for(let c=0;c<cols;c++) cells.push({r,c});
      clearCells(cells, {protectPower:true});
      if(!ROGUE_MODE){ totalScore += 200; levelScore += 200; }
    }
    function clearCol(c){
      const cells=[];
      for(let r=0;r<rows;r++) cells.push({r,c});
      clearCells(cells, {protectPower:true});
      if(!ROGUE_MODE){ totalScore += 200; levelScore += 200; }
    }
    function citBlast(r,c, radius=3){
      const cells=[];
      // Diagonal band (3-wide) across the whole board
      // Main diagonals: (r-c) = const and (r+c) = const
      const diff = r - c;
      const sum = r + c;

      for(let rr=0; rr<rows; rr++){
        for(let cc=0; cc<cols; cc++){
           // Check bandwidth 3 (center + 1 each side)
           if(Math.abs((rr-cc) - diff) <= 1 || Math.abs((rr+cc) - sum) <= 1){
             cells.push({r:rr, c:cc});
           }
        }
      }
      clearCells(cells, {protectPower:true});
      if(!ROGUE_MODE){ totalScore += 260; levelScore += 260; }
    }
    function clearWholeBoard(){
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk==="myst") continue;
        cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
      if(!ROGUE_MODE){ totalScore += 800; levelScore += 800; }
    }
    function wormWave6(r1,c1,r2,c2){
      const mid = Math.round((c1+c2)/2);
      let start = mid-2;
      let end = mid+3;
      if(start<0){ end += -start; start=0; }
      if(end>cols){ start -= (end-cols); end=cols; start=Math.max(0,start); }

      const cells=[];
      for(let r=0;r<rows;r++){
        for(let c=start;c<end;c++) cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
      if(!ROGUE_MODE){ totalScore += 500; levelScore += 500; }
    }
    function koalaMagicOn(targetBaseKey){
      const base = getBase(targetBaseKey);
      toast("🐨 Koala-Magie!", "Alles von "+(base?.name||targetBaseKey)+" weg!", 3200);
      const cells=[];
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const t=grid[r][c];
        if(!t) continue;
        if(isBlocker(t)) continue;
        const bk=parseTypeId(t.type).baseKey;
        if(bk===targetBaseKey) cells.push({r,c});
      }
      clearCells(cells, {protectPower:true});
    }

    function resolvePowerSwap(A,B,dir){
      combo = clamp(combo+2, 1, 999);
      const aBk = parseTypeId(A.type).baseKey;
      const bBk = parseTypeId(B.type).baseKey;

      // === 1. Lovelie + Lovelie ===
      if(aBk==="lovelie" && bBk==="lovelie"){
         lovelieHarmony(A,B);
         return;
      }

      // === 2. SuperNuss + Powerup ===
      // Check if one is Powerup and other is SuperNuss
      // Also allow Giraffie
      if((isPowerupKey(aBk) || aBk==="giraffie") && bBk==="supernuss"){
         superNussCombo(A, B); return;
      }
      if((isPowerupKey(bBk) || bBk==="giraffie") && aBk==="supernuss"){
         superNussCombo(B, A); return;
      }

      // === 3. Lovelie + Powerup ===
      if(aBk==="lovelie" && isPowerupKey(bBk)){
         activateLovelieCombo(B, A); return;
      }
      if(bBk==="lovelie" && isPowerupKey(aBk)){
         activateLovelieCombo(A, B); return;
      }

      // === 4. Powerup + Powerup ===

      // Koala + Worm
      if((aBk==="koala" && bBk==="worm") || (aBk==="worm" && bBk==="koala")){
        unlockCombo("crossblast");
        toast("🐨🪱 KOALA × WORM!", "MEGA CROSS BLAST! 💥", 3500);
        const rMid = Math.round((A.r + B.r)/2);
        const cMid = Math.round((A.c + B.c)/2);
        const cells = [];
        for(let r=rMid-1; r<=rMid+1; r++){
            if(r<0 || r>=rows) continue;
            for(let c=0; c<cols; c++) cells.push({r,c});
        }
        for(let c=cMid-1; c<=cMid+1; c++){
            if(c<0 || c>=cols) continue;
            for(let r=0; r<rows; r++) cells.push({r,c});
        }
        clearCells(cells, {protectPower:true});
        return;
      }

      // Koala + Citrussy
      if((aBk==="koala" && bBk==="cit") || (aBk==="cit" && bBk==="koala")){
        unlockCombo("bigbang");
        toast("🐨🍋 KOALA × Citrussy!", "DOUBLE BOARD CLEAN ×2 💥💥", 3800);
        clearWholeBoard();
        setTimeout(()=>{
         try{
          dropDown();
          mergeMellows();
          setTimeout(()=>{
           try{
            clearWholeBoard();
            const bonus = Math.round(2200 * diff.scoreMult);
            totalScore += bonus;
            levelScore += bonus;
            setTimeout(()=>{
              try{ dropDown(); mergeMellows(); resolveAll(false, true); }
              catch(e){ console.error(e); busy=false; }
            }, 240);
           }catch(e){ console.error(e); busy=false; }
          }, 260);
         }catch(e){ console.error(e); busy=false; }
        }, 260);
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      // Worm + Worm
      if(aBk==="worm" && bBk==="worm"){
        unlockCombo("weaver");
        toast("🪱🪱 WEAVER WEB!", "Checkerboard Wipe! 🏁", 3200);
        checkerboardWipe(A,B);
        return;
      }

      // Cit + Cit
      if(aBk==="cit" && bBk==="cit"){
        toast("🍋🍋 DOUBLE CIT!", "Big Bang! 💥", 3200);
        citBlast(A.r,A.c,6); // Bigger radius
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      // Koala + Koala
      if(aBk==="koala" && bBk==="koala"){
        toast("🐨🐨 DOUBLE KOALA!", "Magic Wipe! ✨", 3200);
        clearWholeBoard();
        clearCells([{r:A.r,c:A.c},{r:B.r,c:B.c}]);
        return;
      }

      // Worm + Cit
      if((aBk==="worm" && bBk==="cit") || (aBk==="cit" && bBk==="worm")){
         unlockCombo("starburst");
         toast("🪱🍋 WORM × CIT!", "Star Rows! 💥", 3400);
         // Clear 3 Rows + 3 Cols
         const rMid = Math.round((A.r + B.r)/2);
         const cMid = Math.round((A.c + B.c)/2);
         // 3 Rows
         const cells = [];
         for(let r=rMid-1; r<=rMid+1; r++){
            if(r>=0 && r<rows) for(let c=0; c<cols; c++) cells.push({r,c});
         }
         // 3 Cols
         for(let c=cMid-1; c<=cMid+1; c++){
            if(c>=0 && c<cols) for(let r=0; r<rows; r++) cells.push({r,c});
         }
         clearCells(cells, {protectPower:true});
         return;
      }

      // === 5. Single Powerup Activation ===

      if(aBk==="koala" && !getSpecial(bBk)){
        koalaMagicOn(bBk);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
        return;
      }
      if(bBk==="koala" && !getSpecial(aBk)){
        koalaMagicOn(aBk);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
        return;
      }

      if(aBk==="worm"){
        if(dir.dr !== 0) clearCol(A.c);
        else clearRow(A.r);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
      }
      if(bBk==="worm"){
        if(dir.dr !== 0) clearCol(B.c);
        else clearRow(B.r);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
      }

      if(aBk==="cit"){
        citBlast(A.r,A.c,3);
        clearCells([{r:A.r,c:A.c}], {protectPower:true});
      }
      if(bBk==="cit"){
        citBlast(B.r,B.c,3);
        clearCells([{r:B.r,c:B.c}], {protectPower:true});
      }
    }

    function lovelieHarmony(A,B){
       toast("💖💖 PURE LOVE!", "Board Clean + Gifts! 🎁", 4000);
       clearWholeBoard();
       // Spawn 3 Powerups randomly
       setTimeout(()=>{
          for(let i=0;i<3;i++){
             const r=Math.floor(Math.random()*rows);
             const c=Math.floor(Math.random()*cols);
             const types = ["worm:P", "cit:P", "koala:P"];
             const tType = types[Math.floor(Math.random()*types.length)];

             // Directly overwrite logic for spawn (simplified)
             // We can just rely on normal dropDown, but we want to Force spawns.
             // We can just set a flag or modify drop logic?
             // Simplest: Wait for dropDown then replace 3 random tiles?
             // Or just let normal drop happen and add points.
             // Let's add massive points.
             totalScore += 10000;
          }
          // Actually spawning specific powerups is hard because the board is empty and will be refilled by dropDown.
          // Let's just give +10 Moves.
          moves += 10;
          toast("Lovelie Bonus!", "+10 Moves! 🎁", 3000);
          updateUI();
       }, 300);
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}], {protectPower:true});
    }

    function checkerboardWipe(A, B){
       const cells = [];
       // Pattern: (r+c)%2 same as A? Or just a fixed checkerboard.
       // Fixed checkerboard is cooler. (r+c)%2 === 0
       for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
             if( (r+c)%2 === 0 ) cells.push({r,c});
          }
       }
       clearCells(cells, {protectPower:true});
       clearCells([{r:A.r,c:A.c}, {r:B.r,c:B.c}], {protectPower:true});
    }

    function superNussCombo(powerup, supernuss){
       const pk = parseTypeId(powerup.type).baseKey;

       if(pk==="worm"){
          toast("🪱🌰 GRAND CROSS!", "Rows+Cols+Diagonals! 💥", 3200);
          // Rows + Cols + Diagonals from center
          const r=supernuss.r, c=supernuss.c;
          clearRow(r); clearCol(c);
          const cells=[];
          // Diagonals
          for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
             if(inBounds(r+d, c+d)) cells.push({r:r+d,c:c+d});
             if(inBounds(r+d, c-d)) cells.push({r:r+d,c:c-d});
          }
          clearCells(cells, {protectPower:true});
       }
       else if(pk==="cit"){
          toast("🍋🌰 GALAXY RING!", "Double Blast! 🪐", 3200);
          // Radius 2 + Radius 4 rings
          citBlast(supernuss.r, supernuss.c, 3); // Center blast
          const cells=[];
          const r=supernuss.r, c=supernuss.c;
          // Radius 5 Ring
          for(let rr=0;rr<rows;rr++){
             for(let cc=0;cc<cols;cc++){
                const dist = Math.hypot(rr-r, cc-c);
                if(dist >= 4.5 && dist <= 5.5) cells.push({r:rr, c:cc});
             }
          }
          clearCells(cells, {protectPower:true});
       }
       else if(pk==="koala"){
           toast("🐨🌰 GOLDEN ARMY!", "Evolution & Detonation! 💥", 4000);
           // Pick a random color present on board
           // Or neighbor color?
           // Random color.
           const target = BASES[Math.floor(Math.random()*BASES.length)];
           const tKey = target.key;

           // Visual transform + Clear
           const cells = [];
           for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
              const t=grid[r][c];
              if(t && parseTypeId(t.type).baseKey === tKey) cells.push({r,c});
           }

           // Clear them with delay to simulate explosion
           clearCells(cells, {protectPower:true});
       }
       else if(pk==="giraffie"){
           unlockCombo("towerpower");
           toast("🦒🌰 TOWER POWER!", "Laser Neck! 💥", 3500);
           
           // Clear column
           clearCol(supernuss.c);
           
           // Spawn 2 random Powerups
           let spawned = 0;
           for(let i=0; i<12; i++){ 
               if(spawned >= 2) break;
               const rr = Math.floor(Math.random()*rows);
               const cc = Math.floor(Math.random()*cols);
               const t = grid[rr][cc];
               if(t && !isBlocker(t) && !isPowerupKey(parseTypeId(t.type).baseKey) && parseTypeId(t.type).baseKey !== "supernuss"){
                   const type = (Math.random()<0.5) ? "cit:P" : "worm:P";
                   const oldEl = tileEls.get(t.id);
                   if(oldEl){ oldEl.remove(); tileEls.delete(t.id); }
                   
                   const newT = makeTile(rr,cc,type);
                   grid[rr][cc] = newT;
                   const newEl = createTileEl(newT, false);
                   newEl.classList.add("spawnGlow");
                   tileEls.set(newT.id, newEl);
                   ui.board.appendChild(newEl);
                   spawned++;
               }
           }
           clearCells([{r:powerup.r,c:powerup.c}, {r:supernuss.r,c:supernuss.c}], {protectPower:true});
           return;
       }

       clearCells([{r:powerup.r,c:powerup.c}, {r:supernuss.r,c:supernuss.c}], {protectPower:true});
    }

    function activateLovelieCombo(powerupTile, lovelieTile){
       const pk = parseTypeId(powerupTile.type).baseKey;
       toast("LOVELIE POWER! 💖", pk.toUpperCase()+" WAVE!", 3000);

       // Massive effect based on powerup
       if(pk === "worm"){
          // Turn 5 random tiles into worms and activate them?
          // Or just clear 5 random rows?
          // Let's clear 5 random rows.
          const rowsToClear = new Set();
          while(rowsToClear.size < 5) rowsToClear.add(Math.floor(Math.random()*rows));
          rowsToClear.forEach(r => clearRow(r));
       } else if(pk === "cit"){
          // 5 random Cit blasts
          for(let i=0;i<5;i++){
             citBlast(Math.floor(Math.random()*rows), Math.floor(Math.random()*cols), 3);
          }
       } else if(pk === "koala"){
          // Clear board + extra points
          clearWholeBoard();
          totalScore += 5000;
       }

       clearCells([{r:powerupTile.r, c:powerupTile.c}, {r:lovelieTile.r, c:lovelieTile.c}], {protectPower:true});
    }

    function resolveAll(initial=false, isPlayerSwap=false){
      if(resolving) return;
      resolving = true;
      busy = true; // Safety lock

      // Safety: Auto-reset busy if something hangs deep in recursion
      setTimeout(()=>{
         if(busy && !document.querySelector(".tile.dragging")) busy = false;
      }, 5000);

      let isFirstStep = true;
      // Boss AI Step (only if isPlayerSwap to count turns properly?)
      // User says "Attacke 2 Züge vorher rot an".
      // We can check it at the start of resolution chain.
      if(isPlayerSwap){
        const zilla = findMellowZilla();
        if(zilla){
          zilla.turn = (zilla.turn || 0) + 1;
          const phase = zilla.turn % 4; // 1,2,3,0
          
          // Update visual frame (0,1,2,3 where 3 is attack)
          // phase 1-> frame 0
          // phase 2-> frame 1
          // phase 3-> frame 2
          // phase 0-> frame 3 (Attack)
          
          let frame = 0;
          if(phase === 2) frame = 1;
          if(phase === 3) frame = 2;
          if(phase === 0) frame = 3;
          
          zilla.animFrame = frame;
          refreshTileEl(zilla);

          const zName = (zilla.type==="koalazilla") ? "KoalaZilla" : "MellowZilla";
          const chooseTarget = ()=>{
            const baseR = lastPlayerMove ? lastPlayerMove.r : Math.floor(Math.random()*(rows-1));
            const baseC = lastPlayerMove ? lastPlayerMove.c : Math.floor(Math.random()*(cols-1));
            const rr = clamp(baseR-1, 0, rows-3);
            const cc = clamp(baseC-1, 0, cols-3);
            return {r: rr, c: cc};
          };

          if(phase === 2 || phase === 3){ // Warn
             const el = tileEls.get(zilla.id);
             if(el){
               el.style.boxShadow = "0 0 20px red"; // Subtle red glow
             }
             if(!zillaPlanned) zillaPlanned = chooseTarget();
             if(phase===3 && zillaPlanned) showAttackPreview(zillaPlanned.r, zillaPlanned.c);
             toast(`${zName} lädt auf...`, "Attacke bald!", 1500);
          } else if(phase === 0 && zilla.turn > 0){ // Attack
             toast(`${zName} ATTACKE!`, "3x3 Wipe! 💥", 2600);
             const target = zillaPlanned || chooseTarget();
             clearAttackPreview();
             zillaPlanned = null;

             // Wipe
             const rr = target.r;
             const cc = target.c;
             const cells = [];
             for(let r=rr; r<rr+3; r++){
               for(let c=cc; c<cc+3; c++) cells.push({r,c});
             }
             clearCells(cells);

             // Reset visual
             const el = tileEls.get(zilla.id);
             if(el) el.style.boxShadow="none";
             
             zillaAttackCounter++;
             if(zillaAttackCounter % 3 === 0){
               dropDown();
               mergeMellows();
               ensureMovesOrShuffle();
             }
          } else {
             // Idle (phase 1)
             const el = tileEls.get(zilla.id);
             if(el) el.style.boxShadow="none";
             clearAttackPreview();
             zillaPlanned = null;
          }
        }
      }

      const step = ()=>{
       try {
        const specials = findSpecialQuads();
        const mm = findLineMatches();

        if(mm.clear.size===0 && specials.length===0){
          // Sicherstellen, dass das Board nach Level-Ups weiter spielbar bleibt
          ensureMovesOrShuffle();
          busy=false;
          resolving=false;
          layoutBoard(); // Force sync visual positions to fix drag bugs
          updateUI();
          return;
        }

        if(ROGUE_MODE){
          combo = 1;
        } else {
          combo = clamp(combo+1, 1, 999);
        }

        // Safety: Infinite Loop Protection
        if(!ROGUE_MODE && combo > 25){
           busy = false;
           resolving = false;
           combo = 1;
           shuffleAll();
           updateUI();
           toast("Auto-Reset 🛠️", "Loop Protection triggered", 2000);
           return;
        }

        let acceptedSpecials = specials;
        // User requested: Special combos only on player swap to prevent loops
        // Only accept specials on the VERY FIRST step of a player swap.
        // Cascades (isFirstStep=false) should not trigger specials.
        if(!isPlayerSwap || !isFirstStep) acceptedSpecials = [];

        // EXIT if acceptedSpecials is empty AND mm.clear is empty
        // This prevents infinite loop if 'specials' are found (so loop continues)
        // but 'acceptedSpecials' is empty (so nothing is cleared),
        // and 'mm.clear' is empty.
        if(acceptedSpecials.length === 0 && mm.clear.size === 0){
           busy=false;
           resolving=false;
           layoutBoard(); // Force sync
           updateUI();
           ensureMovesOrShuffle();
           return;
        }

      if(acceptedSpecials.length){
        for(const sp of acceptedSpecials){
          const center = sp.cells[Math.floor(sp.cells.length/2)];
          const ctr = tileCenter(center.r, center.c);
            flashComboCells(sp.cells);
            showComboSprite(center.r, center.c);
            burstFx(ctr.x, ctr.y, 14);

            if(sp.kind==="moonshuffle"){
              toast("🌙😴 Mond-Shuffle!", "4×4 Bereich ✨", 3200);
              clearCells(sp.cells);
              shuffleArea4x4(center.r, center.c);
              continue;
            }

            if(sp.kind==="therapy"){
              toast("🩹 Therapy Time!", "+3 Moves ✨", 3200);
              moves += 3;
              // Tripel entfernen, damit es NICHT erneut triggert
              clearCells(sp.cells);

              // Alle Grumpy -> Happy (Therapie Effekt)
              for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                  const t=grid[r][c];
                  if(!t) continue;
                  const p=parseTypeId(t.type);
                  if(p.baseKey==="grumpy"){
                    t.type = typeId("happy", p.variant);
                    refreshTileEl(t);
                  }
                }
              }
              continue;
            }

            if(sp.kind==="sprinkle"){
              toast("🍩✨ Sprinkle Beam!", "Beam Clear!", 3200);
              clearCells(sp.cells);
              const rr=center.r, cc=center.c;
              const beam = [];
              for(let d=-Math.max(rows,cols); d<=Math.max(rows,cols); d++){
                if(inBounds(rr, cc+d)) beam.push({r:rr,c:cc+d});
                if(inBounds(rr+d, cc)) beam.push({r:rr+d,c:cc});
                if(inBounds(rr+d, cc+d)) beam.push({r:rr+d,c:cc+d});
                if(inBounds(rr+d, cc-d)) beam.push({r:rr+d,c:cc-d});
              }
              clearCells(beam);
              continue;
            }

            if(sp.kind==="sugar"){
              toast("🍬 Sugar Rush!", "+5 Moves & Clears!", 3400);
              moves += 5;
              clearCells(sp.cells);
              const picks = [];
              for(let i=0;i<14;i++){
                const r=Math.floor(Math.random()*rows);
                const c=Math.floor(Math.random()*cols);
                picks.push({r,c});
              }
              clearCells(picks);
              continue;
            }

            if(sp.kind==="buddies"){
              toast("🐱🐶 Buddy Burst!", "Boom!", 3200);
              const area=[];
              for(const p of sp.cells){
                for(let dr=-1; dr<=1; dr++){
                  for(let dc=-1; dc<=1; dc++){
                    const rr=p.r+dr, cc=p.c+dc;
                    if(inBounds(rr,cc)) area.push({r:rr,c:cc});
                  }
                }
              }
              clearCells(sp.cells);
              clearCells(area);
              continue;
            }

            if(sp.kind==="bestbuddies"){
              toast("🦁🐱 BEST BUDDIES!", "Buddy Wave ✨", 3400);
              clearCells(sp.cells);

              // Row+Col vom Center + extra Punkte
              clearRow(center.r);
              clearCol(center.c);
              totalScore += Math.round(1200*diff.scoreMult);
              levelScore += Math.round(1200*diff.scoreMult);
              continue;
            }

            if(sp.kind==="safaritour"){
              toast("🦒🐨 SAFARI TOUR!", "High Ground Wipe!", 3400);
              clearCells(sp.cells);
              // Clear top 2 rows
              const cells = [];
              for(let r=0; r<2 && r<rows; r++){
                 for(let c=0; c<cols; c++) cells.push({r,c});
              }
              clearCells(cells);
              continue;
            }

            if(sp.kind==="bittersweet"){
              toast("💧🍬 Bittersweet!", "Worm spawns!", 3200);
              clearCells(sp.cells);
              for(let i=0;i<1;i++){
                 const r=Math.floor(Math.random()*rows);
                 const c=Math.floor(Math.random()*cols);
                 const oldT = grid[r][c];
                 if(oldT && !isBlocker(oldT) && !isPowerupKey(parseTypeId(oldT.type).baseKey)){
                    const el=tileEls.get(oldT.id);
                    if(el){ el.remove(); tileEls.delete(oldT.id); }
                    
                    const t=makeTile(r,c,"worm:P");
                    grid[r][c]=t;
                    const newEl=createTileEl(t, false);
                    newEl.classList.add("spawnGlow");
                    tileEls.set(t.id, newEl);
                    ui.board.appendChild(newEl);
                 }
              }
              continue;
            }

            if(sp.kind==="sweetdreams"){
               toast("💤🍬 Sweet Dreams!", "Area Shuffle +2 Moves", 3200);
               moves += 2;
               clearCells(sp.cells);
               shuffleArea4x4(center.r, center.c);
               continue;
            }
          }

          setTimeout(()=>{
            dropDown();
            mergeMellows();
            setTimeout(step, 450); // Increased delay to prevent ghost combos
          }, 240);
          checkLevelUp();
          updateUI();
          return;
        }

        // Check for Fledernuss runs in mm.hRuns/vRuns
        const allRuns = [...(mm.hRuns||[]), ...(mm.vRuns||[])];
        for(const run of allRuns){
          const first = run.cells[0];
          const t = grid[first.r][first.c];
          if(t){
            const bk = parseTypeId(t.type).baseKey;
            if(bk==="fledernuss"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"flederheld:A"});
               // prevent clearing the spawn spot? Logic below handles it:
               // "if(old) remove... grid[r][c]=t"
            } else if(bk==="flederheld"){
               const mid = run.cells[Math.floor(run.cells.length/2)];
               mm.spawn.set(posKey(mid.r,mid.c), {type:"supernuss:A"});
            } else if(bk==="supernuss"){
               // Explosion
               const mid = run.cells[Math.floor(run.cells.length/2)];
               toast("SUPER NUSS!", "BOOM!", 2000);
               burstFx(tileCenter(mid.r, mid.c).x, tileCenter(mid.r, mid.c).y, 20);
               // Add extra clear radius 2
               const blast = [];
               for(let rr=mid.r-2; rr<=mid.r+2; rr++){
                 for(let cc=mid.c-2; cc<=mid.c+2; cc++){
                   if(inBounds(rr,cc)) blast.push({r:rr,c:cc});
                 }
               }
               clearCells(blast); // Immediate clear
            }
          }
        }

        const toClear = new Set(mm.clear);
        // Remove spawns from clear set
        for(const [k] of mm.spawn) toClear.delete(k);

        let scoreAdd = 0;
        if(!ROGUE_MODE){
          scoreAdd = toClear.size * scorePerTile() * (1 + (combo-1)*0.12);
          totalScore += Math.round(scoreAdd);
          levelScore += Math.round(scoreAdd);
        }

        if(!ROGUE_MODE && toClear.size > 0){
           const cells = Array.from(toClear).map(k=>{
             const [rr,cc] = k.split(",").map(Number);
             return {r:rr, c:cc};
           });

           let avgR = 0, avgC = 0;
           for(const p of cells){ avgR += p.r; avgC += p.c; }
           avgR /= cells.length; avgC /= cells.length;

           let center = cells[0];
           let bestD = 1e9;
           for(const p of cells){
             const d = (p.r-avgR)*(p.r-avgR) + (p.c-avgC)*(p.c-avgC);
             if(d < bestD){ bestD = d; center = p; }
           }

           const scoreTxt = (combo > 1) ? Math.round(scoreAdd) : null;
           for(const p of cells){
             const showTxt = (p.r === center.r && p.c === center.c) ? scoreTxt : null;
             showComboAnim(showTxt, p.r, p.c);
           }
        }

        const clearedCells = [];
        const clearedTiles = [];

        for(const key of toClear){
          const [r,c] = key.split(",").map(Number);
          const t = grid[r][c];
          if(!t) continue;
          clearedTiles.push(t);

          if(hitMellowAt(r,c,1)) continue;

          const el = tileEls.get(t.id);
          if(el){
            el.classList.add("comboBurst");
            el.classList.add("pop");
            const ctr = tileCenter(r,c);
            makeStar(ctr.x, ctr.y, true);
            burstFx(ctr.x, ctr.y, 8); // Extra glitter
            setTimeout(()=>{ el.remove(); tileEls.delete(t.id); }, 420);
          }
          grid[r][c]=null;
          clearedCells.push({r,c});
        }

        damageMellowsAround(clearedCells);
        if(ROGUE_MODE){
          applyRogueMatchResults(clearedTiles, mm);
          unlockRootsAround(clearedCells);
        }

        // Fledernuss Evolution Logic
        // Check if any match was Fledernuss chain
        const alreadyEvolved = new Set();

        for(const [key, s] of mm.spawn){
           // Normal spawn logic (Cit, Worm, Koala)
           const [r,c]=key.split(",").map(Number);
           const old = grid[r][c];
           if(old){
             const oldEl = tileEls.get(old.id);
             if(oldEl) oldEl.remove();
             tileEls.delete(old.id);
           }
           const t = makeTile(r,c,s.type);
           grid[r][c]=t;
           const el = createTileEl(t, false);
           el.classList.add("spawnGlow");
           tileEls.set(t.id, el);
           ui.board.appendChild(el);
           const ctr = tileCenter(r,c);
           makeStar(ctr.x, ctr.y, true);
        }

        // Custom Evolution handling
        // For each cleared cell, check if it was part of a Fledernuss match
        // But mm.clear doesn't tell us the type.
        // We iterate matches in mm.
        // findLineMatches returned 'hRuns' and 'vRuns' internally but only returned clear/spawn sets.
        // We need to intercept the match types.

        // Let's re-scan the cleared cells to see what they were? No they are null now.
        // We should have intercepted before clearing.
        // Refactor resolveAll slightly? Or just look at the 'toClear' set before we nulled them.
        // 'clearedCells' contains the coords. But we need types.
        // 'grid' is already nulled.
        // Wait, the block above:
        // const t = grid[r][c]; ... grid[r][c]=null;
        // inside that loop we have access to 't'.

        // I will add the logic inside the clearing loop.
        /*
          const old = grid[r][c];
          if(old){
            const oldEl = tileEls.get(old.id);
            if(oldEl) oldEl.remove();
            tileEls.delete(old.id);
          }

          const t = makeTile(r,c,s.type);
          grid[r][c]=t;
          const el = createTileEl(t, false);
          el.classList.add("spawnGlow");
          tileEls.set(t.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          makeStar(ctr.x, ctr.y, true);
        */

        setTimeout(()=>{
          dropDown();
          mergeMellows();
          isFirstStep = false;
          // Add timeout limit for safety?
          setTimeout(step, 420); // Increased delay to prevent ghost combos
        }, 240);
        checkLevelUp();
        updateUI();
       } catch(e) {
         console.error("Game Logic Error:", e);
         busy = false;
         resolving = false;
       }
      };

      // Safety: If step crashes or hangs, reset busy after 5s?
      // But step() is recursive.
      // We can just rely on step() logic.
      try{
        step();
      }catch(e){
        console.error(e);
        busy=false;
        resolving=false;
      }
    }

    function shuffleArea4x4(centerR, centerC){
      const top = clamp(centerR-1, 0, rows-4);
      const left= clamp(centerC-1, 0, cols-4);

      const coords=[];
      const tiles=[];
      for(let r=top;r<top+4;r++){
        for(let c=left;c<left+4;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk=parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }

      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }

      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function dropDown(){
      for(let c=0;c<cols;c++){
        let r = rows-1;
        while(r>=0){
          while(r>=0 && isBlocker(grid[r][c])) r--;
          if(r<0) break;

          const segEnd = r;
          let segStart = segEnd;
          while(segStart>=0 && !isBlocker(grid[segStart][c])) segStart--;

          let write = segEnd;
            for(let rr=segEnd; rr>=segStart+1; rr--){
              const t = grid[rr][c];
              if(t){
                if(write !== rr){
                  grid[write][c]=t;
                  grid[rr][c]=null;
                  t.r=write; t.c=c;
                  const el = tileEls.get(t.id);
                  if(el){
                    setTileXY(el, t.r, t.c);
                    el.classList.remove("land");
                    void el.offsetWidth;
                    setTimeout(()=>{
                      el.classList.add("land");
                      setTimeout(()=>el.classList.remove("land"), 560);
                    }, 200);
                  }
                }
                write--;
              }
            }

          for(let rr=write; rr>=segStart+1; rr--){
            let tType = randNormalType();
            if(level >= 2 && Math.random() < diff.mystChance){
              tType = "myst:P";
            }
            const t = makeTile(rr,c,tType);
            grid[rr][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }

          r = segStart;
        }
      }

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(grid[r][c]===null){
            const t = makeTile(r,c,randNormalType());
            grid[r][c]=t;
            const el = createTileEl(t, true);
            tileEls.set(t.id, el);
            ui.board.appendChild(el);
          }
        }
      }

      if(Math.random() < diff.lovelieChance*0.45){
        maybeSpawnLovelie();
      }

      // After gravity settles, auto-resolve if matches are still present (failsafe for stuck boards)
      setTimeout(()=>{
        if(busy) return;
        const pending = findLineMatches();
        const specials = findSpecialQuads();
        if((pending?.clear?.size||0) > 0 || (specials?.length||0) > 0){
          resolveAll(false, false);
        }
      }, 40);
    }

    function mergeMellows(){
      for(let r=0;r<rows-1;r++){
        for(let c=0;c<cols-1;c++){
          const a = grid[r][c];
          const b = grid[r][c+1];
          const d = grid[r+1][c];
          const e = grid[r+1][c+1];
          if(!a||!b||!d||!e) continue;

          if(isPlaceholder(a)||isPlaceholder(b)||isPlaceholder(d)||isPlaceholder(e)) continue;

          const ak = parseTypeId(a.type).baseKey;
          const bk = parseTypeId(b.type).baseKey;
          const dk = parseTypeId(d.type).baseKey;
          const ek = parseTypeId(e.type).baseKey;

          if(ak!=="mellow" || bk!=="mellow" || dk!=="mellow" || ek!=="mellow") continue;
          if(a.big || b.big || d.big || e.big) continue;

          const hpSum = (a.hp||0) + (b.hp||0) + (d.hp||0) + (e.hp||0);
          const bigHp = 15; // Fixed HP for MellowLord

          [a,b,d,e].forEach(t=>{
            const el = tileEls.get(t.id);
            if(el){ el.remove(); tileEls.delete(t.id); }
          });
          const bigId = makeId();
          // MellowLord uses special type
          const bigTile = { id: bigId, r, c, type: "mellowlord:A", hp: bigHp, big:true };
          bigMellows.set(bigId, {id:bigId, r, c, hp:bigHp, type:"mellowlord"});

          grid[r][c] = bigTile;
          grid[r][c+1] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c] = { type:"mellow_part", partOf: bigId };
          grid[r+1][c+1] = { type:"mellow_part", partOf: bigId };

          const el = createTileEl(bigTile, false);
          el.classList.add("spawnGlow");
          tileEls.set(bigTile.id, el);
          ui.board.appendChild(el);

          const ctr = tileCenter(r,c);
          burstFx(ctr.x + (CELL+GAP)/2, ctr.y + (CELL+GAP)/2, 25);
          // Peng Peng Glitter
          for(let i=0;i<5;i++){
             setTimeout(()=>makeStar(ctr.x + (Math.random()*60-30), ctr.y + (Math.random()*60-30), true), i*100);
          }
          toast("Mellowlord! 😈","4 Mellows verschmelzen!", 2800);
          setTileXY(el, r, c);
        }
      }
      checkMellowlordFusion();
    }

    function findMellowZilla(){
      for(const [id, m] of bigMellows){
        if(m.type === "mellowzilla" || m.type === "koalazilla") return m;
      }
      return null;
    }

    function clearAttackPreview(){
      const fx = document.getElementById("fxLayer");
      if(!fx) return;
      fx.querySelectorAll(".attackWarn").forEach(el=>el.remove());
    }
    function showAttackPreview(rr, cc){
      const fx = document.getElementById("fxLayer");
      if(!fx) return;
      clearAttackPreview();
      const size = CELL;
      const boardRect = ui.board.getBoundingClientRect();
      const fxRect = fx.getBoundingClientRect();
      const boardX = boardRect.left - fxRect.left;
      const boardY = boardRect.top - fxRect.top;
      const pad = currentPad();
      for(let r=rr; r<rr+3; r++){
        for(let c=cc; c<cc+3; c++){
          if(!inBounds(r,c)) continue;
          const warn = document.createElement("div");
          warn.className = "attackWarn";
          warn.style.left = (boardX + pad + c*(CELL+GAP)) + "px";
          warn.style.top  = (boardY + pad + r*(CELL+GAP)) + "px";
          warn.style.width = size + "px";
          warn.style.height = size + "px";
          fx.appendChild(warn);
        }
      }
    }

    function placeZillaAt(centerR, centerC, zType="mellowzilla", hp=100, setBoss=true){
      discoverLuvvie(zType);
      const bigId = makeId();
      const zilla = { id: bigId, r: centerR, c: centerC, type: `${zType}:A`, hp: hp, big:true, zilla:true };

      for(let r=centerR; r<centerR+3; r++){
        for(let c=centerC; c<centerC+3; c++){
           if(inBounds(r,c)){
             const t = grid[r][c];
             if(t){
               // Check for Big Mellow overlapping
               let victimId = null;
               if(t.big && bigMellows.has(t.id)) victimId = t.id;
               if(isPlaceholder(t)) victimId = t.partOf;
               
               if(victimId && bigMellows.has(victimId)){
                   removeBigMellow(victimId);
                   unlockCombo("zillacrush");
                   toast("ZILLA CRUSH! 🦖", "Platz da!", 2000);
               }

               // Clean up any remaining tile/element
               const t2 = grid[r][c];
               if(t2){
                   const el = tileEls.get(t2.id);
                   if(el) el.remove();
                   tileEls.delete(t2.id);
               }
             }
             grid[r][c] = { type:"mellow_part", partOf: bigId };
           }
        }
      }

      // Anchor
      grid[centerR][centerC] = zilla;
      bigMellows.set(bigId, {id:bigId, r:centerR, c:centerC, hp:hp, type:zType});

      const el = createTileEl(zilla, false);
      el.classList.add("spawnGlow");
      // Scale for 3x3
      el.style.width = `calc(var(--cell) * 3 + var(--gap) * 2)`;
      el.style.height = `calc(var(--cell) * 3 + var(--gap) * 2)`;

      tileEls.set(zilla.id, el);
      ui.board.appendChild(el);
      setTileXY(el, centerR, centerC);

      if(setBoss){
        bossFight = { active:true, type:zType, hp:hp, spawnLevel: level, deadlineLevel: level + 5 };
        zillaAttackCounter = 0;
        zillaPlanned = null;
      }
      toast(zType==="mellowzilla" ? "MELLOW ZILLA!! 🦖" : "KOALA ZILLA!! 🐨🦖", "Boss Fight!", 4000);
      return zilla;
    }

    function spawnMellowZilla(){
      if(level < 20) return;
      if(level % 20 !== 0) return;

      // Random alternate: KoalaZilla <-> MellowZilla (avoid same twice in a row)
      let zType = (Math.random() < 0.5) ? "mellowzilla" : "koalazilla";
      if(lastZillaType && zType === lastZillaType){
        zType = (zType === "mellowzilla") ? "koalazilla" : "mellowzilla";
      }
      lastZillaType = zType;

      const cr = Math.floor(rows/2)-1;
      const cc = Math.floor(cols/2)-1;
      placeZillaAt(cr, cc, zType, 100, true);
    }

    function shiftMellowZilla(zilla){
      // Shift center by 2 blocks? Or move Zilla?
      // User: "Mitte verschieben um 2 Blöcke"
      // Let's assume shuffling the center or moving Zilla.
      // Moving Zilla is hard if board is full.
      // Let's shuffle the board AROUND Zilla.
      shuffleAll();
      toast("Zilla Roar!", "Alles geshuffelt!", 2000);
    }

    function removeBigMellow(bigId){
      const big = bigMellows.get(bigId);
      if(!big) return;
      bigMellows.delete(bigId);

      const anchor = grid[big.r][big.c];
      if(anchor && anchor.id){
        const el = tileEls.get(anchor.id);
        if(el){
          // Show Death Animation
          if(big.type.includes("mellowzilla") || big.type.includes("koalazilla") || big.type.includes("mellowlord")){
             showDeathAnim(big.r + (big.type.includes("zilla") ? 1.5 : 1), big.c + (big.type.includes("zilla") ? 1.5 : 1));
          }
          el.classList.add("pop");
          setTimeout(()=>{ el.remove(); tileEls.delete(anchor.id); }, 420);
        }
      }

      // Boss Check for points
      if(big.type.includes("mellowzilla") || big.type.includes("koalazilla")){

        // KOALA_BOSSFIGHT_CLEAR: Boss besiegt -> Timer stoppen
        try{ if(bossFight && bossFight.active){ bossFight.active=false; bossFight=null; } }catch(e){}
        clearAttackPreview();
        const bonus = 20000;
        totalScore += bonus;
        levelScore += bonus;
        if(big.type === "mellowzilla"){
          toast("MELLOW ZILLA BESIEGT! 🏆", "+20.000 PUNKTE!", 4000);
        } else {
          toast("KOALA ZILLA BESIEGT! 🏆", "+20.000 PUNKTE!", 4000);
        }
      } else {
        toast("Mellow gelöst! ✨","Nice!", 2600);
      }

      const size = (big.type==="mellowzilla" || big.type==="koalazilla") ? 3 : 2;
      for(let rLoop=big.r; rLoop<big.r+size; rLoop++){
        for(let cLoop=big.c; cLoop<big.c+size; cLoop++){
          if(!inBounds(rLoop,cLoop)) continue;
          showComboSprite(rLoop, cLoop);
          const t = grid[rLoop][cLoop];
          if(t && isPlaceholder(t) && t.partOf===bigId) grid[rLoop][cLoop]=null;
          if(t && t.id===bigId) grid[rLoop][cLoop]=null;
        }
      }
    }

    function checkMellowlordFusion(){
      const anchorMap = new Map();
      for(const [id, m] of bigMellows){
        if(m.type==="mellowlord") anchorMap.set(posKey(m.r,m.c), id);
      }
      const processed = new Set();
      for(const key of anchorMap.keys()){
        if(processed.has(key)) continue;
        const [r,c] = key.split(",").map(Number);
        const needed = [
          posKey(r,c),
          posKey(r,c+2),
          posKey(r+2,c),
          posKey(r+2,c+2)
        ];
        if(needed.every(k=>anchorMap.has(k))){
          needed.forEach(k=>processed.add(k));
          // remove old mellowlords
          const ids = needed.map(k=>anchorMap.get(k));
          ids.forEach(id=>{
            const info = bigMellows.get(id);
            if(!info) return;
            for(let rr=info.r; rr<info.r+2; rr++){
              for(let cc=info.c; cc<info.c+2; cc++){
                const t=grid[rr][cc];
                if(t && t.id===id){
                  const el = tileEls.get(t.id);
                  if(el){ el.remove(); tileEls.delete(t.id); }
                }
                grid[rr][cc]=null;
              }
            }
            bigMellows.delete(id);
          });
          const centerR = r+1, centerC = c+1;
          placeZillaAt(centerR, centerC, "mellowzilla", 80, true);
          toast("MellowZilla entsteht!","4 Mellowlords fusionieren!", 3600);
        }
      }
    }

    function hasMove(){
      if(!isGridReady()) return false;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          // Free move logic: if t is mellow, it's always movable
          const isMellow = parseTypeId(t.type).baseKey === "mellow";

          const dirs=[[1,0],[0,1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            if(isMellow) return true;
            const uIsMellow = parseTypeId(u.type).baseKey === "mellow";
            if(uIsMellow) return true;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok) return true;
          }
        }
      }
      return false;
    }

    function shuffleAll(){
      const coords=[];
      const tiles=[];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t) continue;
          if(isBlocker(t)) continue;
          const bk = parseTypeId(t.type).baseKey;
          if(bk==="myst") continue;
          coords.push({r,c});
          tiles.push(t);
        }
      }
      for(let i=tiles.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [tiles[i],tiles[j]]=[tiles[j],tiles[i]];
      }
      coords.forEach((p,i)=>{
        const t=tiles[i];
        grid[p.r][p.c]=t;
        t.r=p.r; t.c=p.c;
        const el = tileEls.get(t.id);
        if(el){
          setTileXY(el, t.r, t.c);
          el.classList.add("spawnGlow");
          setTimeout(()=>el.classList.remove("spawnGlow"), 700);
        }
      });
    }

    function ensurePlayableBoard(maxShuffles=6, autoResolve=true){
      if(!isGridReady()) return true; // defer shuffling until board exists
      try{ if(typeof pruneOrphanTileEls === "function") pruneOrphanTileEls(); }catch(e){}
      let tries = 0;
      while(tries < maxShuffles){
        if(hasAnyMatchOrSpecial()){
          if(autoResolve && !busy && !autoResolveQueued && !resolving){
            autoResolveQueued = true;
            setTimeout(()=>{
              autoResolveQueued = false;
              if(!busy && !resolving) resolveAll(false, false);
            }, 0);
          }
          return true; // immediate clearable match/special
        }
        if(hasMove()) return true;              // at least one possible swap-to-match
        shuffleAll();
        tries++;
      }
      return false;
    }

    function ensureMovesOrShuffle(){
      if(resolving) return;
      if(ensurePlayableBoard(6, false)) return;
      // Fallback: still stuck? force one last shuffle and try resolving
      shuffleAll();
      layoutBoard();
      setTimeout(()=>{ if(!busy && !resolving) resolveAll(false, false); }, 60);
    }

    // Idle watchdog: if matches exist while not busy, auto-resolve to prevent stuck boards
    setInterval(()=>{
      if(busy || autoResolveQueued || resolving || document.hidden) return;
      if(hasAnyMatchOrSpecial()){
        autoResolveQueued = true;
        setTimeout(()=>{
          autoResolveQueued = false;
          if(!busy && !resolving) resolveAll(false, false);
        }, 0);
      }
    }, 520);

    function hint(){
      
      // KOALA_HINT_COST_MOVE: Hint kostet 1 Move
      if(typeof moves !== 'undefined'){
        if(moves<=0){ try{ toast('Keine Moves mehr!','',1800); }catch(e){} return; }
        try{ spendMoves(1); }catch(e){}
        try{ updateUI(); }catch(e){}
      }
clearHints();
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const t=grid[r][c];
          if(!t || isBlocker(t)) continue;
          if(!isSwappable(t)) continue;

          const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const u=grid[rr][cc];
            if(!u || isBlocker(u)) continue;
            if(!isSwappable(u)) continue;

            doSwap(r,c,rr,cc);
            const ok = hasAnyMatchOrSpecial();
            doSwap(r,c,rr,cc);
            if(ok){
              const el1=tileEls.get(t.id);
              const el2=tileEls.get(u.id);
              if(el1) el1.classList.add("hint");
              if(el2) el2.classList.add("hint");
              toast("Hint ✨","Probier die zwei!", 3000);
              return;
            }
          }
        }
      }
      toast("Keine direkten Matches 😵","Du kannst trotzdem frei swappen (Setup-Move).", 3200);
      // Recovery: resync layout to avoid rare input deadlocks / stray tiles
      try{ busy=false; }catch(e){}
      try{ layoutBoard(); pruneOrphanTileEls(); updateUI(); }catch(e){}
      clearHints();
    }

    async function toggleFullscreen(){
      const root = document.documentElement;
      try{
        if(document.fullscreenElement){
          await document.exitFullscreen();
        }else{
          await root.requestFullscreen();
        }
      }catch(e){}
    }
    document.addEventListener("fullscreenchange", ()=>{
      if(document.fullscreenElement){
        document.body.classList.add("fs");
        document.body.classList.remove("hidePanels");
        document.body.classList.add("showPanels");
        buildFsBg(true);
      }else{
        document.body.classList.remove("fs");
        document.body.classList.remove("maximized");
        document.body.classList.remove("showPanels");
        document.body.classList.remove("hidePanels");
        document.getElementById("fsBg").innerHTML="";
      }
      setAppHeight();
      setTimeout(()=>relayoutAll(true, true), 120);
    });

    function updateUI(){
      if(ROGUE_MODE){
        updateRogueUI();
        return;
      }
      ui.level.textContent = level;
      ui.goal.textContent = fmt(target);
      ui.score.textContent = fmt(totalScore);
      ui.moves.textContent = moves;
      ui.combo.textContent = "x"+combo;

      const pct = clamp(Math.round((levelScore/target)*100), 0, 100);
      ui.bar.style.setProperty("--pct", pct+"%");
      ui.pct.textContent = pct+"%";

      ui.hudLevel.textContent = "Level "+level;
      ui.hudScore.textContent = "Score "+fmt(totalScore);
      ui.hudMoves.textContent = "Moves "+moves;
      ui.hudCombo.textContent = "Combo x"+combo;
      ui.hudBar.style.setProperty("--pct", pct+"%");
      ui.hudPct.textContent = pct+"%";
    
      // Maximize HUD mirror
      const ml = document.getElementById("maxLvl");
      const ms = document.getElementById("maxScore");
      const mm = document.getElementById("maxMoves");
      const mc = document.getElementById("maxCombo");
      if(ml) ml.textContent = level;
      if(ms) ms.textContent = fmt(totalScore);
      if(mm) mm.textContent = moves;
      if(mc) mc.textContent = "x"+combo;
    }

    function checkLevelUp(){
      if(ROGUE_MODE){
        checkRoguePendingOutcome();
        return;
      }
      if(levelScore >= target){
        level++;

        // KOALA_BOSS_DEADLINE_CHECK: Option 2 -> Wenn Boss noch lebt und Deadline überschritten -> Game Over
        try{
          if(bossFight && bossFight.active && bossFight.hp > 0 && level > bossFight.deadlineLevel){
            toast('Boss entkommen 😱', 'Du hattest bis Level '+bossFight.deadlineLevel+' Zeit!', 4200);
            moves = 0;
            updateUI();
            setTimeout(()=>gameOver(), 400);
            return;
          }
        }catch(e){}
        levelScore = 0;
        maybeUnlockVariant();
        refreshActivePool(); // Recalculate allowed colors

        target = calcTarget(level);
        moves = calcMoves(level);

        toast("🎉 Ziel erreicht!","Next Level: "+level, 3200);
        spawnMellow();
        spawnMellowZilla(); // Check if Boss level
        maybeSpawnLovelie();
      }
    }

    function gameOver(){
      if(ROGUE_MODE){
        finishRogueRun();
        showRogueSummary(false);
        return;
      }
      // Show dedicated Game Over Modal
      document.getElementById("goScore").textContent = fmt(totalScore);

      // Set Boss Images
      const zLeft = document.getElementById("goZillaLeft");
      const zRight = document.getElementById("goZillaRight");
      if(zLeft && IMG.mellowzilla) zLeft.src = IMG.mellowzilla[3] || IMG.mellowzilla[0];
      if(zRight && IMG.koalazilla) zRight.src = IMG.koalazilla[3] || IMG.koalazilla[0];

      const saved = getCookie("luvvies_name");
      document.getElementById("goName").value = saved || document.getElementById("lbName").value || document.getElementById("greetName").value || "";

      document.getElementById("gameOverBack").style.display = "flex";

      // Auto-fill lbName if changed
      document.getElementById("lbName").value = document.getElementById("goName").value;

      // Auto-post (optional)
      try{
        const auto = document.getElementById("lbAuto")?.checked;
        const nm = (document.getElementById("lbName").value || "").trim();
        if(auto && nm && !autoPostDone){
          autoPostDone = true;
          setTimeout(()=>postScore(), 180);
        }
      }catch(e){}
    }

    // Game Over Buttons
    document.getElementById("goNew").addEventListener("click", ()=>{
      document.getElementById("gameOverBack").style.display = "none";
      if(ROGUE_MODE){
        if(ROGUE.run.actComplete){
          finishRogueRun();
        } else {
          showTown(true);
        }
        return;
      }
      newGame(false);
    });
    const goContinue = document.getElementById("goContinue");
    if(goContinue) goContinue.addEventListener("click", ()=>{
      document.getElementById("gameOverBack").style.display = "none";
      if(ROGUE_MODE){
        startNextAct();
      }
    });
    document.getElementById("goPost").addEventListener("click", async ()=>{
       if(ROGUE_MODE) return;
       // Sync name
       const n = document.getElementById("goName").value;
       document.getElementById("lbName").value = n;
       await postScore();
       document.getElementById("gameOverBack").style.display = "none";
       newGame(false);
    });

    function newGame(fromDiffChange=false){
      busy=false;
      resolving=false;
      autoPostDone=false;
      level = (ROGUE_MODE && window.ROGUE_PENDING_NODE && typeof window.ROGUE_PENDING_NODE.row === "number")
        ? (window.ROGUE_PENDING_NODE.row + 1)
        : 1;
      totalScore=0;
      levelScore=0;
      combo=1;
      mellowFreeMoves = 10;
      resetUnlocked();
      target = calcTarget(level);
      moves = calcMoves(level);
      lastSwap=null;
      TILE_TINT_CACHE.clear();
      USED_TINT_HUES.length = 0;

      // Determine active pool for this game (based on difficulty)
      // Recalculate if level goes up?
      // If we limit colors, new characters won't appear.
      // Maybe we shouldn't limit statically.
      // But 8x8 with 10 colors is unplayable.
      // Strategy: On initBoard, we set the pool.
      // But BASES changes with Level (minLevel).
      // We will handle pool logic dynamically but cap the count.
      // Actually, simplest is: select Max N types from available.
      // Which ones?
      // Always basics + current "featured" ones?
      // Let's implement `refreshActivePool()` called on Level Up.
      refreshActivePool();

      initBoard();
      buildMenu();
      updateUI();
      refreshLeaderboard();
      if(!fromDiffChange){
        toast("Neues Spiel ✨", diff.name+" • "+diff.rows+"×"+diff.cols, 2600);
      }
      syncLbHeight();
    }

    /**********************
     * Menu + Steckbrief
     **********************/
    function buildMenu(){
      ui.menu.innerHTML="";
      const menuGrid = document.getElementById("menuLuvGrid");
      if(menuGrid) menuGrid.innerHTML="";

      // 1. Get Bases (including Giraffie/MellowLord which are in BASES)
      const baseItems = BASES.map(b=>({ ...b, imgSmall: IMG_SMALL[b.key] || b.img }));
      
      // 2. Define Specials (Powerups/Bosses that are NOT in BASES or need manual entry)
      const specials = [
        {key:"myst",name:"???",img:IMG.mystBtn,imgSmall:IMG_SMALL.myst,tag:"powerup",ability:"Mystery‑Powerup",story:"Mystery ist Glück + Rarity.",lines:{easy:["???","Puff ✨","Glück!"],normal:["Reveal time.","Puff.","Random!"],hard:["Risk it.","Puff.","Roll!"],shock:["ALL IN 😈","Puff!","GAMBLE!"]}},
        {key:"worm",name:"Sourworm",img:IMG.worm,imgSmall:IMG_SMALL.worm,tag:"powerup",ability:"Powerup‑Effekt",story:"Sauer, aber räumt sauber.",lines:{easy:["Chomp!","Weg damit!","Sauer!"],normal:["Line clear.","Crunch.","Nice."],hard:["Präzise.","Perfekt.","Clean."],shock:["WELLE!","CRUNCH!","RIP Reihe!"]}},
        {key:"cit",name:"Citrussy",img:IMG.citrussy,imgSmall:IMG_SMALL.citrussy,tag:"powerup",ability:"Powerup‑Effekt",story:"Zitrus-Boom in alle Richtungen.",lines:{easy:["CIT!","Spritz!","Boom!"],normal:["Cross clear.","Zing!","Nice."],hard:["Setz’s gut.","Perfekt.","Value!"],shock:["ZITRUS-NUKE!","BOOM!","MEHR!"]}},
        {key:"koala",name:"Koala",img:IMG.koala,imgSmall:IMG_SMALL.koala,tag:"powerup",ability:"Powerup‑Effekt",story:"Boss-Magie: eine Sorte komplett weg.",lines:{easy:["Boss!","Magie!","Clean!"],normal:["Koala time.","Alles weg.","Nice."],hard:["Richtig wählen.","Perfekt.","Carry."],shock:["BOSS MODE 😈","Wipe!","SWEET!"]}},
        {key:"mellow",name:"Mellow",img:IMG.mellow,imgSmall:IMG_SMALL.mellow,tag:"obstacle",ability:"Kein HP – 10× gratis bewegbar",story:"Mellow blockt nicht, er schenkt dir Free‑Moves.",lines:{easy:["Gratis Move!","Slide!","10x frei"],normal:["Free‑Move.","Geschenkt.","Weiter!"],hard:["Gratis Zug.","Nutzen.","Sauber."],shock:["FREE MOVES 😈","Schieben!","Go!"]}},
        {key:"lovelie",name:"Lovelie",img:IMG.lovelie,imgSmall:IMG_SMALL.lovelie,tag:"bonus",ability:"Ultra selten (Bonus)",story:"Wenn Lovelie kommt, lohnt’s sich.",lines:{easy:["OMG 💖","So selten!","Bonus!"],normal:["Lovelie!","Lucky!","Nice."],hard:["Rare!","Take it.","Value!"],shock:["ULTRA RARE 💖","LETS GO!","HYPE!"]}},
        {key:"mellowzilla",name:"MellowZilla",img:IMG.mellowzilla[0],imgSmall:IMG_SMALL.mellowzilla,tag:"boss",ability:"Boss‑Präsenz",story:"MellowZilla stampft durchs Board – wenn er auftaucht, wird’s wild.",lines:{easy:["Grrr…","Ich bin groß!","ROAR!"],normal:["Stampf.","Chaos.","Zilla time."],hard:["Ich komme.","Bereit?","Druck."],shock:["MELLOWZILLA!! 😈","BOARD CRUSH","ROOOAR!"]}},
        {key:"koalazilla",name:"KoalaZilla",img:IMG.koalazilla[0],imgSmall:IMG_SMALL.koalazilla,tag:"boss",ability:"Boss‑Präsenz",story:"KoalaZilla ist selten, aber brutal – der Boss räumt hart ab.",lines:{easy:["Koala…Zilla!","ROAR!","Big Boss."],normal:["Zilla time.","Bereit.","Grrr."],hard:["Kein Fehler.","Druck.","Achtung."],shock:["KOALAZILLA 😈","BOSS RAGE","CRUSH!"]}}
      ];

      // Merge maps to ensure unique keys (prefer BASES version if exists)
      const map = new Map();
      baseItems.forEach(x=>map.set(x.key, x));
      specials.forEach(x=>{
         if(!map.has(x.key)) map.set(x.key, x);
      });
      
      const all = Array.from(map.values());

      // Custom Order: Group Koalas, Group Mellows, rest roughly by level/theme
      const order = [
         "sweety", "donut", "sleepy", "mond", 
         "grumpy", "happy", "cry", "normal",
         "joyce", "smokey", "simba", 
         "worm", "cit", 
         "fledernuss", "flederheld", "supernuss",
         "giraffie",
         "lovelie", "myst",
         // Koala Group
         "koala", "koalazilla",
         // Mellow Group
         "mellow", "mellowlord", "mellowzilla"
      ];
      
      all.sort((a,b)=>{
         let ia = order.indexOf(a.key);
         let ib = order.indexOf(b.key);
         if(ia===-1) ia=999;
         if(ib===-1) ib=999;
         if(ia !== ib) return ia - ib;
         return (a.minLevel||0) - (b.minLevel||0);
      });

      const createCard = (b) => {
        const card=document.createElement("div");
        card.className="luvCard";
        // Give each Luvvie card a subtle unique background (helps recognition in the list)
        const base = getBase(b.key);
        const pal = (base && base.palettes && (base.palettes.A || base.palettes.B)) ? (base.palettes.A || base.palettes.B) : ["#ffffff","#f2f3ff"];
        card.classList.add("hasPal");
        card.style.setProperty("--c1", pal[0]);
        card.style.setProperty("--c2", pal[1]);
        const imgSrc = b.imgSmall || b.img || "";
        const imgHtml = imgSrc ?
          `<img src="${imgSrc}" alt="${b.name}">` :
          `<div style="width:78px;height:78px;border-radius:18px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ff4fb9,#7ad8ff);color:#fff;font-weight:1000;font-size:32px;box-shadow:0 12px 20px rgba(0,0,0,.12);">?</div>`;
        const hasB = (unlocked[b.key] && unlocked[b.key].has("B")) || gridHasVariantB(b.key);
        card.innerHTML = `
          ${imgHtml}
          <div>
            <b>${b.name}</b>
            <small>${b.tag || "normal"}</small>
          </div>
          <button class="luvSave" title="Diese Farbe dauerhaft speichern" style="position:absolute;right:8px;bottom:38px;height:26px;min-width:28px;padding:0 6px;border-radius:999px;border:1px solid rgba(17,13,26,.12);background:rgba(255,255,255,.9);font-weight:1000;font-size:12px;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,.10);z-index:2;">💾</button>
          <button class="luvChange" title="Farbe wechseln">🌈</button>
          ${hasB ? `<button class="variantBadge btn" title="Variante B Farbe">B</button>` : ""}
        `;
        card.addEventListener("click", ()=>openInfo(b));
        const saveBtn = card.querySelector(".luvSave");
        if(saveBtn){
          saveBtn.addEventListener("click", (e)=>{
            e.stopPropagation();
            saveTintState();
            saveTintOverrides();
            toast("Farbe gespeichert 💾", b.name, 1800);
          });
        }
        const changeBtn = card.querySelector(".luvChange");
        if(changeBtn){
          changeBtn.addEventListener("click", (e)=>{
            e.stopPropagation();
            rerollLuvvieTint(b.key);
          });
        }
        const changeBtnB = card.querySelector(".variantBadge.btn");
        if(changeBtnB){
          changeBtnB.addEventListener("click", (e)=>{
            e.stopPropagation();
            rerollLuvvieTintB(b.key);
          });
        }
        return card;
      };

      for(const b of all){
        ui.menu.appendChild(createCard(b));
        if(menuGrid) menuGrid.appendChild(createCard(b));
      }
      syncLbHeight();
    }

    function openInfo(b){
      const infoSrc = b.imgSmall || b.img || "";
      document.getElementById("infoImg").src = infoSrc;
      document.getElementById("infoImg").style.display = infoSrc ? "block" : "none";
      document.getElementById("infoName").textContent = b.name;
      document.getElementById("infoTag").textContent = (b.tag || "normal") + " • Varianten: A/B (ab Level 5)";
      document.getElementById("infoAbility").textContent = b.ability || "—";
      document.getElementById("infoStory").textContent = b.story || "—";
      const comboEl = document.getElementById("infoCombo");
      if(comboEl){
        const keys = comboKeysForBase(b.key);
        const unlocked = keys.filter(k => combosUnlocked.has(k));
        if(unlocked.length){
          comboEl.textContent = unlocked.map(k => COMBOS[k].title).join(" • ");
        }else{
          comboEl.textContent = keys.length ? "???" : "—";
        }
      }

      const ul = document.getElementById("infoLines");
      ul.innerHTML="";
      const lines = (b.lines?.[diff.key] || b.lines?.easy || []).slice(0,3);
      for(const line of lines){
        const li=document.createElement("li");
        li.textContent=line;
        ul.appendChild(li);
      }
      document.getElementById("infoBack").style.display="flex";
    }

    /**********************
     * Leaderboard
     **********************/
    function cleanName(s){
      let out = s.replace(/[^a-zA-Z0-9\säöüÄÖÜß!._-]/g, "");
      // Expanded Bad words filter
      const bad = [
        "hitler", "nazi", "arsch", "wichser", "hurensohn", "idiot", "dummbatz", "fuck", "bitch", "whore", "cunt", "nigger", "faggot", "fotze", "missgeburt", "bastard", "penis", "vagina", "sex", "anal"
      ];
      const lower = out.toLowerCase();
      // Whitelist
      if(lower.includes("koalaaufpillen")) return out;

      for(const b of bad){
        if(lower.includes(b)) return "***";
      }
      return out;
    }

    function getUuid(){
      let u = getCookie("luvvies_uuid");
      if(!u){
        try{ u = crypto.randomUUID(); }
        catch(e){ u = String(Date.now()) + "-" + Math.random().toString(16).slice(2); }
        setCookie("luvvies_uuid", u, 36500); // 100 years
      }
      return u;
    }

    // Current season = calendar quarter (resets every ~3 months)
    function currentSeasonStart(){
      // Returns { isoTs, dateStr, label }
      const now = new Date();
      const y = now.getUTCFullYear();
      const q = Math.floor(now.getUTCMonth() / 3);   // 0..3
      const m = q * 3;                               // 0,3,6,9
      const d = new Date(Date.UTC(y, m, 1, 0, 0, 0)); // quarter start
      const isoTs = d.toISOString();                 // for created_at filters
      const dateStr = isoTs.slice(0,10);             // YYYY-MM-DD for season_start (optional)
      const label = `Q${q+1} ${y}`;
      return { isoTs, dateStr, label };
    }

    async function postScore(){
      if(ROGUE_MODE) return;
      if(!sb){ toast("Leaderboard offline","(Supabase nicht erreichbar)", 3200); return; }

      let name = (document.getElementById("lbName").value || document.getElementById("goName").value || document.getElementById("greetName").value || "Anonymous").trim().slice(0,24);
      name = cleanName(name);

      // Save name + keep stable UUID (identity)
      setCookie("luvvies_name", name, 36500);
      const uuid = getUuid();
      localStorage.setItem("luvvies_last_name", name);

      // Season: current calendar quarter (≈ 3 months)
      const season = currentSeasonStart();
      const seasonStartIso = season.isoTs;

      const payload = {
        player_name: name,
        score: totalScore,
        level: level,
        difficulty: diff.key,
        version:"luvvies-crush",
        user_id: uuid
      };

      try{
        // Find existing best for this UUID + difficulty inside current season window
        let best = null;
        try{
          const { data, error } = await sb
            .from(SCORE_TABLE)
            .select("id,score,created_at")
            .eq("user_id", uuid)
            .eq("difficulty", diff.key)
            .gte("created_at", seasonStartIso)
            .order("score", { ascending:false })
            .limit(1);

          if(error) throw error;
          best = (data && data[0]) ? data[0] : null;
        }catch(selErr){
          // Fallback if table has no "id" column: select without id
          const msg = String(selErr?.message || selErr);
          if(msg.toLowerCase().includes("column") && msg.toLowerCase().includes("id")){
            const { data, error } = await sb
              .from(SCORE_TABLE)
              .select("score,created_at")
              .eq("user_id", uuid)
              .eq("difficulty", diff.key)
              .gte("created_at", seasonStartIso)
              .order("score", { ascending:false })
              .limit(1);
            if(error) throw error;
            best = (data && data[0]) ? data[0] : null;
          } else {
            throw selErr;
          }
        }

        // If not better, don't spam inserts
        if(best && Number(payload.score) <= Number(best.score||0)){
          toast("Schon gespeichert ✅", `Bestscore (${diffLabel(diff.key)}): ${fmt(best.score)}`, 3200);
          await refreshLeaderboard();
          return;
        }

        // Update if possible; otherwise insert
        if(best && best.id){
          const { error } = await sb.from(SCORE_TABLE).update(payload).eq("id", best.id);
          if(error) throw error;
          toast("Bestscore aktualisiert ✅", name+" • "+fmt(totalScore), 3200);
        } else if(best && !best.id){
          // Without an id, update the newest season rows for this uuid+diff (keeps single identity, even if duplicates exist)
          const { error } = await sb
            .from(SCORE_TABLE)
            .update(payload)
            .eq("user_id", uuid)
            .eq("difficulty", diff.key)
            .gte("created_at", seasonStartIso);
          if(error) throw error;
          toast("Bestscore aktualisiert ✅", name+" • "+fmt(totalScore), 3200);
        } else {
          const { error } = await sb.from(SCORE_TABLE).insert(payload);
          if(error) throw error;
          toast("Score gepostet ✅", name+" • "+fmt(totalScore), 3200);
        }

        await refreshLeaderboard();
      }catch(e){
        toast("Post fehlgeschlagen ❌", String(e.message||e), 3400);
      }
    }

    function demoLeaderboardRows(diffKey){
      const now = new Date().toISOString();
      return [
        { player_name:"CandyQueen", score:184200, level:14, difficulty:diffKey, created_at:now, user_id:"demo-1" },
        { player_name:"KoalaChamp", score:152880, level:13, difficulty:diffKey, created_at:now, user_id:"demo-2" },
        { player_name:"LuvMaster", score:120440, level:12, difficulty:diffKey, created_at:now, user_id:"demo-3" },
        { player_name:"BubbleBuddy", score:84400, level:10, difficulty:diffKey, created_at:now, user_id:"demo-4" },
        { player_name:"Sourworm", score:64200, level:9, difficulty:diffKey, created_at:now, user_id:"demo-5" }
      ];
    }

    function renderLeaderboardRows(rows, note){
      const list = document.getElementById("lbList");
      list.innerHTML = "";
      // Ensure we always have visible podium rows
      const padded = [...rows];
      const demo = demoLeaderboardRows(rows[0]?.difficulty || diff.key);
      while(padded.length < 3 && demo.length){
        padded.push(demo[padded.length % demo.length]);
      }

      padded.forEach((x,i)=>{
        const item = document.createElement("div");
        item.className="lbItem";
        item.style.animationDelay = (i * 0.05) + "s";
        if(i===0) item.classList.add("rank1");
        if(i===1) item.classList.add("rank2");
        if(i===2) item.classList.add("rank3");

        const rankNum = i+1;
        const d = new Date(x.created_at || Date.now());
        const stamp = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.${d.getFullYear()} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
        item.innerHTML = `
          <div class="left">
            <b>${rankNum}. ${escapeHtml(x.player_name||"Anonymous")}</b>
            <small>Lvl ${x.level||1} • ${diffLabel(x.difficulty||"easy")} • ${stamp}</small>
          </div>
          <div class="score">${fmt(x.score||0)}</div>
        `;
        list.appendChild(item);
      });
      if(note){
        const info = document.createElement("div");
        info.className = "tiny";
        info.style.marginTop = "6px";
        info.textContent = note;
        list.appendChild(info);
      }
    }

    async function refreshLeaderboard(){
      if(ROGUE_MODE) return;
      const list = document.getElementById("lbList");
      const sel = document.getElementById("lbDiffSelect");
      // Prefer leaderboard tabs (lbDiff radios), fallback to hidden select, fallback to current game diff
      let dKey = document.querySelector('input[name="lbDiff"]:checked')?.value || (sel ? sel.value : diff.key);

      const season = currentSeasonStart();

      const title = document.getElementById("lbTitle");
      if(title) title.textContent = "Leaderboard • " + season.label;

      if(!sb){
        renderLeaderboardRows(demoLeaderboardRows(dKey), "Leaderboard aktuell nicht verfügbar – zeige Demo-Einträge.");
        return;
      }
      try{
        // Filter by selected difficulty
        const { data, error } = await sb
          .from(SCORE_TABLE)
          .select("player_name,score,level,difficulty,created_at,user_id")
          .eq('difficulty', dKey)
          .gte('created_at', season.isoTs)
          .order("score", { ascending:false })
          .limit(80);
        if(error) throw error;

        // Filter unique by UUID
        const unique = [];
        const seen = new Set();
        for(const row of (data||[])){
           const key = row.user_id || row.player_uuid || (row.player_name||"").toLowerCase();
           if(seen.has(key)) continue;
           seen.add(key);
           unique.push(row);
           if(unique.length >= 25) break;
        }

        if(!data || data.length===0 || unique.length===0){
          renderLeaderboardRows(demoLeaderboardRows(dKey), "Noch keine Scores – Demo-Einträge aktiviert. Poste deinen ersten Run!");
        } else {
          renderLeaderboardRows(unique, "");
        }
      }catch(e){
        const msg = String(e?.message || e || "Unbekannter Fehler");
        console.error("Leaderboard error:", e);
        renderLeaderboardRows(demoLeaderboardRows(dKey), "Leaderboard Fehler: "+escapeHtml(msg)+" (zeige Demo)");
      }
      syncLbHeight();
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    /**********************
     * Make Leaderboard same height as luvvies panel
     **********************/
    function syncLbHeight(){
      // Disabled
    }

    /**********************
     * Intro/Greet events
     **********************/
    function showGreetingIfNeeded(){
      // Show greeting about every 3 hours per device/UUID (instead of once per day)
      // This reduces "daily popups" while still keeping the welcome screen alive.
      try{ getUuid(); }catch(e){}
      const k = "luvvies_greet_ts";
      const last = Number(localStorage.getItem(k) || getCookie(k) || 0);
      const now = Date.now();
      const interval = 3 * 60 * 60 * 1000; // 3h
      if(!last || (now - last) > interval){
        document.getElementById("greetBack").style.display="flex";
      }
    }
    function closeGreeting(updateTs=true){
      if(updateTs){
        const k = "luvvies_greet_ts";
        const now = Date.now();
        localStorage.setItem(k, String(now));
        setCookie(k, String(now), 36500); // keep long-term
      }
      document.getElementById("greetBack").style.display="none";
    }

    document.getElementById("greetPlay").addEventListener("click", ()=>{
      closeGreeting(true);
      toast("Let’s go! ✨","Viel Spaß!", 2600);
    });
    document.getElementById("greetGuide").addEventListener("click", ()=>{
      closeGreeting(true);
      document.getElementById("introBack").style.display="flex";
    });

    document.getElementById("introClose").addEventListener("click", ()=>document.getElementById("introBack").style.display="none");
    document.getElementById("infoClose").addEventListener("click", ()=>document.getElementById("infoBack").style.display="none");

    /**********************
     * Buttons & Menu
     **********************/
    // Old listeners removed (btnNew, btnHint etc replaced by menu versions)

    // Main Menu Trigger
    const btnHintTop = document.getElementById("btnHintTop");
    if(btnHintTop) btnHintTop.addEventListener("click", hint);

    const btnReroll = document.getElementById("btnReroll");
    if(btnReroll) btnReroll.addEventListener("click", rerollTileTints);
    const fsReroll = document.getElementById("fsReroll");
    if(fsReroll) fsReroll.addEventListener("click", rerollTileTints);

    const fsToggleUi = document.getElementById("fsToggleUi");
    if(fsToggleUi) fsToggleUi.addEventListener("click", ()=>{
      const isShowing = document.body.classList.contains("showPanels");
      document.body.classList.toggle("showPanels", !isShowing);
      document.body.classList.toggle("hidePanels", isShowing);
      fsToggleUi.textContent = document.body.classList.contains("showPanels") ? "HIDE" : "SHOW";
      setTimeout(()=>{ try{ relayoutAll(false, true); }catch(e){} }, 30);
      setTimeout(()=>{ try{ syncBgHeight(); }catch(e){} }, 80);
      try{ positionComboModal(); }catch(e){}
    });

    document.getElementById("btnMenu").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "flex";
    });
    const menuCloseX = document.getElementById("menuCloseX");
    if(menuCloseX) menuCloseX.addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
    });

    // Menu Actions
    const startNewRun = () => {
       document.getElementById("settingsBack").style.display = "none";
       if(window.rogueEngine && typeof window.rogueEngine.startNewRun === "function"){
         window.rogueEngine.startNewRun();
       } else {
         newGame(false);
       }
    };
    const menuNew = document.getElementById("menuNew");
    if(menuNew) menuNew.addEventListener("click", startNewRun);
    const menuMap = document.getElementById("menuMap");
    if(menuMap) menuMap.addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       if(window.rogueEngine && typeof window.rogueEngine.showMap === "function") window.rogueEngine.showMap();
    });
    document.getElementById("menuHint").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       hint();
    });
    const mhq = document.getElementById("menuHintQuick");
    if(mhq) mhq.addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       hint();
    });

    // Fullscreen button removed (handled by top bar Maximize)
    document.getElementById("menuIntro").addEventListener("click", ()=>{
       document.getElementById("settingsBack").style.display = "none";
       document.getElementById("introBack").style.display = "flex";
    });
    const comboOk = document.getElementById("comboOk");
    if(comboOk) comboOk.addEventListener("click", ()=>{
      const back = document.getElementById("comboBack");
      if(back) back.style.display = "none";
    });
    window.addEventListener("resize", ()=>{ try{ positionComboModal(); }catch(e){} });

    document.getElementById("btnPost").addEventListener("click", postScore);
    document.getElementById("btnRefresh").addEventListener("click", refreshLeaderboard);

    const lbSel = document.getElementById("lbDiffSelect");
    if(lbSel) lbSel.addEventListener("change", refreshLeaderboard);

    // Leaderboard tabs (buttons like the top difficulty pills)
    function setLbDiff(key, doRefresh=true){
      const lbSel2 = document.getElementById("lbDiffSelect");
      if(lbSel2) lbSel2.value = key;

      const radios = document.querySelectorAll('input[name="lbDiff"]');
      radios.forEach(r => r.checked = (r.value === key));

      if(doRefresh) refreshLeaderboard();
    }

    const lbTabs = document.getElementById("lbTabs");
    if(lbTabs){
      lbTabs.addEventListener("change", ()=>{
        const v = document.querySelector('input[name="lbDiff"]:checked')?.value || (document.getElementById("lbDiffSelect")?.value) || diff.key;
        setLbDiff(v, true);
      });
    }


    // Dark Mode
    const btnTheme = document.getElementById("btnTheme");
    const globalThemeBtn = document.getElementById("globalThemeBtn");
    const fsMenuThemeBtn = document.getElementById("fsMenuTheme");
    const fsThemeHudBtn = document.getElementById("fsTheme");
    function syncTheme(){
      const isDark = document.body.classList.contains("dark");
      const label = isDark ? "Light" : "Dark";
      if(btnTheme) btnTheme.textContent = label;
      if(globalThemeBtn) globalThemeBtn.textContent = label;
      if(fsMenuThemeBtn) fsMenuThemeBtn.textContent = label;
      if(fsThemeHudBtn) fsThemeHudBtn.textContent = label;
      localStorage.setItem("luvvies_dark", isDark ? "1" : "0");
      if(typeof applyBiomeTheme === "function"){
        try{
          const current = (ROGUE && ROGUE.run && ROGUE.run.biomeId) ? biomeById(ROGUE.run.biomeId) : biomeById("forest");
          applyBiomeTheme(current);
        }catch(e){}
      }
    }
    function toggleTheme(){
      document.body.classList.toggle("dark");
      syncTheme();
    }
    if(localStorage.getItem("luvvies_dark")==="1"){
      document.body.classList.add("dark");
    }
    syncTheme();
    if(btnTheme) btnTheme.addEventListener("click", toggleTheme);
    if(globalThemeBtn) globalThemeBtn.addEventListener("click", toggleTheme);
    if(fsMenuThemeBtn) fsMenuThemeBtn.addEventListener("click", toggleTheme);
    if(fsThemeHudBtn) fsThemeHudBtn.addEventListener("click", toggleTheme);

    // Debug Tools
    const debugBtn = document.getElementById("debugBtn");
    const debugView = document.getElementById("debugView");
    const debugClose = document.getElementById("debugClose");
    const debugApply = document.getElementById("debugApply");
    function debugNum(id){
      const el = document.getElementById(id);
      if(!el) return 0;
      const v = parseInt(el.value, 10);
      return Number.isFinite(v) ? v : 0;
    }
    function applyDebugResources(){
      const res = ROGUE.meta.resources;
      res.gold += debugNum("dbgGold");
      res.wood += debugNum("dbgWood");
      res.stone += debugNum("dbgStone");
      res.essence += debugNum("dbgEssence");
      if(window.rogueEngine && window.rogueEngine.state){
        const st = window.rogueEngine.state;
        st.gold = (st.gold || 0) + debugNum("dbgRunGold");
        const addMax = debugNum("dbgRunMaxHp");
        if(addMax) st.maxHp = Math.max(1, (st.maxHp || 0) + addMax);
        const addHp = debugNum("dbgRunHp");
        if(addHp) st.hp = Math.max(0, (st.hp || 0) + addHp);
        if(st.maxHp != null && st.hp > st.maxHp) st.hp = st.maxHp;
      }
      saveRogueMeta();
      updateTownResources();
      renderTownCombos();
      renderTownMarket();
      updateRogueUI();
      try{ renderShop(); }catch(e){}
      if(window.rogueEngine && typeof window.rogueEngine.showMap === "function"){
        const mapView = document.getElementById("mapView");
        if(mapView && mapView.style.display === "flex") window.rogueEngine.showMap();
      }
      if(debugView) debugView.style.display = "none";
      ["dbgGold","dbgWood","dbgStone","dbgEssence","dbgRunGold","dbgRunHp","dbgRunMaxHp"].forEach(id=>{
        const el = document.getElementById(id);
        if(el) el.value = 0;
      });
    }
    if(debugBtn && debugView){
      debugBtn.addEventListener("click", ()=>{ debugView.style.display = "flex"; });
    }
    if(debugClose && debugView){
      debugClose.addEventListener("click", ()=>{ debugView.style.display = "none"; });
    }
    if(debugView){
      debugView.addEventListener("click", (e)=>{
        if(e.target === debugView) debugView.style.display = "none";
      });
    }
    if(debugApply) debugApply.addEventListener("click", applyDebugResources);

    // Maximize Button (fullscreen + draggable HUD)
      const btnMax = document.getElementById("btnMax");
      if(btnMax){
         btnMax.addEventListener("click", async ()=>{
            const shouldMax = !document.body.classList.contains("maximized");
            const root = document.documentElement;
            if(shouldMax){
              document.body.classList.add("maximized");
              layoutBoard();
              updateUI();
              try{
                if(!document.fullscreenElement){
                  await root.requestFullscreen();
                }
              }catch(e){}
            } else {
              document.body.classList.remove("maximized");
              layoutBoard();
              updateUI();
              try{
                if(document.fullscreenElement){
                  await document.exitFullscreen();
                }
              }catch(e){}
            }
         });
      }

    
    // Maximize HUD controls
    const btnUnmax = document.getElementById("btnUnmax");
    if(btnUnmax) btnUnmax.addEventListener("click", async ()=>{
       document.body.classList.remove("maximized");
       layoutBoard();
       updateUI();
       try{
         if(document.fullscreenElement){
           await document.exitFullscreen();
         }
       }catch(e){}
    });
    const maxHint = document.getElementById("maxHint");
    if(maxHint) maxHint.addEventListener("click", hint);

    // KOALA_DRAG_HUD: HUD (fsHud / maxHud) verschiebbar machen (damit es nicht im Weg ist)
    function makeHudDraggable(el, key){
      if(!el) return;
      const handle = el; // ganze Leiste draggable
      handle.style.cursor = "move";

      // Restore position
      try{
        const saved = localStorage.getItem(key);
        if(saved){
          const p = JSON.parse(saved);
          if(p && p.left && p.top){
            el.style.position = "fixed";
            el.style.left = p.left;
            el.style.top = p.top;
            el.style.transform = "none";
          }
        }
      }catch(e){}

      let dragging=false, sx=0, sy=0, ox=0, oy=0;
      handle.addEventListener("pointerdown", (e)=>{
        if(e.button!==0) return;

        // Nicht draggen wenn Buttons / Inputs geklickt werden
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
        const allowDrag = e.target && e.target.dataset && e.target.dataset.allowDrag === "1";
        if((tag==="button" || tag==="input" || tag==="select" || tag==="textarea") && !allowDrag) return;

        // Prevent default to stop scrolling/text selection
        e.preventDefault();

        dragging=true;
        try{ handle.setPointerCapture(e.pointerId); }catch(_e){}
        const r = el.getBoundingClientRect();
        sx=e.clientX; sy=e.clientY;
        ox=r.left; oy=r.top;

        el.style.position="fixed";
        el.style.left = r.left+"px";
        el.style.top  = r.top+"px";
        el.style.right = "auto";
        el.style.bottom = "auto";
        el.style.transform="none";
      });
      handle.addEventListener("pointermove", (e)=>{
        if(!dragging) return;
        e.preventDefault(); // crucial for touch
        const dx=e.clientX-sx, dy=e.clientY-sy;
        el.style.left = (ox+dx)+"px";
        el.style.top  = (oy+dy)+"px";
      });
      handle.addEventListener("pointerup", (e)=>{
        if(!dragging) return;
        dragging=false;
        try{ handle.releasePointerCapture(e.pointerId); }catch(_e){}
        try{
          localStorage.setItem(key, JSON.stringify({left: el.style.left, top: el.style.top}));
        }catch(_e){}
      });
    }

    // aktivieren (script läuft nach DOM)
        try{ makeHudDraggable(document.getElementById("maxHud"), "luvHudPos_max"); }catch(e){}
        try{ makeHudDraggable(document.getElementById("fsHud"), "luvHudPos_fs"); }catch(e){}
        
        try{
           const t = document.getElementById("toast");
           if(t){
              t.style.pointerEvents = "auto";
              makeHudDraggable(t, "luvToastPos");
           }
        }catch(e){}

// FX Slider (Dimmer Overlay)
    function updateFx(v){
      // v: 0-100. Opacity: 0 -> 0.7
      const op = (v / 100) * 0.7;
      const ov = document.getElementById("darkOverlay");
      if(ov) ov.style.opacity = op;

      // Reset filter on body if switching back from old method
      document.body.style.filter = "none";

      // Sync sliders
      if(document.getElementById("fxSlider")) document.getElementById("fxSlider").value = v;
      if(document.getElementById("fsMenuFx")) document.getElementById("fsMenuFx").value = v;
    }

    const FX_LIGHT_KEY = "luvvies_fx_light";
    function setFxLight(v){
      document.body.classList.toggle("fxLight", !!v);
      try{ localStorage.setItem(FX_LIGHT_KEY, v ? "1" : "0"); }catch(e){}
      const a = document.getElementById("fxLightToggle");
      const b = document.getElementById("fsMenuFxLight");
      if(a) a.checked = !!v;
      if(b) b.checked = !!v;
    }
    try{
      const raw = localStorage.getItem(FX_LIGHT_KEY);
      if(raw === "1") setFxLight(true);
    }catch(e){}
    const fxLightToggle = document.getElementById("fxLightToggle");
    if(fxLightToggle) fxLightToggle.addEventListener("change", (e)=>setFxLight(e.target.checked));
    const fsMenuFxLight = document.getElementById("fsMenuFxLight");
    if(fsMenuFxLight) fsMenuFxLight.addEventListener("change", (e)=>setFxLight(e.target.checked));

    const fxSlider = document.getElementById("fxSlider");
    fxSlider.addEventListener("input", (e)=>updateFx(e.target.value));

    const fsMenuFx = document.getElementById("fsMenuFx");
    if(fsMenuFx) fsMenuFx.addEventListener("input", (e)=>updateFx(e.target.value));

    document.getElementById("diffPills").addEventListener("change", ()=>{
      const v = document.querySelector('input[name="diff"]:checked').value;
      if(ROGUE_MODE){
        if(ROGUE.run.inCombat){
          toast("Gesperrt", "Schwierigkeit nur in der Stadt wechseln.", 1800);
          syncRogueDiffUI();
          return;
        }
        if(!isDiffUnlocked(v)){
          toast("Gesperrt", `${diffLabel(v)} ist noch nicht frei.`, 1800);
          syncRogueDiffUI();
          return;
        }
        setRogueDiff(v, true);
        return;
      }
      diff = DIFFS[v];

      // Sync leaderboard filter
      const lbSel = document.getElementById("lbDiffSelect");
      if(lbSel) lbSel.value = v;
      try{ if(typeof setLbDiff==="function") setLbDiff(v, false); }catch(e){}
      try{ refreshLeaderboard(); }catch(e){}

      newGame(true);
      buildGlobalBg();
      buildFsBg();
    });
    const townDiffPills = document.getElementById("townDiffPills");
    if(townDiffPills){
      townDiffPills.addEventListener("change", ()=>{
        if(!ROGUE_MODE) return;
        if(ROGUE.run.active){
          toast("Gesperrt", "Schwierigkeit nur vor dem Run wechseln.", 1800);
          syncRogueDiffUI();
          return;
        }
        const v = document.querySelector('input[name="rogueDiff"]:checked')?.value || "easy";
        if(!isDiffUnlocked(v)){
          toast("Gesperrt", `${diffLabel(v)} ist noch nicht frei.`, 1800);
          syncRogueDiffUI();
          return;
        }
        setRogueDiff(v, true);
      });
    }
    document.getElementById("fsHint").addEventListener("click", hint);
    // Menu Btn
    const btnMenu = document.getElementById("fsMenuBtn");
    if(btnMenu) btnMenu.addEventListener("click", ()=>{
       document.getElementById("fsMenuBack").style.display="flex";
    });

    const menuClose = document.getElementById("fsMenuClose");
    if(menuClose) menuClose.addEventListener("click", ()=>document.getElementById("fsMenuBack").style.display="none");

    const fsMenuMap = document.getElementById("fsMenuMap");
    if(fsMenuMap) fsMenuMap.addEventListener("click", ()=>{
       document.getElementById("fsMenuBack").style.display="none";
       if(window.rogueEngine && typeof window.rogueEngine.showMap === "function") window.rogueEngine.showMap();
    });

    const menuIntro = document.getElementById("fsMenuIntro");
    if(menuIntro) menuIntro.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    const menuLuv = document.getElementById("fsMenuLuv");
    if(menuLuv) menuLuv.addEventListener("click", ()=>{
       toast("Luvvies Menü", "Bitte Spiel beenden für Details", 2000);
    });
    const menuSaveColors = document.getElementById("menuSaveColors");
    if(menuSaveColors) menuSaveColors.addEventListener("click", saveTintSnapshot);
    const menuLoadColors = document.getElementById("menuLoadColors");
    if(menuLoadColors) menuLoadColors.addEventListener("click", applyTintSnapshot);

    // Theme toggle wired in syncTheme above.

    const fsMenuMax = document.getElementById("fsMenuMax");
    if(fsMenuMax) fsMenuMax.addEventListener("click", ()=>{
      const btnMax = document.getElementById("btnMax");
      if(btnMax) btnMax.click();
    });

    const fsMenuReroll = document.getElementById("fsMenuReroll");
    if(fsMenuReroll) fsMenuReroll.addEventListener("click", rerollTileTints);

    // Old FS listeners (kept for safety if buttons exist)
    const fsIntroBtn = document.getElementById("fsIntro");
    if(fsIntroBtn) fsIntroBtn.addEventListener("click", ()=>document.getElementById("introBack").style.display="flex");

    document.getElementById("fsExit").addEventListener("click", async ()=>{
      if(document.fullscreenElement) await document.exitFullscreen();
    });

    function resetTileTints(){
      TINT_OVERRIDES.clear();
      rerollTileTints();
      toast("Alle Farben zurückgesetzt 🔄", "Gespeicherte Farben gelöscht.", 2200);
    }

    const btnSaveColors = document.getElementById("btnSaveColors");
    if(btnSaveColors) btnSaveColors.addEventListener("click", () => {
       saveTintState();
       saveTintOverrides();
       toast("Farben gespeichert 💾", "Deine Auswahl ist gesichert.", 2000);
    });
    
    const fsSaveColors = document.getElementById("fsSaveColors");
    if(fsSaveColors) fsSaveColors.addEventListener("click", () => {
       saveTintState();
       saveTintOverrides();
       toast("Farben gespeichert 💾", "Deine Auswahl ist gesichert.", 2000);
    });

    const btnResetColors = document.getElementById("btnResetColors");
    if(btnResetColors) btnResetColors.addEventListener("click", resetTileTints);

    // Theme toggle wired in syncTheme above.

    /**********************
     * Boot
     **********************/
    attachResize();
    syncBgHeight();
    function refreshActivePool(){
      let pool = BASES.filter(b => (b.minLevel||1) <= level);
      if(ROGUE_MODE){
        const unlocked = new Set(ROGUE.meta.unlockedHeroes || []);
        pool = pool.filter(b => unlocked.has(b.key));
      }

      const pairs = [
        ["sleepy", "mond"],
        ["joyce", "smokey"],
        ["simba", "smokey"],
        ["grumpy", "happy"],
        ["donut", "sweety"]
      ];

      let max = 6;
      if(diff.key === "easy") max = 7;
      if(diff.key === "normal") max = 6;
      if(diff.key === "hard") max = 6;
      if(diff.key === "shock") max = 5;

      const selected = new Set();
      const add = (k) => {
         if(selected.has(k)) return;
         if(selected.size >= max) return;
         selected.add(k);
      };

      // Shuffle pool
      const shuffled = [...pool].sort(()=>Math.random()-0.5);

      for(const b of shuffled){
         if(selected.size >= max) break;

         const myPairs = pairs.filter(p => p.includes(b.key));
         if(myPairs.length > 0){
            // Has partner
            const partnerKey = myPairs[0].find(k => k !== b.key);
            // Check if partner exists in pool (level req)
            if(!pool.find(x=>x.key===partnerKey)){
               add(b.key); // Partner not available (level too low), add alone
               continue;
            }

            // Check space
            if(!selected.has(partnerKey) && selected.size >= max - 1){
               // Not enough space for pair
               continue;
            }
            add(b.key);
            add(partnerKey);
         } else {
            add(b.key);
         }
      }

      // Fallback fill
      if(selected.size < 4){
         for(const b of pool){
            if(selected.size >= max) break;
            add(b.key);
         }
      }

      gameActivePool = BASES.filter(b => selected.has(b.key));
    }

    // resetUnlocked();
    // newGame(true); <--- DISABLED FOR ROGUE MODE
    // showGreetingIfNeeded();
  </script>

  <style>
    /* ROGUE MODE STYLES */
    #charView {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        font-family: var(--kawaii-font);
    }
    #charView h2 {
        font-size: 2.5rem;
        margin-bottom: 30px;
        background: linear-gradient(45deg, #ff4fb9, #7ad8ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    #charList{
        display:grid;
        grid-auto-flow: column;
        grid-auto-columns: minmax(140px, 1fr);
        grid-template-rows: repeat(3, auto);
        gap: 14px;
        margin: 20px 0;
        padding: 14px;
        border-radius: 22px;
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.12);
        box-shadow: 0 18px 40px rgba(0,0,0,0.35);
        overflow-x: auto;
        scrollbar-width: thin;
    }
    #charList::-webkit-scrollbar{ height: 6px; }
    #charList::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.2); border-radius: 999px; }
    @media (max-width: 720px){
        #charList{ grid-template-rows: repeat(2, auto); }
    }
    .char-card {
        background: rgba(255,255,255,0.05);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 24px;
        padding: 14px;
        min-width: 140px;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s, border-color 0.2s, background 0.2s;
        backdrop-filter: blur(10px);
        display:flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }
    .char-card:hover {
        transform: translateY(-5px);
        border-color: #ff4fb9;
        background: rgba(255,255,255,0.1);
    }
    .char-card.selected {
        border-color: #ff4fb9;
        background: rgba(255, 79, 185, 0.2);
        box-shadow: 0 0 20px rgba(255, 79, 185, 0.3);
        transform: scale(1.05);
    }
    .char-card.locked{
        opacity: .6;
        filter: grayscale(.5);
    }
    .char-card.locked:hover{
        transform: none;
        border-color: rgba(255,255,255,0.1);
        background: rgba(255,255,255,0.05);
    }
    .char-card h3 {
        margin: 4px 0 0;
        font-size: 1rem;
        color: white;
    }
    .charArt{
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 18px;
        background:
          radial-gradient(circle at 20% 20%, rgba(255,255,255,.7), rgba(255,255,255,.15)),
          linear-gradient(160deg, rgba(255,255,255,.2), rgba(255,255,255,.05));
        border: 1px solid rgba(255,255,255,.15);
        box-shadow: inset 0 8px 18px rgba(255,255,255,.15);
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        overflow:hidden;
    }
    .charArt::after{
        content:"";
        position:absolute;
        inset:0;
        background: radial-gradient(circle at 70% 30%, rgba(255,255,255,.25), transparent 60%);
        pointer-events:none;
    }
    .charArt img {
        width: 85%;
        height: 85%;
        object-fit: contain;
        filter: drop-shadow(0 8px 12px rgba(0,0,0,0.3));
        z-index:1;
    }
    .charLvl{
        font-size: 12px;
        font-weight: 900;
        opacity: .85;
    }
    .charNote{
        font-size: 11px;
        opacity: .7;
        text-transform: uppercase;
        letter-spacing: .08em;
    }
    #mapView {
        background:
          radial-gradient(circle at 15% 15%, rgba(255,79,185,0.18), transparent 55%),
          radial-gradient(circle at 80% 20%, rgba(122,216,255,0.18), transparent 55%),
          linear-gradient(160deg, #2b1b3f, #181122);
    }
    body.rogue #mapView{
        background: var(--biome-page-bg) !important;
        color: var(--biome-ink) !important;
    }
    body.rogue #townView,
    body.rogue #shopView,
    body.rogue #charView{
        color: var(--biome-ink) !important;
    }
    body.rogue #townView{
        background: linear-gradient(160deg, #151326, #0c0a14) !important;
    }
    body.rogue #charView{
        background: linear-gradient(135deg, #1a1a2e, #16213e) !important;
    }
    body.rogue:not(.dark) #townView{
        background: linear-gradient(160deg, #f7f1fb, #eef4ff) !important;
    }
    body.rogue:not(.dark) #shopView{
        background: linear-gradient(160deg, #fff2f9, #f3f7ff) !important;
    }
    body.rogue:not(.dark) #charView{
        background: linear-gradient(135deg, #fff3fa, #f2f7ff) !important;
    }
    body.rogue:not(.dark) .stats,
    body.rogue:not(.dark) .progressRow{
        background: rgba(255,255,255,.86);
        border: 1px solid rgba(20,18,32,.12);
        box-shadow: 0 12px 24px rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .stat{
        background: rgba(255,255,255,.92);
        border: 1px solid rgba(20,18,32,.12);
        box-shadow: 0 10px 20px rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .stat .v{
        color: #3b4a67;
    }
    body.rogue:not(.dark) .playArea{
        background: rgba(255,255,255,.78);
        border: 1px solid rgba(20,18,32,.12);
        box-shadow: 0 18px 40px rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .hudChip,
    body.rogue:not(.dark) .hudBtn{
        background: rgba(255,255,255,.88);
        border: 1px solid rgba(20,18,32,.12);
        color: #2c2336;
    }
    body.rogue:not(.dark) .townCard,
    body.rogue:not(.dark) .townNote{
        background: rgba(255,255,255,.86);
        border: 1px solid rgba(20,18,32,.12);
        box-shadow: 0 14px 28px rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .townHeader,
    body.rogue:not(.dark) .shopHeader{
        background: rgba(255,255,255,.8);
        border: 1px solid rgba(20,18,32,.12);
        box-shadow: 0 12px 24px rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .townDiffRow .diffPills{
        background: rgba(255,255,255,.86);
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .comboCard{
        background: rgba(255,255,255,.92);
        border: 1px solid rgba(230,170,90,.4);
    }
    body.rogue:not(.dark) .comboBadge{
        background: rgba(255,230,190,.9);
        border-color: rgba(230,170,90,.5);
        color: #6b3a12;
    }
    body.rogue:not(.dark) .heroCard{
        background: rgba(255,255,255,.88);
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .shopItem,
    body.rogue:not(.dark) .shopBanner{
        background: rgba(255,255,255,.86);
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .shopItem:hover{
        box-shadow: 0 12px 24px rgba(20,18,32,.18);
    }
    body.rogue:not(.dark) .shopBubble{
        background: rgba(255,255,255,.98);
        color: #2c2336;
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .shopDecorImg{
        background: rgba(255,255,255,.96);
    }
    body.rogue:not(.dark) #charList{
        background: rgba(255,255,255,.7);
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) .char-card{
        background: rgba(255,255,255,.86);
        border: 1px solid rgba(20,18,32,.12);
    }
    body.rogue:not(.dark) #globalThemeBtn,
    body.rogue:not(.dark) #debugBtn{
        background: rgba(255,255,255,.92);
        color: #2c2336;
        border: 1px solid rgba(20,18,32,.18);
    }
    body.rogue:not(.dark) #mapFog{
        opacity: .45;
        mix-blend-mode: multiply;
        filter: blur(4px);
    }
    body.rogue:not(.dark) .map-node{
        color: #2c2336;
        background-color: rgba(255,255,255,0.6);
        border-color: rgba(20,18,32,0.18);
        box-shadow: 0 12px 22px rgba(20,18,32,0.18);
        text-shadow: 0 1px 4px rgba(255,255,255,0.8);
    }
    body.rogue:not(.dark) .map-node.active{
        border-color: var(--biome-accent);
        box-shadow: 0 14px 26px rgba(20,18,32,0.22);
    }
    body.rogue:not(.dark) .map-line{
        stroke: rgba(50,60,80,0.35);
        filter: drop-shadow(0 4px 10px rgba(20,18,32,0.18));
    }
    body.rogue:not(.dark) .map-line.active{
        stroke: var(--biome-accent);
        filter: drop-shadow(0 6px 12px rgba(20,18,32,0.22));
    }
    body.rogue:not(.dark) .map-line.done{
        stroke: rgba(90,120,160,0.45);
    }
    body.rogue #rightPanel,
    body.rogue #comboBack,
    body.rogue #lbTabs,
    body.rogue #lbList,
    body.rogue #lbTitle,
    body.rogue .lbRow,
    body.rogue #comboList{
        display: none !important;
    }
    body.rogue .stats,
    body.rogue .progressRow{
        background: rgba(18,16,30,.75);
        border: 1px solid rgba(255,255,255,.12);
        box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    body.rogue .stat{
        background: rgba(20,18,34,.72);
        border: 1px solid rgba(255,255,255,.12);
        box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    body.rogue .stat .k{
        text-transform: uppercase;
        letter-spacing: .12em;
        font-size: 10px;
    }
    body.rogue .stat .v{
        color: var(--biome-accent);
    }
    body.rogue .playArea{
        background: rgba(18,16,30,.82);
        border: 1px solid rgba(255,255,255,.12);
        box-shadow: 0 20px 50px rgba(0,0,0,.4);
    }
    body.rogue .hudChip{
        background: rgba(20,18,32,.85);
        border: 1px solid rgba(255,255,255,.12);
    }
    body.rogue .hudBtn{
        background: rgba(30,26,44,.85);
        border: 1px solid rgba(255,255,255,.12);
    }
    #globalThemeBtn,
    #debugBtn{
        position: fixed;
        right: 12px;
        z-index: 400000;
        padding: 8px 12px;
        border-radius: 999px;
        font-weight: 900;
        font-size: 12px;
        border: 1px solid rgba(255,255,255,.2);
        background: rgba(20,18,32,.9);
        color: #fff;
        box-shadow: 0 10px 24px rgba(0,0,0,.35);
        cursor: pointer;
    }
    #globalThemeBtn{ top: 12px; }
    #debugBtn{ top: 52px; display: none; }
    body.rogue #debugBtn{ display: inline-flex; }
    .debugModal{
        width: min(420px, 92vw);
        display:flex;
        flex-direction:column;
        gap: 12px;
    }
    .debugGrid{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
    .debugGrid label{
        display:flex;
        flex-direction:column;
        gap: 4px;
        font-size: 12px;
        font-weight: 900;
    }
    .debugGrid input{
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,.2);
        background: rgba(255,255,255,.9);
        font-weight: 900;
    }
    #debugView{
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(8,8,16,.7);
        z-index: 360000;
        padding: 20px;
        color: var(--biome-ink);
    }
    .debugModal{
        background: rgba(20,18,32,.92);
        border: 1px solid rgba(255,255,255,.12);
        border-radius: 18px;
        padding: 16px;
        box-shadow: 0 20px 45px rgba(0,0,0,.4);
    }
    body.rogue:not(.dark) #debugView{
        background: rgba(230,230,240,.75);
    }
    body.rogue:not(.dark) .debugModal{
        background: rgba(255,255,255,.92);
        border: 1px solid rgba(20,18,32,.12);
        color: #2c2336;
    }
    body.rogue:not(.dark) .debugGrid input{
        border: 1px solid rgba(20,18,32,.15);
        background: rgba(255,255,255,.98);
    }
    .townWrap{
        width: min(980px, 94vw);
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    .townHeader{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 18px;
        padding: 14px 16px;
        box-shadow: 0 18px 50px rgba(0,0,0,0.35);
    }
    .townRes{
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        font-weight: 900;
        font-size: 14px;
    }
    .townGrid{
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 14px;
    }
    .townDiffRow{
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }
    .townDiffRow .diffPills{
        padding: 6px;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 999px;
    }
    .diffPills input:disabled + label,
    .diffPills label.locked{
        opacity: 0.45;
        cursor: not-allowed;
        filter: grayscale(0.6);
    }
    .diffPills label.locked::after{
        content: " LOCK";
        font-size: 10px;
        font-weight: 900;
        letter-spacing: 0.08em;
        opacity: 0.8;
        margin-left: 6px;
    }
    .townSection{
        display:flex;
        flex-direction:column;
        gap:10px;
        margin-top: 6px;
    }
    .townSectionHead{
        display:flex;
        align-items:center;
        justify-content: space-between;
        gap: 12px;
        padding: 6px 4px;
    }
    .townNote{
        padding: 12px 14px;
        border-radius: 14px;
        background: rgba(255,255,255,0.08);
        border: 1px dashed rgba(255,255,255,0.18);
        font-size: 12px;
        opacity: 0.9;
    }
    .townCard{
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 18px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 16px 40px rgba(0,0,0,0.28);
    }
    .townCard .title{
        font-weight: 1000;
        font-size: 16px;
    }
    .townCard .desc{
        font-size: 12px;
        opacity: 0.85;
        line-height: 1.4;
    }
    .townCard .lvl{
        font-weight: 900;
        font-size: 13px;
        opacity: 0.9;
    }
    .townCard button{
        margin-top: auto;
        align-self: flex-start;
    }
    .comboCard .comboIconsSmall{
        display:flex;
        align-items:center;
        gap:6px;
        font-weight:900;
        font-size:12px;
        opacity:.9;
    }
    .comboCard .comboIconsSmall img{
        width:36px;
        height:36px;
        object-fit:contain;
        filter: drop-shadow(0 6px 10px rgba(0,0,0,.25));
    }
    .comboCard{
        position: relative;
        border: 1px solid rgba(255,207,90,0.35);
        background:
          radial-gradient(circle at 15% 15%, rgba(255,210,120,0.2), transparent 55%),
          linear-gradient(160deg, rgba(60,40,20,0.65), rgba(20,14,24,0.75));
    }
    .comboBadge{
        align-self: flex-start;
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 10px;
        font-weight: 900;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        background: rgba(255,207,90,0.22);
        border: 1px solid rgba(255,207,90,0.4);
        color: #ffe8b8;
    }
    .heroGrid{
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .heroCard{
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 18px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-height: 140px;
    }
    .heroCard .heroArt{
        width: 64px;
        height: 64px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.18);
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
    }
    .heroCard .heroArt img{
        width: 58px;
        height: 58px;
        object-fit: contain;
        filter: drop-shadow(0 8px 12px rgba(0,0,0,0.25));
    }
    .heroCard.locked .heroArt img{
        opacity: 0.55;
        filter: grayscale(0.65) drop-shadow(0 8px 12px rgba(0,0,0,0.2));
    }
    .heroCard .heroName{
        font-weight: 1000;
        font-size: 14px;
    }
    .heroCard .heroNote{
        font-size: 11px;
        opacity: 0.8;
    }
    .heroCard button{
        margin-top: auto;
        align-self: flex-start;
    }
    .marketCard .desc{
        font-weight:700;
        font-size:12px;
    }
    .townActions{
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        flex-wrap: wrap;
    }
    .shopWrap{
        width: min(720px, 94vw);
        display: flex;
        flex-direction: column;
        gap: 14px;
    }
    .shopHeader{
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 16px;
        padding: 12px 14px;
    }
    body.rogue #shopView{
        background:
          radial-gradient(circle at 15% 20%, rgba(255,209,90,.22), transparent 55%),
          radial-gradient(circle at 80% 15%, rgba(255,79,185,.22), transparent 55%),
          linear-gradient(160deg, #2a1938, #140c1d) !important;
    }
    .shopTitle{
        display:flex;
        align-items:center;
        gap:12px;
    }
    .shopHost{
        width:60px;
        height:60px;
        object-fit:contain;
        filter: drop-shadow(0 12px 20px rgba(0,0,0,.25));
    }
    .shopName{
        font-weight: 1000;
        letter-spacing: .03em;
    }
    .shopLine{
        font-size: 12px;
        font-weight: 700;
        opacity: .85;
    }
    .shopStats{
        display: flex;
        gap: 12px;
        font-weight: 900;
        font-size: 13px;
    }
    .shopBanner{
        display:flex;
        align-items:center;
        gap:12px;
        padding: 10px 12px;
        border-radius: 16px;
        background: rgba(255,255,255,0.1);
        border: 1px dashed rgba(255,255,255,0.18);
    }
    .shopCandy{
        width:52px;
        height:52px;
        object-fit:contain;
        filter: drop-shadow(0 10px 18px rgba(0,0,0,.2));
    }
    .shopBubble{
        background: rgba(255,255,255,0.92);
        color:#2a1849;
        font-weight: 900;
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 14px;
        border: 1px solid rgba(17,13,26,.12);
        box-shadow: 0 10px 22px rgba(0,0,0,.12);
    }
    .shopDecor{
        display:flex;
        gap:6px;
        margin-left:auto;
    }
    .shopDecorImg{
        width:28px;
        height:28px;
        object-fit:contain;
        border-radius:10px;
        background: rgba(255,255,255,0.85);
        padding: 4px;
        box-shadow: 0 6px 14px rgba(0,0,0,.18);
    }
    .shopGrid{
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
    }
    .shopItem{
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 16px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .shopItemHead{
        display:flex;
        align-items:center;
        gap:10px;
    }
    .shopIcon{
        width:44px;
        height:44px;
        object-fit:contain;
        filter: drop-shadow(0 8px 12px rgba(0,0,0,.2));
    }
    .shopItem:hover{
        transform: translateY(-2px);
        box-shadow: 0 14px 30px rgba(0,0,0,0.35);
    }
    .shopItem .title{
        font-weight: 1000;
        font-size: 14px;
    }
    .shopItem .desc{
        font-size: 12px;
        opacity: 0.85;
    }
    .shopItem .cost{
        font-weight: 900;
        font-size: 13px;
    }
    .shopNotes{
        font-size: 12px;
        opacity: 0.85;
        line-height: 1.4;
    }
    #mapGraph{
        position: relative;
        width: min(820px, 100%);
    }
    #mapFog{
        position:absolute;
        inset:0;
        pointer-events:none;
        z-index:3;
        background:
          radial-gradient(circle at 20% 20%, rgba(255,255,255,.08), transparent 55%),
          radial-gradient(circle at 75% 35%, rgba(255,255,255,.06), transparent 60%),
          linear-gradient(180deg, var(--biome-fog), rgba(10,10,20,0) 38%, rgba(10,10,20,0) 70%, var(--biome-fog));
        mix-blend-mode: screen;
        opacity:.7;
        filter: blur(6px);
    }
    #mapLines{
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }
    #mapNodes{
        width: 100%;
        display: flex;
        flex-direction: column-reverse;
        gap: 18px;
        align-items: center;
        padding-bottom: 90px;
        --map-cols: 5;
        position: relative;
        z-index: 2;
    }
    .map-row{
        width: 100%;
        display: grid;
        grid-template-columns: repeat(var(--map-cols), minmax(0, 1fr));
        gap: 18px;
        align-items: center;
        justify-items: center;
    }
    .map-node{
        width: 60px;
        height: 60px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        font-weight: 900;
        color: #fff;
        background-color: rgba(12,10,24,0.35);
        background-size: var(--map-tile-size, 48px 48px);
        background-repeat: repeat;
        background-position: center;
        border: 2px solid rgba(255,255,255,0.18);
        box-shadow: 0 12px 24px rgba(0,0,0,0.35);
        text-shadow: 0 2px 6px rgba(0,0,0,0.5);
        transform: translateX(var(--wiggle-x, 0px));
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .map-line{
        fill: none;
        stroke: rgba(255,255,255,0.25);
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(0 6px 14px rgba(0,0,0,0.45));
    }
    .map-line.active{
        stroke: rgba(255,207,90,0.9);
        stroke-width: 4;
        filter: drop-shadow(0 8px 18px rgba(255,207,90,0.35));
    }
    .map-line.done{
        stroke: rgba(122,216,255,0.55);
    }
    .map-slot{
        width: 60px;
        height: 60px;
        border-radius: 16px;
        opacity: 0;
        pointer-events: none;
    }
    .map-node.active{
        transform: translateX(var(--wiggle-x, 0px)) translateY(-2px) scale(1.05);
        border-color: rgba(255,207,90,0.9);
        box-shadow: 0 16px 30px rgba(0,0,0,0.45);
        cursor: pointer;
    }
    .map-node.locked{
        opacity: .35;
        filter: grayscale(.6);
        pointer-events: none;
    }
    .map-node.fogged{
        opacity: .25;
        filter: blur(1px) grayscale(.7);
    }
    .map-node.fogged::after{
        content:"";
        position:absolute;
        inset:-4px;
        border-radius: inherit;
        background:
          radial-gradient(circle at 30% 30%, rgba(255,255,255,.18), transparent 60%),
          radial-gradient(circle at 70% 70%, rgba(200,210,255,.12), transparent 65%),
          linear-gradient(140deg, rgba(20,20,40,.55), rgba(10,10,20,.2));
        mix-blend-mode: screen;
        pointer-events:none;
    }
    .map-node.done{
        opacity: .6;
        filter: grayscale(.25);
    }
    @media (max-width: 520px){
        #mapNodes{ gap: 14px; }
        .map-row{ gap: 14px; }
        .map-node{ width: 52px; height: 52px; font-size: 18px; border-radius: 14px; }
        .map-slot{ width: 52px; height: 52px; border-radius: 14px; }
    }
  </style>

  <script src="rogue.js"></script>
  <script>
    // ROGUE AUTO-BOOT
    (function boot() {
        // Force hide main game page initially
        document.getElementById("page").style.display = "none";
        
        if(window.rogueEngine) {
            console.log("Rogue Engine detected, initializing...");
            setupRogueHooks();
            initRogueUI();
            window.rogueEngine.init();
            if(ROGUE_MODE) showTown(true);
        } else {
            console.log("Waiting for rogueEngine...");
            setTimeout(boot, 100);
        }
    })();
  </script>
</body></html>


